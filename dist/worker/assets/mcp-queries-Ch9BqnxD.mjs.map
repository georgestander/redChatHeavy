{"version":3,"file":"mcp-queries-Ch9BqnxD.mjs","sources":["../../../lib/db/mcp-queries.ts"],"sourcesContent":["\"use server\";\n\nimport type {\n  OAuthClientInformation,\n  OAuthClientMetadata,\n  OAuthTokens,\n} from \"@ai-sdk/mcp\";\nimport { and, desc, eq, isNotNull, isNull, ne, or, sql } from \"drizzle-orm\";\nimport { db } from \"./client\";\nimport {\n  type McpConnector,\n  type McpOAuthSession,\n  mcpConnector,\n  mcpOAuthSession,\n} from \"./schema\";\n\n// Full client information includes both metadata and registration response\nexport type OAuthClientInformationFull = OAuthClientMetadata &\n  OAuthClientInformation;\n\n// MCP Connector queries\n\nexport async function getMcpConnectorsByUserId({\n  userId,\n}: {\n  userId: string;\n}): Promise<McpConnector[]> {\n  try {\n    return await db\n      .select()\n      .from(mcpConnector)\n      .where(or(eq(mcpConnector.userId, userId), isNull(mcpConnector.userId)))\n      .orderBy(desc(mcpConnector.createdAt));\n  } catch (error) {\n    console.error(\"Failed to get MCP connectors from database\", error);\n    throw error;\n  }\n}\n\nexport async function getMcpConnectorById({\n  id,\n}: {\n  id: string;\n}): Promise<McpConnector | undefined> {\n  try {\n    const [connector] = await db\n      .select()\n      .from(mcpConnector)\n      .where(eq(mcpConnector.id, id));\n    return connector;\n  } catch (error) {\n    console.error(\"Failed to get MCP connector by id from database\", error);\n    throw error;\n  }\n}\n\nexport async function getMcpConnectorByNameId({\n  userId,\n  nameId,\n  excludeId,\n}: {\n  userId: string | null;\n  nameId: string;\n  excludeId?: string;\n}): Promise<McpConnector | undefined> {\n  try {\n    const conditions = [\n      eq(mcpConnector.nameId, nameId),\n      userId === null\n        ? isNull(mcpConnector.userId)\n        : eq(mcpConnector.userId, userId),\n    ];\n\n    const whereClause = excludeId\n      ? and(...conditions, sql`${mcpConnector.id} != ${excludeId}::uuid`)\n      : and(...conditions);\n\n    const [connector] = await db.select().from(mcpConnector).where(whereClause);\n    return connector;\n  } catch (error) {\n    console.error(\"Failed to get MCP connector by nameId from database\", error);\n    throw error;\n  }\n}\n\nexport async function createMcpConnector({\n  userId,\n  name,\n  nameId,\n  url,\n  type,\n  oauthClientId,\n  oauthClientSecret,\n}: {\n  userId: string | null;\n  name: string;\n  nameId: string;\n  url: string;\n  type: \"http\" | \"sse\";\n  oauthClientId?: string;\n  oauthClientSecret?: string;\n}): Promise<McpConnector> {\n  try {\n    const [connector] = await db\n      .insert(mcpConnector)\n      .values({\n        userId,\n        name,\n        nameId,\n        url,\n        type,\n        oauthClientId: oauthClientId ?? null,\n        oauthClientSecret: oauthClientSecret ?? null,\n      })\n      .returning();\n    return connector;\n  } catch (error) {\n    console.error(\"Failed to create MCP connector in database\", error);\n    throw error;\n  }\n}\n\nexport async function updateMcpConnector({\n  id,\n  updates,\n}: {\n  id: string;\n  updates: Partial<{\n    name: string;\n    nameId: string;\n    url: string;\n    type: \"http\" | \"sse\";\n    oauthClientId: string | null;\n    oauthClientSecret: string | null;\n    enabled: boolean;\n  }>;\n}): Promise<void> {\n  try {\n    await db\n      .update(mcpConnector)\n      .set({\n        ...updates,\n        updatedAt: new Date(),\n      })\n      .where(eq(mcpConnector.id, id));\n  } catch (error) {\n    console.error(\"Failed to update MCP connector in database\", error);\n    throw error;\n  }\n}\n\nexport async function deleteMcpConnector({\n  id,\n}: {\n  id: string;\n}): Promise<void> {\n  try {\n    await db.delete(mcpConnector).where(eq(mcpConnector.id, id));\n  } catch (error) {\n    console.error(\"Failed to delete MCP connector from database\", error);\n    throw error;\n  }\n}\n\n// MCP OAuth Session queries\n\nexport async function getAuthenticatedSession({\n  mcpConnectorId,\n}: {\n  mcpConnectorId: string;\n}): Promise<McpOAuthSession | undefined> {\n  const [session] = await db\n    .select()\n    .from(mcpOAuthSession)\n    .where(\n      and(\n        eq(mcpOAuthSession.mcpConnectorId, mcpConnectorId),\n        isNotNull(mcpOAuthSession.tokens)\n      )\n    )\n    .orderBy(desc(mcpOAuthSession.updatedAt))\n    .limit(1);\n  return session;\n}\n\nexport async function getSessionByState({\n  state,\n}: {\n  state: string;\n}): Promise<McpOAuthSession | undefined> {\n  if (!state) {\n    return;\n  }\n  const [session] = await db\n    .select()\n    .from(mcpOAuthSession)\n    .where(eq(mcpOAuthSession.state, state));\n  return session;\n}\n\nexport async function createOAuthSession({\n  mcpConnectorId,\n  serverUrl,\n  state,\n  codeVerifier,\n  clientInfo,\n}: {\n  mcpConnectorId: string;\n  serverUrl: string;\n  state: string;\n  codeVerifier?: string;\n  clientInfo?: OAuthClientInformationFull;\n}): Promise<McpOAuthSession> {\n  const [session] = await db\n    .insert(mcpOAuthSession)\n    .values({\n      mcpConnectorId,\n      serverUrl,\n      state,\n      codeVerifier,\n      clientInfo,\n    })\n    .returning();\n  return session;\n}\n\nexport async function setOAuthCodeVerifierOnceByState({\n  state,\n  codeVerifier,\n}: {\n  state: string;\n  codeVerifier: string;\n}): Promise<McpOAuthSession> {\n  const [updated] = await db\n    .update(mcpOAuthSession)\n    .set({ codeVerifier })\n    .where(\n      and(\n        eq(mcpOAuthSession.state, state),\n        isNull(mcpOAuthSession.codeVerifier)\n      )\n    )\n    .returning();\n\n  if (updated) {\n    return updated;\n  }\n\n  const [existingSession] = await db\n    .select()\n    .from(mcpOAuthSession)\n    .where(eq(mcpOAuthSession.state, state));\n  if (!existingSession) {\n    throw new Error(`Session with state ${state} not found`);\n  }\n  return existingSession;\n}\n\nexport async function setOAuthClientInfoOnceByState({\n  state,\n  clientInfo,\n}: {\n  state: string;\n  clientInfo: OAuthClientInformationFull;\n}): Promise<McpOAuthSession> {\n  const [updated] = await db\n    .update(mcpOAuthSession)\n    .set({ clientInfo })\n    .where(\n      and(eq(mcpOAuthSession.state, state), isNull(mcpOAuthSession.clientInfo))\n    )\n    .returning();\n\n  if (updated) {\n    return updated;\n  }\n\n  const [existingSession] = await db\n    .select()\n    .from(mcpOAuthSession)\n    .where(eq(mcpOAuthSession.state, state));\n  if (!existingSession) {\n    throw new Error(`Session with state ${state} not found`);\n  }\n  return existingSession;\n}\n\nexport async function updateSessionByState({\n  state,\n  updates,\n}: {\n  state: string;\n  updates: {\n    tokens?: OAuthTokens | null;\n    clientInfo?: OAuthClientInformationFull | null;\n    codeVerifier?: string | null;\n  };\n}): Promise<McpOAuthSession> {\n  // Filter out undefined values - only include explicit values (including null)\n  const setValues = Object.fromEntries(\n    Object.entries(updates).filter(([_, v]) => v !== undefined)\n  );\n\n  if (Object.keys(setValues).length === 0) {\n    const [existingSession] = await db\n      .select()\n      .from(mcpOAuthSession)\n      .where(eq(mcpOAuthSession.state, state));\n    if (!existingSession) {\n      throw new Error(`Session with state ${state} not found`);\n    }\n    return existingSession;\n  }\n\n  const [session] = await db\n    .update(mcpOAuthSession)\n    .set(setValues)\n    .where(eq(mcpOAuthSession.state, state))\n    .returning();\n  if (!session) {\n    throw new Error(`Session with state ${state} not found`);\n  }\n  return session;\n}\n\nexport async function saveTokensAndCleanup({\n  state,\n  mcpConnectorId,\n  tokens,\n}: {\n  state: string;\n  mcpConnectorId: string;\n  tokens: OAuthTokens;\n}): Promise<McpOAuthSession> {\n  const [session] = await db\n    .update(mcpOAuthSession)\n    .set({ tokens })\n    .where(eq(mcpOAuthSession.state, state))\n    .returning();\n\n  if (!session) {\n    throw new Error(`Session with state ${state} not found`);\n  }\n\n  await db\n    .delete(mcpOAuthSession)\n    .where(\n      and(\n        eq(mcpOAuthSession.mcpConnectorId, mcpConnectorId),\n        isNull(mcpOAuthSession.tokens),\n        ne(mcpOAuthSession.state, state)\n      )\n    );\n\n  return session;\n}\n\nexport async function deleteSessionByState({\n  state,\n}: {\n  state: string;\n}): Promise<void> {\n  await db.delete(mcpOAuthSession).where(eq(mcpOAuthSession.state, state));\n}\n\nexport async function deleteSessionsByConnectorId({\n  mcpConnectorId,\n}: {\n  mcpConnectorId: string;\n}): Promise<void> {\n  await db\n    .delete(mcpOAuthSession)\n    .where(eq(mcpOAuthSession.mcpConnectorId, mcpConnectorId));\n}\n"],"names":["getMcpConnectorsByUserId","userId","db","mcpConnector","or","eq","isNull","desc","error","getMcpConnectorById","id","connector","getMcpConnectorByNameId","nameId","excludeId","conditions","whereClause","and","sql","createMcpConnector","name","url","type","oauthClientId","oauthClientSecret","updateMcpConnector","updates","deleteMcpConnector","getAuthenticatedSession","mcpConnectorId","session","mcpOAuthSession","isNotNull","getSessionByState","state","createOAuthSession","serverUrl","codeVerifier","clientInfo","setOAuthCodeVerifierOnceByState","updated","existingSession","setOAuthClientInfoOnceByState","updateSessionByState","setValues","_","v","saveTokensAndCleanup","tokens","ne","deleteSessionByState","deleteSessionsByConnectorId"],"mappings":"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"}