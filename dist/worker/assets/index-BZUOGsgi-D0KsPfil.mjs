import{aB as L,az as T,aC as N}from"./index-CPesPnUn.mjs";import{aD as se}from"./index-CPesPnUn.mjs";import"node:events";import"cloudflare:workers";import"async_hooks";import"node:os";import"node:diagnostics_channel";import"fs";import"events";import"util";import"path";import"assert";import"node:stream";import"module";import"node:path";import"url";import"buffer";import"crypto";import"node:crypto";const ne=(F,y)=>{let x=null;const _=h=>({getFieldName:b,schema:R,getDefaultFieldName:D,getDefaultModelName:q,getFieldAttributes:I,getModelName:j})=>{const M=l=>{const d=[],a=[];if(l)for(const[r,o]of Object.entries(l)){const t=R[q(r)]?.fields,[e,s]=r.includes(".")?r.split("."):[void 0,r];if(t){t.id={type:"string"};for(const[n,u]of Object.entries(t))d.push(N`${N.ref(`join_${s}`)}.${N.ref(u.fieldName||n)} as ${N.ref(`_joined_${s}_${u.fieldName||n}`)}`),a.push({joinModel:r,joinModelRef:s,fieldName:u.fieldName||n})}}return{allSelectsStr:a,allSelects:d}},O=async(l,d,a,r)=>{let o;if(y?.type==="mysql"){await d.execute();const t=l.id?"id":r.length>0&&r[0]?.field?r[0].field:"id";if(!l.id&&r.length===0)return o=await h.selectFrom(a).selectAll().orderBy(b({model:a,field:t}),"desc").limit(1).executeTakeFirst(),o;const e=l[t]||r[0]?.value;return o=await h.selectFrom(a).selectAll().orderBy(b({model:a,field:t}),"desc").where(b({model:a,field:t}),"=",e).limit(1).executeTakeFirst(),o}return y?.type==="mssql"?(o=await d.outputAll("inserted").executeTakeFirst(),o):(o=await d.returningAll().executeTakeFirst(),o)};function $(l,d){if(!d)return{and:null,or:null};const a={and:[],or:[]};return d.forEach(r=>{const{field:o,value:t,operator:e="=",connector:s="AND"}=r,n=t,u=b({model:l,field:o}),m=p=>{const i=`${l}.${u}`;return e.toLowerCase()==="in"?p(i,"in",Array.isArray(n)?n:[n]):e.toLowerCase()==="not_in"?p(i,"not in",Array.isArray(n)?n:[n]):e==="contains"?p(i,"like",`%${n}%`):e==="starts_with"?p(i,"like",`${n}%`):e==="ends_with"?p(i,"like",`%${n}`):e==="eq"?p(i,"=",n):e==="ne"?p(i,"<>",n):e==="gt"?p(i,">",n):e==="gte"?p(i,">=",n):e==="lt"?p(i,"<",n):e==="lte"?p(i,"<=",n):p(i,e,n)};s==="OR"?a.or.push(m):a.and.push(m)}),{and:a.and.length?a.and:null,or:a.or.length?a.or:null}}function S(l,d,a){if(!d||!l.length)return l;const r=new Map;for(const t of l){const e={},s={};for(const[m]of Object.entries(d))s[j(m)]={};for(const[m,p]of Object.entries(t)){const i=String(m);let c=!1;for(const{joinModel:f,fieldName:w,joinModelRef:g}of a)if(i===`_joined_${g}_${w}`){s[j(f)][b({model:f,field:w})]=p,c=!0;break}c||(e[m]=p)}const n=e.id;if(!n)continue;if(!r.has(n)){const m={...e};for(const[p,i]of Object.entries(d))m[j(p)]=i.relation==="one-to-one"?null:[];r.set(n,m)}const u=r.get(n);for(const[m,p]of Object.entries(d)){const i=p.relation==="one-to-one",c=p.limit??100,f=s[j(m)],w=f&&Object.keys(f).length>0&&Object.values(f).some(g=>g!=null);if(i)u[j(m)]=w?f:null;else{const g=j(m);if(Array.isArray(u[g])&&w){if(u[g].length>=c)continue;const k=b({model:m,field:"id"}),E=f[k];E?!u[g].some(B=>B[k]===E)&&u[g].length<c&&u[g].push(f):u[g].length<c&&u[g].push(f)}}}}const o=Array.from(r.values());for(const t of o)for(const[e,s]of Object.entries(d))if(s.relation!=="one-to-one"){const n=j(e);if(Array.isArray(t[n])){const u=s.limit??100;t[n].length>u&&(t[n]=t[n].slice(0,u))}}return o}return{async create({data:l,model:d}){return await O(l,h.insertInto(d).values(l),d,[])},async findOne({model:l,where:d,select:a,join:r}){const{and:o,or:t}=$(l,d);let e=h.selectFrom(p=>{let i=p.selectFrom(l);return o&&(i=i.where(c=>c.and(o.map(f=>f(c))))),t&&(i=i.where(c=>c.or(t.map(f=>f(c))))),i.selectAll().as("primary")}).selectAll("primary");if(r)for(const[p,i]of Object.entries(r)){const[c,f]=p.includes(".")?p.split("."):[void 0,p];e=e.leftJoin(`${p} as join_${f}`,w=>w.onRef(`join_${f}.${i.on.to}`,"=",`primary.${i.on.from}`))}const{allSelectsStr:s,allSelects:n}=M(r);e=e.select(n);const u=await e.execute();if(!u||!Array.isArray(u)||u.length===0)return null;const m=u[0];return r?S(u,r,s)[0]:m},async findMany({model:l,where:d,limit:a,offset:r,sortBy:o,join:t}){const{and:e,or:s}=$(l,d);let n=h.selectFrom(i=>{let c=i.selectFrom(l);return y?.type==="mssql"?r!==void 0?(o||(c=c.orderBy(b({model:l,field:"id"}))),c=c.offset(r).fetch(a||100)):a!==void 0&&(c=c.top(a)):(a!==void 0&&(c=c.limit(a)),r!==void 0&&(c=c.offset(r))),o?.field&&(c=c.orderBy(`${b({model:l,field:o.field})}`,o.direction)),e&&(c=c.where(f=>f.and(e.map(w=>w(f))))),s&&(c=c.where(f=>f.or(s.map(w=>w(f))))),c.selectAll().as("primary")}).selectAll("primary");if(t)for(const[i,c]of Object.entries(t)){const[f,w]=i.includes(".")?i.split("."):[void 0,i];n=n.leftJoin(`${i} as join_${w}`,g=>g.onRef(`join_${w}.${c.on.to}`,"=",`primary.${c.on.from}`))}const{allSelectsStr:u,allSelects:m}=M(t);n=n.select(m),o?.field&&(n=n.orderBy(`${b({model:l,field:o.field})}`,o.direction));const p=await n.execute();return p?t?S(p,t,u):p:[]},async update({model:l,where:d,update:a}){const{and:r,or:o}=$(l,d);let t=h.updateTable(l).set(a);return r&&(t=t.where(e=>e.and(r.map(s=>s(e))))),o&&(t=t.where(e=>e.or(o.map(s=>s(e))))),await O(a,t,l,d)},async updateMany({model:l,where:d,update:a}){const{and:r,or:o}=$(l,d);let t=h.updateTable(l).set(a);r&&(t=t.where(s=>s.and(r.map(n=>n(s))))),o&&(t=t.where(s=>s.or(o.map(n=>n(s)))));const e=(await t.executeTakeFirst()).numUpdatedRows;return e>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:Number(e)},async count({model:l,where:d}){const{and:a,or:r}=$(l,d);let o=h.selectFrom(l).select(h.fn.count("id").as("count"));a&&(o=o.where(e=>e.and(a.map(s=>s(e))))),r&&(o=o.where(e=>e.or(r.map(s=>s(e)))));const t=await o.execute();return typeof t[0].count=="number"?t[0].count:typeof t[0].count=="bigint"?Number(t[0].count):parseInt(t[0].count)},async delete({model:l,where:d}){const{and:a,or:r}=$(l,d);let o=h.deleteFrom(l);a&&(o=o.where(t=>t.and(a.map(e=>e(t))))),r&&(o=o.where(t=>t.or(r.map(e=>e(t))))),await o.execute()},async deleteMany({model:l,where:d}){const{and:a,or:r}=$(l,d);let o=h.deleteFrom(l);a&&(o=o.where(e=>e.and(a.map(s=>s(e))))),r&&(o=o.where(e=>e.or(r.map(s=>s(e)))));const t=(await o.executeTakeFirst()).numDeletedRows;return t>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:Number(t)},options:y}};let A=null;A={config:{adapterId:"kysely",adapterName:"Kysely Adapter",usePlural:y?.usePlural,debugLogs:y?.debugLogs,supportsBooleans:!(y?.type==="sqlite"||y?.type==="mssql"||y?.type==="mysql"||!y?.type),supportsDates:!(y?.type==="sqlite"||y?.type==="mssql"||!y?.type),supportsJSON:y?.type==="postgres",supportsArrays:!1,supportsUUIDs:y?.type==="postgres",transaction:y?.transaction?h=>F.transaction().execute(b=>h(T({config:A.config,adapter:_(b)})(x))):!1},adapter:_(F)};const v=T(A);return h=>(x=h,v(h))};export{L as createKyselyAdapter,se as getKyselyDatabaseType,ne as kyselyAdapter};
//# sourceMappingURL=index-BZUOGsgi-D0KsPfil.mjs.map
