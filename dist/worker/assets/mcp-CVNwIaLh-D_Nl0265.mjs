import{q as J,R as re,n as ne,c as m,W as o,a6 as it,E as Ut,A as se,a7 as Et,a as E,a8 as oe,a9 as Rt,aa as ie,ab as ae,ac as ce,ad as X,ae as p,a4 as g,O as k,$ as Z,T as b,a3 as Tt,af as kt,ag as zt,U as pt,ah as V,ai as Ot,V as M,aj as le,ak as ue,H as he,m as S}from"./index-CPesPnUn.mjs";import{randomUUID as de}from"node:crypto";import{getAuthenticatedSession as xt,createMcpConnector as pe,deleteMcpConnector as me,deleteSessionsByConnectorId as fe,getMcpConnectorsByUserId as Mt,updateMcpConnector as $t,getMcpConnectorById as we,getMcpConnectorByNameId as ge,getSessionByState as yt,createOAuthSession as ye,updateSessionByState as _e,deleteSessionByState as _t,setOAuthClientInfoOnceByState as ve,saveTokensAndCleanup as Ce,setOAuthCodeVerifierOnceByState as Ie}from"./mcp-queries-Ch9BqnxD-RNg6oCaj.mjs";import"node:events";import"cloudflare:workers";import"async_hooks";import"node:os";import"node:diagnostics_channel";import"fs";import"events";import"util";import"path";import"assert";import"node:stream";import"module";import"node:path";import"url";import"buffer";import"crypto";const at=it("mcp-cache"),ct={connectionStatus:e=>`mcp-connection-status-${e}`,discovery:e=>`mcp-discovery-${e}`};function Dt(e,t){return Et(()=>(at.debug({connectorId:e},"Fetching connection status (cache miss)"),t()),["mcp-connection-status",e],{revalidate:300,tags:[ct.connectionStatus(e)]})}function Ae(e,t){return Et(()=>(at.debug({connectorId:e},"Fetching discovery (cache miss)"),t()),["mcp-discovery",e],{revalidate:300,tags:[ct.discovery(e)]})}function be(e){at.debug({connectorId:e},"Invalidating connection status cache"),Rt(ct.connectionStatus(e))}function Se(e){at.debug({connectorId:e},"Invalidating discovery cache"),Rt(ct.discovery(e))}function Q(e){be(e),Se(e)}let mt;mt=globalThis.crypto;async function Pe(e){return(await mt).getRandomValues(new Uint8Array(e))}async function Ue(e){const t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~",r=Math.pow(2,8)-Math.pow(2,8)%t.length;let n="";for(;n.length<e;){const s=await Pe(e-n.length);for(const i of s)i<r&&(n+=t[i%t.length])}return n}async function Ee(e){return await Ue(e)}async function Re(e){const t=await(await mt).subtle.digest("SHA-256",new TextEncoder().encode(e));return btoa(String.fromCharCode(...new Uint8Array(t))).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,"")}async function Te(e){if(e||(e=43),e<43||e>128)throw`Expected a length between 43 and 128. Received ${e}.`;const t=await Ee(e),r=await Re(t);return{code_verifier:t,code_challenge:r}}var ke="AI_MCPClientError",qt=`vercel.ai.error.${ke}`,ze=Symbol.for(qt),vt,Ct,y=class extends(Ct=X,vt=ze,Ct){constructor({name:e="MCPClientError",message:t,cause:r,data:n,code:s}){super({name:e,message:t,cause:r}),this[vt]=!0,this.data=n,this.code=s}static isInstance(e){return X.hasMarker(e,qt)}},L="2025-06-18",Oe=[L,"2025-03-26","2024-11-05"],xe=p(Tt(o(),Z())),Me=V({name:o(),version:o()}),lt=V({_meta:p(m({}).loose())}),O=lt,Vt=m({method:o(),params:p(lt)}),Ht=m({applyDefaults:p(E())}).loose(),$e=V({experimental:p(m({}).loose()),logging:p(m({}).loose()),prompts:p(V({listChanged:p(E())})),resources:p(V({subscribe:p(E()),listChanged:p(E())})),tools:p(V({listChanged:p(E())})),elicitation:p(Ht)});m({elicitation:p(Ht)}).loose();var De=O.extend({protocolVersion:o(),capabilities:$e,serverInfo:Me,instructions:p(o())}),ft=O.extend({nextCursor:p(o())}),qe=m({name:o(),description:p(o()),inputSchema:m({type:b("object"),properties:p(m({}).loose())}).loose(),annotations:p(m({title:p(o())}).loose()),_meta:xe}).loose(),Ve=ft.extend({tools:g(qe)}),Lt=m({type:b("text"),text:o()}).loose(),jt=m({type:b("image"),data:Ot(),mimeType:o()}).loose(),He=m({uri:o(),name:o(),title:p(o()),description:p(o()),mimeType:p(o()),size:p(M())}).loose(),Le=ft.extend({resources:g(He)}),Nt=m({uri:o(),name:p(o()),title:p(o()),mimeType:p(o())}).loose(),Ft=Nt.extend({text:o()}),Bt=Nt.extend({blob:Ot()}),Jt=m({type:b("resource"),resource:k([Ft,Bt])}).loose(),je=O.extend({content:g(k([Lt,jt,Jt])),isError:E().default(!1).optional()}).or(O.extend({toolResult:Z()})),Ne=m({uriTemplate:o(),name:o(),title:p(o()),description:p(o()),mimeType:p(o())}).loose(),Fe=O.extend({resourceTemplates:g(Ne)}),Be=O.extend({contents:g(k([Ft,Bt]))}),Je=m({name:o(),description:p(o()),required:p(E())}).loose(),We=m({name:o(),title:p(o()),description:p(o()),arguments:p(g(Je))}).loose(),Ze=ft.extend({prompts:g(We)}),Ge=m({role:k([b("user"),b("assistant")]),content:k([Lt,jt,Jt])}).loose(),Ke=O.extend({description:p(o()),messages:g(Ge)}),Ye=lt.extend({message:o(),requestedSchema:Z()}),It=Vt.extend({method:b("elicitation/create"),params:Ye}),Xe=O.extend({action:k([b("accept"),b("decline"),b("cancel")]),content:p(Tt(o(),Z()))}),ut="2.0",Qe=m({jsonrpc:b(ut),id:k([o(),M().int()])}).merge(Vt).strict(),tr=m({jsonrpc:b(ut),id:k([o(),M().int()]),result:O}).strict(),er=m({jsonrpc:b(ut),id:k([o(),M().int()]),error:m({code:M().int(),message:o(),data:p(Z())})}).strict(),rr=m({jsonrpc:b(ut)}).merge(m({method:o(),params:p(lt)})).strict(),B=k([Qe,rr,tr,er]),Wt=typeof __PACKAGE_VERSION__<"u"?__PACKAGE_VERSION__:"0.0.0-test",Zt=m({access_token:o(),id_token:o().optional(),token_type:o(),expires_in:M().optional(),scope:o().optional(),refresh_token:o().optional()}).strip(),A=o().url().superRefine((e,t)=>{if(!URL.canParse(e))return t.addIssue({code:ue.custom,message:"URL must be parseable",fatal:!0}),le}).refine(e=>{const t=new URL(e);return t.protocol!=="javascript:"&&t.protocol!=="data:"&&t.protocol!=="vbscript:"},{message:"URL cannot use javascript:, data:, or vbscript: scheme"}),nr=m({resource:o().url(),authorization_servers:g(A).optional(),jwks_uri:o().url().optional(),scopes_supported:g(o()).optional(),bearer_methods_supported:g(o()).optional(),resource_signing_alg_values_supported:g(o()).optional(),resource_name:o().optional(),resource_documentation:o().optional(),resource_policy_uri:o().url().optional(),resource_tos_uri:o().url().optional(),tls_client_certificate_bound_access_tokens:E().optional(),authorization_details_types_supported:g(o()).optional(),dpop_signing_alg_values_supported:g(o()).optional(),dpop_bound_access_tokens_required:E().optional()}).passthrough(),Gt=m({issuer:o(),authorization_endpoint:A,token_endpoint:A,registration_endpoint:A.optional(),scopes_supported:g(o()).optional(),response_types_supported:g(o()),grant_types_supported:g(o()).optional(),code_challenge_methods_supported:g(o()),token_endpoint_auth_methods_supported:g(o()).optional(),token_endpoint_auth_signing_alg_values_supported:g(o()).optional()}).passthrough(),sr=m({issuer:o(),authorization_endpoint:A,token_endpoint:A,userinfo_endpoint:A.optional(),jwks_uri:A,registration_endpoint:A.optional(),scopes_supported:g(o()).optional(),response_types_supported:g(o()),grant_types_supported:g(o()).optional(),subject_types_supported:g(o()),id_token_signing_alg_values_supported:g(o()),claims_supported:g(o()).optional(),token_endpoint_auth_methods_supported:g(o()).optional()}).passthrough(),or=sr.merge(Gt.pick({code_challenge_methods_supported:!0})),ir=m({client_id:o(),client_secret:o().optional(),client_id_issued_at:M().optional(),client_secret_expires_at:M().optional()}).strip(),ar=m({redirect_uris:g(A),token_endpoint_auth_method:o().optional(),grant_types:g(o()).optional(),response_types:g(o()).optional(),client_name:o().optional(),client_uri:A.optional(),logo_uri:A.optional(),scope:o().optional(),contacts:g(o()).optional(),tos_uri:A.optional(),policy_uri:o().optional(),jwks_uri:A.optional(),jwks:he().optional(),software_id:o().optional(),software_version:o().optional(),software_statement:o().optional()}).strip(),cr=m({error:o(),error_description:o().optional(),error_uri:o().optional()}),lr=ar.merge(ir),ur="AI_MCPClientOAuthError",Kt=`vercel.ai.error.${ur}`,hr=Symbol.for(Kt),At,bt,G=class extends(bt=X,At=hr,bt){constructor({name:e="MCPClientOAuthError",message:t,cause:r}){super({name:e,message:t,cause:r}),this[At]=!0}static isInstance(e){return X.hasMarker(e,Kt)}},H=class extends G{};H.errorCode="server_error";var tt=class extends G{};tt.errorCode="invalid_client";var et=class extends G{};et.errorCode="invalid_grant";var rt=class extends G{};rt.errorCode="unauthorized_client";var dr={[H.errorCode]:H,[tt.errorCode]:tt,[et.errorCode]:et,[rt.errorCode]:rt};function pr(e){const t=typeof e=="string"?new URL(e):new URL(e.href);return t.hash="",t}function mr({requestedResource:e,configuredResource:t}){const r=typeof e=="string"?new URL(e):new URL(e.href),n=typeof t=="string"?new URL(t):new URL(t.href);if(r.origin!==n.origin||r.pathname.length<n.pathname.length)return!1;const s=r.pathname.endsWith("/")?r.pathname:r.pathname+"/",i=n.pathname.endsWith("/")?n.pathname:n.pathname+"/";return s.startsWith(i)}var nt=class extends Error{constructor(e="Unauthorized"){super(e),this.name="UnauthorizedError"}};function st(e){var t;const r=(t=e.headers.get("www-authenticate"))!=null?t:e.headers.get("WWW-Authenticate");if(!r)return;const[n,s]=r.split(" ");if(n.toLowerCase()!=="bearer"||!s)return;const i=/resource_metadata="([^"]*)"/,l=r.match(i);if(l)try{return new URL(l[1])}catch{return}}function fr(e,t="",r={}){return t.endsWith("/")&&(t=t.slice(0,-1)),r.prependPathname?`${t}/.well-known/${e}`:`/.well-known/${e}${t}`}async function wt(e,t,r=fetch){try{return await r(e,{headers:t})}catch(n){if(n instanceof TypeError)return t?wt(e,void 0,r):void 0;throw n}}async function St(e,t,r=fetch){return await wt(e,{"MCP-Protocol-Version":t},r)}function wr(e,t){return!e||e.status>=400&&e.status<500&&t!=="/"}async function gr(e,t,r,n){var s,i;const l=new URL(e),d=(s=n?.protocolVersion)!=null?s:L;let u;if(n?.metadataUrl)u=new URL(n.metadataUrl);else{const c=fr(t,l.pathname);u=new URL(c,(i=n?.metadataServerUrl)!=null?i:l),u.search=l.search}let a=await St(u,d,r);if(!n?.metadataUrl&&wr(a,l.pathname)){const c=new URL(`/.well-known/${t}`,l);a=await St(c,d,r)}return a}async function yr(e,t,r=fetch){const n=await gr(e,"oauth-protected-resource",r,{protocolVersion:t?.protocolVersion,metadataUrl:t?.resourceMetadataUrl});if(!n||n.status===404)throw new Error("Resource server does not implement OAuth 2.0 Protected Resource Metadata.");if(!n.ok)throw new Error(`HTTP ${n.status} trying to load well-known OAuth protected resource metadata.`);return nr.parse(await n.json())}function _r(e){const t=typeof e=="string"?new URL(e):e,r=t.pathname!=="/",n=[];if(!r)return n.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),n.push({url:new URL("/.well-known/openid-configuration",t.origin),type:"oidc"}),n;let s=t.pathname;return s.endsWith("/")&&(s=s.slice(0,-1)),n.push({url:new URL(`/.well-known/oauth-authorization-server${s}`,t.origin),type:"oauth"}),n.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),n.push({url:new URL(`/.well-known/openid-configuration${s}`,t.origin),type:"oidc"}),n.push({url:new URL(`${s}/.well-known/openid-configuration`,t.origin),type:"oidc"}),n}async function vr(e,{fetchFn:t=fetch,protocolVersion:r=L}={}){var n;const s={"MCP-Protocol-Version":r},i=_r(e);for(const{url:l,type:d}of i){const u=await wt(l,s,t);if(u){if(!u.ok){if(u.status>=400&&u.status<500)continue;throw new Error(`HTTP ${u.status} trying to load ${d==="oauth"?"OAuth":"OpenID provider"} metadata from ${l}`)}if(d==="oauth")return Gt.parse(await u.json());{const a=or.parse(await u.json());if(!((n=a.code_challenge_methods_supported)!=null&&n.includes("S256")))throw new Error(`Incompatible OIDC provider at ${l}: does not support S256 code challenge method required by MCP specification`);return a}}}}async function Cr(e,{metadata:t,clientInformation:r,redirectUrl:n,scope:s,state:i,resource:l}){const d="code",u="S256";let a;if(t){if(a=new URL(t.authorization_endpoint),!t.response_types_supported.includes(d))throw new Error(`Incompatible auth server: does not support response type ${d}`);if(!t.code_challenge_methods_supported||!t.code_challenge_methods_supported.includes(u))throw new Error(`Incompatible auth server: does not support code challenge method ${u}`)}else a=new URL("/authorize",e);const c=await Te(),h=c.code_verifier,v=c.code_challenge;return a.searchParams.set("response_type",d),a.searchParams.set("client_id",r.client_id),a.searchParams.set("code_challenge",v),a.searchParams.set("code_challenge_method",u),a.searchParams.set("redirect_uri",String(n)),i&&a.searchParams.set("state",i),s&&a.searchParams.set("scope",s),s?.includes("offline_access")&&a.searchParams.append("prompt","consent"),l&&a.searchParams.set("resource",l.href),{authorizationUrl:a,codeVerifier:h}}function Yt(e,t){const r=e.client_secret!==void 0;return t.length===0?r?"client_secret_post":"none":r&&t.includes("client_secret_basic")?"client_secret_basic":r&&t.includes("client_secret_post")?"client_secret_post":t.includes("none")?"none":r?"client_secret_post":"none"}function Xt(e,t,r,n){const{client_id:s,client_secret:i}=t;switch(e){case"client_secret_basic":Ir(s,i,r);return;case"client_secret_post":Ar(s,i,n);return;case"none":br(s,n);return;default:throw new Error(`Unsupported client authentication method: ${e}`)}}function Ir(e,t,r){if(!t)throw new Error("client_secret_basic authentication requires a client_secret");const n=btoa(`${e}:${t}`);r.set("Authorization",`Basic ${n}`)}function Ar(e,t,r){r.set("client_id",e),t&&r.set("client_secret",t)}function br(e,t){t.set("client_id",e)}async function gt(e){const t=e instanceof Response?e.status:void 0,r=e instanceof Response?await e.text():e;try{const n=cr.parse(JSON.parse(r)),{error:s,error_description:i,error_uri:l}=n,d=dr[s]||H;return new d({message:i||"",cause:l})}catch(n){const s=`${t?`HTTP ${t}: `:""}Invalid OAuth error response: ${n}. Raw body: ${r}`;return new H({message:s})}}async function Sr(e,{metadata:t,clientInformation:r,authorizationCode:n,codeVerifier:s,redirectUri:i,resource:l,addClientAuthentication:d,fetchFn:u}){var a;const c="authorization_code",h=t?.token_endpoint?new URL(t.token_endpoint):new URL("/token",e);if(t?.grant_types_supported&&!t.grant_types_supported.includes(c))throw new Error(`Incompatible auth server: does not support grant type ${c}`);const v=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),f=new URLSearchParams({grant_type:c,code:n,code_verifier:s,redirect_uri:String(i)});if(d)d(v,f,e,t);else{const w=(a=t?.token_endpoint_auth_methods_supported)!=null?a:[],_=Yt(r,w);Xt(_,r,v,f)}l&&f.set("resource",l.href);const C=await(u??fetch)(h,{method:"POST",headers:v,body:f});if(!C.ok)throw await gt(C);return Zt.parse(await C.json())}async function Pr(e,{metadata:t,clientInformation:r,refreshToken:n,resource:s,addClientAuthentication:i,fetchFn:l}){var d;const u="refresh_token";let a;if(t){if(a=new URL(t.token_endpoint),t.grant_types_supported&&!t.grant_types_supported.includes(u))throw new Error(`Incompatible auth server: does not support grant type ${u}`)}else a=new URL("/token",e);const c=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),h=new URLSearchParams({grant_type:u,refresh_token:n});if(i)i(c,h,e,t);else{const f=(d=t?.token_endpoint_auth_methods_supported)!=null?d:[],C=Yt(r,f);Xt(C,r,c,h)}s&&h.set("resource",s.href);const v=await(l??fetch)(a,{method:"POST",headers:c,body:h});if(!v.ok)throw await gt(v);return Zt.parse({refresh_token:n,...await v.json()})}async function Ur(e,{metadata:t,clientMetadata:r,fetchFn:n}){let s;if(t){if(!t.registration_endpoint)throw new Error("Incompatible auth server: does not support dynamic client registration");s=new URL(t.registration_endpoint)}else s=new URL("/register",e);const i=await(n??fetch)(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!i.ok)throw await gt(i);return lr.parse(await i.json())}async function W(e,t){var r,n;try{return await dt(e,t)}catch(s){if(s instanceof tt||s instanceof rt)return await((r=e.invalidateCredentials)==null?void 0:r.call(e,"all")),await dt(e,t);if(s instanceof et)return await((n=e.invalidateCredentials)==null?void 0:n.call(e,"tokens")),await dt(e,t);throw s}}async function Er(e,t,r){const n=pr(e);if(t.validateResourceURL)return await t.validateResourceURL(n,r?.resource);if(r){if(!mr({requestedResource:n,configuredResource:r.resource}))throw new Error(`Protected resource ${r.resource} does not match expected ${n} (or origin)`);return new URL(r.resource)}}async function dt(e,{serverUrl:t,authorizationCode:r,scope:n,resourceMetadataUrl:s,fetchFn:i}){let l,d;try{l=await yr(t,{resourceMetadataUrl:s},i),l.authorization_servers&&l.authorization_servers.length>0&&(d=l.authorization_servers[0])}catch{}d||(d=t);const u=await Er(t,e,l),a=await vr(d,{fetchFn:i});let c=await Promise.resolve(e.clientInformation());if(!c){if(r!==void 0)throw new Error("Existing OAuth client information is required when exchanging an authorization code");if(!e.saveClientInformation)throw new Error("OAuth client information must be saveable for dynamic registration");const w=await Ur(d,{metadata:a,clientMetadata:e.clientMetadata,fetchFn:i});await e.saveClientInformation(w),c=w}if(r!==void 0){const w=await e.codeVerifier(),_=await Sr(d,{metadata:a,clientInformation:c,authorizationCode:r,codeVerifier:w,redirectUri:e.redirectUrl,resource:u,addClientAuthentication:e.addClientAuthentication,fetchFn:i});return await e.saveTokens(_),"AUTHORIZED"}const h=await e.tokens();if(h?.refresh_token)try{const w=await Pr(d,{metadata:a,clientInformation:c,refreshToken:h.refresh_token,resource:u,addClientAuthentication:e.addClientAuthentication,fetchFn:i});return await e.saveTokens(w),"AUTHORIZED"}catch(w){if(!(!(w instanceof G)||w instanceof H))throw w}const v=e.state?await e.state():void 0,{authorizationUrl:f,codeVerifier:C}=await Cr(d,{metadata:a,clientInformation:c,state:v,redirectUrl:e.redirectUrl,scope:n||e.clientMetadata.scope,resource:u});return await e.saveCodeVerifier(C),await e.redirectToAuthorization(f),"REDIRECT"}var Rr=class{constructor({url:e,headers:t,authProvider:r}){this.connected=!1,this.url=new URL(e),this.headers=t,this.authProvider=r}async commonHeaders(e){const t={...this.headers,...e,"mcp-protocol-version":L};if(this.authProvider){const r=await this.authProvider.tokens();r?.access_token&&(t.Authorization=`Bearer ${r.access_token}`)}return kt(t,`ai-sdk/${Wt}`,zt())}async start(){return new Promise((e,t)=>{if(this.connected)return e();this.abortController=new AbortController;const r=async(n=!1)=>{var s,i,l,d,u;try{const a=await this.commonHeaders({Accept:"text/event-stream"}),c=await fetch(this.url.href,{headers:a,signal:(s=this.abortController)==null?void 0:s.signal});if(c.status===401&&this.authProvider&&!n){this.resourceMetadataUrl=st(c);try{if(await W(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED"){const f=new nt;return(i=this.onerror)==null||i.call(this,f),t(f)}}catch(f){return(l=this.onerror)==null||l.call(this,f),t(f)}return r(!0)}if(!c.ok||!c.body){let f=`MCP SSE Transport Error: ${c.status} ${c.statusText}`;c.status===405&&(f+=". This server does not support SSE transport. Try using `http` transport instead");const C=new y({message:f});return(d=this.onerror)==null||d.call(this,C),t(C)}const h=c.body.pipeThrough(new TextDecoderStream).pipeThrough(new pt).getReader(),v=async()=>{var f,C,w;try{for(;;){const{done:_,value:I}=await h.read();if(_){if(this.connected)throw this.connected=!1,new y({message:"MCP SSE Transport Error: Connection closed unexpectedly"});return}const{event:$,data:T}=I;if($==="endpoint"){if(this.endpoint=new URL(T,this.url),this.endpoint.origin!==this.url.origin)throw new y({message:`MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`});this.connected=!0,e()}else if($==="message")try{const D=B.parse(JSON.parse(T));(f=this.onmessage)==null||f.call(this,D)}catch(D){const q=new y({message:"MCP SSE Transport Error: Failed to parse message",cause:D});(C=this.onerror)==null||C.call(this,q)}}}catch(_){if(_ instanceof Error&&_.name==="AbortError")return;(w=this.onerror)==null||w.call(this,_),t(_)}};this.sseConnection={close:()=>h.cancel()},v()}catch(a){if(a instanceof Error&&a.name==="AbortError")return;(u=this.onerror)==null||u.call(this,a),t(a)}};r()})}async close(){var e,t,r;this.connected=!1,(e=this.sseConnection)==null||e.close(),(t=this.abortController)==null||t.abort(),(r=this.onclose)==null||r.call(this)}async send(e){if(!this.endpoint||!this.connected)throw new y({message:"MCP SSE Transport Error: Not connected"});const t=this.endpoint,r=async(n=!1)=>{var s,i,l,d,u;try{const a={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json"}),body:JSON.stringify(e),signal:(s=this.abortController)==null?void 0:s.signal},c=await fetch(t,a);if(c.status===401&&this.authProvider&&!n){this.resourceMetadataUrl=st(c);try{if(await W(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED"){const h=new nt;(i=this.onerror)==null||i.call(this,h);return}}catch(h){(l=this.onerror)==null||l.call(this,h);return}return r(!0)}if(!c.ok){const h=await c.text().catch(()=>null),v=new y({message:`MCP SSE Transport Error: POSTing to endpoint (HTTP ${c.status}): ${h}`});(d=this.onerror)==null||d.call(this,v);return}}catch(a){(u=this.onerror)==null||u.call(this,a);return}};await r()}},Tr=class{constructor({url:e,headers:t,authProvider:r}){this.inboundReconnectAttempts=0,this.reconnectionOptions={initialReconnectionDelay:1e3,maxReconnectionDelay:3e4,reconnectionDelayGrowFactor:1.5,maxRetries:2},this.url=new URL(e),this.headers=t,this.authProvider=r}async commonHeaders(e){const t={...this.headers,...e,"mcp-protocol-version":L};if(this.sessionId&&(t["mcp-session-id"]=this.sessionId),this.authProvider){const r=await this.authProvider.tokens();r?.access_token&&(t.Authorization=`Bearer ${r.access_token}`)}return kt(t,`ai-sdk/${Wt}`,zt())}async start(){if(this.abortController)throw new y({message:"MCP HTTP Transport Error: Transport already started. Note: client.connect() calls start() automatically."});this.abortController=new AbortController,this.openInboundSse()}async close(){var e,t,r;(e=this.inboundSseConnection)==null||e.close();try{if(this.sessionId&&this.abortController&&!this.abortController.signal.aborted){const n=await this.commonHeaders({});await fetch(this.url,{method:"DELETE",headers:n,signal:this.abortController.signal}).catch(()=>{})}}catch{}(t=this.abortController)==null||t.abort(),(r=this.onclose)==null||r.call(this)}async send(e){const t=async(r=!1)=>{var n,s,i,l,d,u,a;try{const c={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json",Accept:"application/json, text/event-stream"}),body:JSON.stringify(e),signal:(n=this.abortController)==null?void 0:n.signal},h=await fetch(this.url,c),v=h.headers.get("mcp-session-id");if(v&&(this.sessionId=v),h.status===401&&this.authProvider&&!r){this.resourceMetadataUrl=st(h);try{if(await W(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED")throw new nt}catch(w){throw(s=this.onerror)==null||s.call(this,w),w}return t(!0)}if(h.status===202){this.inboundSseConnection||this.openInboundSse();return}if(!h.ok){const w=await h.text().catch(()=>null);let _=`MCP HTTP Transport Error: POSTing to endpoint (HTTP ${h.status}): ${w}`;h.status===404&&(_+=". This server does not support HTTP transport. Try using `sse` transport instead");const I=new y({message:_});throw(i=this.onerror)==null||i.call(this,I),I}const f=h.headers.get("content-type")||"";if(f.includes("application/json")){const w=await h.json(),_=Array.isArray(w)?w.map(I=>B.parse(I)):[B.parse(w)];for(const I of _)(l=this.onmessage)==null||l.call(this,I);return}if(f.includes("text/event-stream")){if(!h.body){const _=new y({message:"MCP HTTP Transport Error: text/event-stream response without body"});throw(d=this.onerror)==null||d.call(this,_),_}const w=h.body.pipeThrough(new TextDecoderStream).pipeThrough(new pt).getReader();(async()=>{var _,I,$;try{for(;;){const{done:T,value:D}=await w.read();if(T)return;const{event:q,data:N}=D;if(q==="message")try{const F=B.parse(JSON.parse(N));(_=this.onmessage)==null||_.call(this,F)}catch(F){const ee=new y({message:"MCP HTTP Transport Error: Failed to parse message",cause:F});(I=this.onerror)==null||I.call(this,ee)}}}catch(T){if(T instanceof Error&&T.name==="AbortError")return;($=this.onerror)==null||$.call(this,T)}})();return}const C=new y({message:`MCP HTTP Transport Error: Unexpected content type: ${f}`});throw(u=this.onerror)==null||u.call(this,C),C}catch(c){throw(a=this.onerror)==null||a.call(this,c),c}};await t()}getNextReconnectionDelay(e){const{initialReconnectionDelay:t,reconnectionDelayGrowFactor:r,maxReconnectionDelay:n}=this.reconnectionOptions;return Math.min(t*Math.pow(r,e),n)}scheduleInboundSseReconnection(){var e;const{maxRetries:t}=this.reconnectionOptions;if(t>0&&this.inboundReconnectAttempts>=t){(e=this.onerror)==null||e.call(this,new y({message:`MCP HTTP Transport Error: Maximum reconnection attempts (${t}) exceeded.`}));return}const r=this.getNextReconnectionDelay(this.inboundReconnectAttempts);this.inboundReconnectAttempts+=1,setTimeout(async()=>{var n;(n=this.abortController)!=null&&n.signal.aborted||await this.openInboundSse(!1,this.lastInboundEventId)},r)}async openInboundSse(e=!1,t){var r,n,s,i,l,d;try{const u=await this.commonHeaders({Accept:"text/event-stream"});t&&(u["last-event-id"]=t);const a=await fetch(this.url.href,{method:"GET",headers:u,signal:(r=this.abortController)==null?void 0:r.signal}),c=a.headers.get("mcp-session-id");if(c&&(this.sessionId=c),a.status===401&&this.authProvider&&!e){this.resourceMetadataUrl=st(a);try{if(await W(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED"){const f=new nt;(n=this.onerror)==null||n.call(this,f);return}}catch(f){(s=this.onerror)==null||s.call(this,f);return}return this.openInboundSse(!0,t)}if(a.status===405)return;if(!a.ok||!a.body){const f=new y({message:`MCP HTTP Transport Error: GET SSE failed: ${a.status} ${a.statusText}`});(i=this.onerror)==null||i.call(this,f);return}const h=a.body.pipeThrough(new TextDecoderStream).pipeThrough(new pt).getReader(),v=async()=>{var f,C,w,_;try{for(;;){const{done:I,value:$}=await h.read();if(I)return;const{event:T,data:D,id:q}=$;if(q&&(this.lastInboundEventId=q),T==="message")try{const N=B.parse(JSON.parse(D));(f=this.onmessage)==null||f.call(this,N)}catch(N){const F=new y({message:"MCP HTTP Transport Error: Failed to parse message",cause:N});(C=this.onerror)==null||C.call(this,F)}}}catch(I){if(I instanceof Error&&I.name==="AbortError")return;(w=this.onerror)==null||w.call(this,I),(_=this.abortController)!=null&&_.signal.aborted||this.scheduleInboundSseReconnection()}};this.inboundSseConnection={close:()=>h.cancel()},this.inboundReconnectAttempts=0,v()}catch(u){if(u instanceof Error&&u.name==="AbortError")return;(l=this.onerror)==null||l.call(this,u),(d=this.abortController)!=null&&d.signal.aborted||this.scheduleInboundSseReconnection()}}};function kr(e){switch(e.type){case"sse":return new Rr(e);case"http":return new Tr(e);default:throw new y({message:"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface."})}}function zr(e){return"start"in e&&typeof e.start=="function"&&"send"in e&&typeof e.send=="function"&&"close"in e&&typeof e.close=="function"}var Or="1.0.0";async function xr(e){const t=new Mr(e);return await t.init(),t}var Mr=class{constructor({transport:e,name:t="ai-sdk-mcp-client",version:r=Or,onUncaughtError:n,capabilities:s}){this.requestMessageId=0,this.responseHandlers=new Map,this.serverCapabilities={},this.isClosed=!0,this.onUncaughtError=n,this.clientCapabilities=s??{},zr(e)?this.transport=e:this.transport=kr(e),this.transport.onclose=()=>this.onClose(),this.transport.onerror=i=>this.onError(i),this.transport.onmessage=i=>{if("method"in i){"id"in i?this.onRequestMessage(i):this.onError(new y({message:"Unsupported message type"}));return}this.onResponse(i)},this.clientInfo={name:t,version:r}}async init(){try{await this.transport.start(),this.isClosed=!1;const e=await this.request({request:{method:"initialize",params:{protocolVersion:L,capabilities:this.clientCapabilities,clientInfo:this.clientInfo}},resultSchema:De});if(e===void 0)throw new y({message:"Server sent invalid initialize result"});if(!Oe.includes(e.protocolVersion))throw new y({message:`Server's protocol version is not supported: ${e.protocolVersion}`});return this.serverCapabilities=e.capabilities,await this.notification({method:"notifications/initialized"}),this}catch(e){throw await this.close(),e}}async close(){var e;this.isClosed||(await((e=this.transport)==null?void 0:e.close()),this.onClose())}assertCapability(e){switch(e){case"initialize":break;case"tools/list":case"tools/call":if(!this.serverCapabilities.tools)throw new y({message:"Server does not support tools"});break;case"resources/list":case"resources/read":case"resources/templates/list":if(!this.serverCapabilities.resources)throw new y({message:"Server does not support resources"});break;case"prompts/list":case"prompts/get":if(!this.serverCapabilities.prompts)throw new y({message:"Server does not support prompts"});break;default:throw new y({message:`Unsupported method: ${e}`})}}async request({request:e,resultSchema:t,options:r}){return new Promise((n,s)=>{if(this.isClosed)return s(new y({message:"Attempted to send a request from a closed client"}));this.assertCapability(e.method);const i=r?.signal;i?.throwIfAborted();const l=this.requestMessageId++,d={...e,jsonrpc:"2.0",id:l},u=()=>{this.responseHandlers.delete(l)};this.responseHandlers.set(l,a=>{if(i?.aborted)return s(new y({message:"Request was aborted",cause:i.reason}));if(a instanceof Error)return s(a);try{const c=t.parse(a.result);n(c)}catch(c){const h=new y({message:"Failed to parse server response",cause:c});s(h)}}),this.transport.send(d).catch(a=>{u(),s(a)})})}async listTools({params:e,options:t}={}){try{return this.request({request:{method:"tools/list",params:e},resultSchema:Ve,options:t})}catch(r){throw r}}async callTool({name:e,args:t,options:r}){try{return this.request({request:{method:"tools/call",params:{name:e,arguments:t}},resultSchema:je,options:{signal:r?.abortSignal}})}catch(n){throw n}}async listResourcesInternal({params:e,options:t}={}){try{return this.request({request:{method:"resources/list",params:e},resultSchema:Le,options:t})}catch(r){throw r}}async readResourceInternal({uri:e,options:t}){try{return this.request({request:{method:"resources/read",params:{uri:e}},resultSchema:Be,options:t})}catch(r){throw r}}async listResourceTemplatesInternal({options:e}={}){try{return this.request({request:{method:"resources/templates/list"},resultSchema:Fe,options:e})}catch(t){throw t}}async listPromptsInternal({params:e,options:t}={}){try{return this.request({request:{method:"prompts/list",params:e},resultSchema:Ze,options:t})}catch(r){throw r}}async getPromptInternal({name:e,args:t,options:r}){try{return this.request({request:{method:"prompts/get",params:{name:e,arguments:t}},resultSchema:Ke,options:r})}catch(n){throw n}}async notification(e){const t={...e,jsonrpc:"2.0"};await this.transport.send(t)}async tools({schemas:e="automatic"}={}){var t;const r={};try{const n=await this.listTools();for(const{name:s,description:i,inputSchema:l,annotations:d,_meta:u}of n.tools){const a=d?.title;if(e!=="automatic"&&!(s in e))continue;const c=this,h=async(f,C)=>{var w;return(w=C?.abortSignal)==null||w.throwIfAborted(),c.callTool({name:s,args:f,options:C})},v=e==="automatic"?ie({description:i,title:a,inputSchema:ae({...l,properties:(t=l.properties)!=null?t:{},additionalProperties:!1}),execute:h}):ce({description:i,title:a,inputSchema:e[s].inputSchema,execute:h});r[s]={...v,_meta:u}}return r}catch(n){throw n}}listResources({params:e,options:t}={}){return this.listResourcesInternal({params:e,options:t})}readResource({uri:e,options:t}){return this.readResourceInternal({uri:e,options:t})}listResourceTemplates({options:e}={}){return this.listResourceTemplatesInternal({options:e})}experimental_listPrompts({params:e,options:t}={}){return this.listPromptsInternal({params:e,options:t})}experimental_getPrompt({name:e,arguments:t,options:r}){return this.getPromptInternal({name:e,args:t,options:r})}onElicitationRequest(e,t){if(e!==It)throw new y({message:"Unsupported request schema. Only ElicitationRequestSchema is supported."});this.elicitationRequestHandler=t}async onRequestMessage(e){try{if(e.method!=="elicitation/create"){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32601,message:`Unsupported request method: ${e.method}`}});return}if(!this.elicitationRequestHandler){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32601,message:"No elicitation handler registered on client"}});return}const t=It.safeParse({method:e.method,params:e.params});if(!t.success){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32602,message:`Invalid elicitation request: ${t.error.message}`,data:t.error.issues}});return}try{const r=await this.elicitationRequestHandler(t.data),n=Xe.parse(r);await this.transport.send({jsonrpc:"2.0",id:e.id,result:n})}catch(r){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32603,message:r instanceof Error?r.message:"Failed to handle elicitation request"}}),this.onError(r)}}catch(t){this.onError(t)}}onClose(){if(this.isClosed)return;this.isClosed=!0;const e=new y({message:"Connection closed"});for(const t of this.responseHandlers.values())t(e);this.responseHandlers.clear()}onError(e){this.onUncaughtError&&this.onUncaughtError(e)}onResponse(e){const t=Number(e.id),r=this.responseHandlers.get(t);if(r===void 0)throw new y({message:`Protocol error: Received a response for an unknown message ID: ${JSON.stringify(e)}`});this.responseHandlers.delete(t),r("result"in e?e:new y({message:e.error.message,code:e.error.code,data:e.error.data,cause:e.error}))}};const z=it("mcp-oauth-provider");class Pt extends Error{authorizationUrl;constructor(t){super("OAuth user authorization required"),this.name="OAuthAuthorizationRequiredError",this.authorizationUrl=t}}class $r{currentOAuthState="";cachedAuthData;initialized=!1;saveCodeVerifierPromise=null;cachedAuthorizationUrl=null;config;saveClientInformationPromise=null;constructor(t){this.config=t}initializationPromise=null;async initializeOAuth(){if(this.initializationPromise)return this.initializationPromise;if(!this.initialized){this.initializationPromise=this.doInitializeOAuth();try{await this.initializationPromise}finally{this.initializationPromise=null}}}async doInitializeOAuth(){if(this.config.state){const r=await yt({state:this.config.state});if(r&&r.mcpConnectorId===this.config.mcpConnectorId){this.currentOAuthState=r.state??"",this.cachedAuthData=r,this.initialized=!0;return}}const t=await xt({mcpConnectorId:this.config.mcpConnectorId});if(t){this.currentOAuthState=t.state??"",this.cachedAuthData=t,this.initialized=!0;return}this.currentOAuthState=de(),this.cachedAuthData=await ye({mcpConnectorId:this.config.mcpConnectorId,serverUrl:this.config.serverUrl,state:this.currentOAuthState}),this.initialized=!0}async getAuthData(){return await this.initializeOAuth(),this.cachedAuthData}async updateAuthData(t){if(!this.currentOAuthState)throw new Error("OAuth not initialized");return this.cachedAuthData=await _e({state:this.currentOAuthState,updates:t}),this.cachedAuthData}get redirectUrl(){return this.config.clientMetadata.redirect_uris[0]}get clientMetadata(){return this.config.clientMetadata}state(){return this.currentOAuthState}async clientInformation(){const t=await this.getAuthData();if(t?.clientInfo){const r=t.clientInfo;if(!t.tokens&&r.redirect_uris[0]!==this.redirectUrl){z.warn({state:t.state,savedRedirectUri:r.redirect_uris[0],currentRedirectUri:this.redirectUrl},"clientInformation: redirect URI mismatch, invalidating session"),t.state&&await _t({state:t.state}),this.cachedAuthData=void 0,this.initialized=!1;return}return r}}async saveClientInformation(t){if(this.saveClientInformationPromise){await this.saveClientInformationPromise;return}this.cachedAuthData?.clientInfo||(this.cachedAuthData&&(this.cachedAuthData={...this.cachedAuthData,clientInfo:t}),this.saveClientInformationPromise=ve({state:this.currentOAuthState,clientInfo:t}).then(r=>{this.cachedAuthData=r}).finally(()=>{this.saveClientInformationPromise=null}),await this.saveClientInformationPromise)}async tokens(){return(await this.getAuthData())?.tokens}async saveTokens(t){this.cachedAuthData=await Ce({state:this.currentOAuthState,mcpConnectorId:this.config.mcpConnectorId,tokens:t})}async redirectToAuthorization(t){if(t.searchParams.set("state",this.state()),this.cachedAuthorizationUrl){await this.config.onRedirectToAuthorization(this.cachedAuthorizationUrl);return}this.cachedAuthorizationUrl=new URL(t.toString()),await this.config.onRedirectToAuthorization(t)}async saveCodeVerifier(t){if(this.saveCodeVerifierPromise){await this.saveCodeVerifierPromise;return}const r=this.cachedAuthData?.codeVerifier;if(r){z.info({state:this.currentOAuthState,existingVerifierPrefix:r.slice(0,10),newVerifierPrefix:t.slice(0,10)},"saveCodeVerifier: SKIPPING - verifier already exists");return}z.info({state:this.currentOAuthState,codeVerifierPrefix:t.slice(0,10)},"saveCodeVerifier: saving first verifier"),this.cachedAuthData&&(this.cachedAuthData={...this.cachedAuthData,codeVerifier:t}),this.saveCodeVerifierPromise=Ie({state:this.currentOAuthState,codeVerifier:t}).then(n=>{this.cachedAuthData=n}).finally(()=>{this.saveCodeVerifierPromise=null}),await this.saveCodeVerifierPromise}async codeVerifier(){const t=await this.getAuthData();if(z.info({state:this.currentOAuthState,hasCodeVerifier:!!t?.codeVerifier,codeVerifierPrefix:t?.codeVerifier?.slice(0,10)},"codeVerifier called"),!t?.codeVerifier)throw new Error("OAuth code verifier not found");return t.codeVerifier}async adoptState(t){if(!t){z.warn("adoptState called with empty state");return}if(this.initialized&&this.currentOAuthState===t){z.info({state:t},"adoptState: already initialized with this state");return}const r=await yt({state:t});if(!r){z.warn({state:t},"adoptState: session not found");return}if(r.mcpConnectorId!==this.config.mcpConnectorId){z.warn({state:t,sessionConnectorId:r.mcpConnectorId,expectedConnectorId:this.config.mcpConnectorId},"adoptState: connector ID mismatch");return}z.info({state:t,previousState:this.currentOAuthState,wasInitialized:this.initialized,hasCodeVerifier:!!r.codeVerifier,hasClientInfo:!!r.clientInfo,hasTokens:!!r.tokens},"adoptState: adopting session (overriding previous state if any)"),this.currentOAuthState=t,this.cachedAuthData=r,this.initialized=!0}async invalidateCredentials(t){t==="all"?(await _t({state:this.currentOAuthState}),this.cachedAuthData=void 0,this.initialized=!1,this.currentOAuthState=""):t==="tokens"?await this.updateAuthData({tokens:null}):t==="client"?(await this.updateAuthData({clientInfo:null}),this.initialized=!1,this.currentOAuthState="",this.cachedAuthData=void 0):t==="verifier"&&(await this.updateAuthData({codeVerifier:null}),this.cachedAuthorizationUrl=null)}}const Y=it("mcp-client");class Dr{client;oauthProvider;authorizationUrl;_status="disconnected";id;name;serverConfig;constructor(t,r,n){this.id=t,this.name=r,this.serverConfig=n;const s=oe();this.oauthProvider=new $r({mcpConnectorId:this.id,serverUrl:this.serverConfig.url,clientMetadata:{client_name:`${J.appPrefix}-${this.name}`,grant_types:["authorization_code","refresh_token"],response_types:["code"],token_endpoint_auth_method:"none",scope:"mcp:tools",redirect_uris:[`${s}/api/mcp/oauth/callback`],software_id:J.appPrefix,software_version:"1.0.0"},onRedirectToAuthorization:i=>{throw this.authorizationUrl=i,new Pt(i)}})}get status(){return this.authorizationUrl?"authorizing":this.client?"connected":this._status}getAuthorizationUrl(){return this.authorizationUrl}async connect(t){if(this.status==="connected"&&this.client)return this.client;this._status="connecting",t&&await this.oauthProvider.adoptState(t);try{return this.client=await xr({transport:{type:this.serverConfig.type,url:this.serverConfig.url,headers:this.serverConfig.headers,authProvider:this.oauthProvider}}),this._status="connected",this.client}catch(r){if(r instanceof Pt){this._status="authorizing",Y.info({connectorId:this.id,authUrl:r.authorizationUrl.toString()},"OAuth authorization required");return}throw this._status="disconnected",r}}async attemptConnection(){if(this.status==="connected"&&this.client)return{status:"connected",needsAuth:!1};if(this.authorizationUrl)return{status:"authorizing",needsAuth:!0};try{return await this.connect(),this.authorizationUrl?{status:"authorizing",needsAuth:!0}:{status:this.client?"connected":"disconnected",needsAuth:!1}}catch(t){const r=t instanceof Error?t.message:String(t);return Y.error({connectorId:this.id,errorMessage:r,errorStack:t instanceof Error?t.stack:void 0},"attemptConnection failed"),r.includes("does not support dynamic client registration")?(this._status="incompatible",{status:"incompatible",needsAuth:!1,error:"Server requires pre-configured OAuth credentials (does not support dynamic client registration)"}):{status:"disconnected",needsAuth:!1,error:r}}}async finishAuth(t,r){await this.oauthProvider.adoptState(r),await W(this.oauthProvider,{serverUrl:this.serverConfig.url,authorizationCode:t}),this.authorizationUrl=void 0}async tools(){if(!this.client)throw new Error("Client not connected");try{return await this.client.tools()}catch(t){throw this.handlePotentialAuthError(t),t}}async listResources(){if(!this.client)throw new Error("Client not connected");try{return await this.client.listResources()}catch(t){throw this.handlePotentialAuthError(t),t}}async listPrompts(){if(!this.client)throw new Error("Client not connected");try{return await this.client.experimental_listPrompts()}catch(t){throw this.handlePotentialAuthError(t),t}}async close(){try{await this.client?.close()}catch(t){Y.error({error:t,connectorId:this.id},"Error closing MCP client")}this.client=void 0,this._status="disconnected",Q(this.id)}handlePotentialAuthError(t){const r=t instanceof Error?t.message:String(t);(r.includes("401")||r.includes("403")||r.includes("Unauthorized")||r.includes("Forbidden")||r.includes("token"))&&(Y.warn({connectorId:this.id,errorMessage:r},"Auth error detected, invalidating caches"),Q(this.id))}}const ot=new Map;function K({id:e,name:t,url:r,type:n,headers:s}){let i=ot.get(e);return i||(i=new Dr(e,t,{url:r,type:n,headers:s}),ot.set(e,i)),i}async function ht(e){const t=ot.get(e);t&&(await t.close(),ot.delete(e))}const qr=/_+/g,Vr=/^_|_$/g,Hr=/[^a-z0-9]/g,Qt=20,Lr="global";function jr(e){const t=e.toLowerCase().replace(Hr,"_").replace(qr,"_").replace(Vr,"");return t?t===Lr?{ok:!1,error:"reserved"}:{ok:!0,nameId:t}:{ok:!1,error:"empty"}}const Nr=m({name:o().min(1).max(Qt),url:o().url(),type:Ut(["http","sse"]),oauthClientId:o().optional(),oauthClientSecret:o().optional()}),Fr=m({id:o().uuid(),updates:m({name:o().min(1).max(Qt).optional(),url:o().url().optional(),type:Ut(["http","sse"]).optional(),oauthClientId:o().nullable().optional(),oauthClientSecret:o().nullable().optional(),enabled:E().optional()})}),j=m({id:o().uuid()}),Br=m({id:o().uuid(),enabled:E()}),Jr=m({id:se()}),U=it("mcp.actions");function R(){if(!J.integrations.mcp)throw new Error("MCP integration disabled")}async function P(){const e=await re.api.getSession({headers:ne.request.headers});if(!e?.user)throw new Error("UNAUTHORIZED");const{id:t,...r}=e.user;if(!t)throw console.error("User ID missing in session callback"),new Error("UNAUTHORIZED");return{id:t,...r}}async function te({name:e,userId:t,excludeId:r}){R();const n=jr(e);if(!n.ok)throw new Error(n.error==="empty"?"Connector name must contain at least one alphanumeric character":'Connector name cannot be "global" (reserved)');if(await ge({userId:t,nameId:n.nameId,excludeId:r}))throw new Error(`A connector with namespace "${n.nameId}" already exists. Choose a different name.`);return n.nameId}async function x({id:e,userId:t,permission:r}){const n=await we({id:e});if(!n)throw new Error("Connector not found");const s=n.userId===t,i=n.userId===null;if(!(r==="own"?s:s||i))throw new Error("Cannot access this connector");return n}async function Wr(){const e=await P();return J.integrations.mcp?await Mt({userId:e.id}):[]}async function Zr(){const e=await P();if(!J.integrations.mcp)return[];const t=await Mt({userId:e.id});return(await Promise.all(t.map(async r=>{const n=async()=>{const i=await K({id:r.id,name:r.name,url:r.url,type:r.type}).attemptConnection();return{status:i.status,needsAuth:i.needsAuth,error:i.error}},s=Dt(r.id,n);try{const i=await s();return{connector:r,status:i}}catch{return{connector:r,status:null}}}))).filter(r=>r.status?.status==="connected").map(r=>r.connector)}async function Gr(e){const t=await P(),r=Nr.parse(e);R();const n=await te({name:r.name,userId:t.id});return await pe({userId:t.id,name:r.name,nameId:n,url:r.url,type:r.type,oauthClientId:r.oauthClientId,oauthClientSecret:r.oauthClientSecret})}async function Kr(e){const t=await P(),r=Fr.parse(e);R();const n=await x({id:r.id,userId:t.id,permission:"own"}),s={...r.updates};if(s.name){const i=await te({name:s.name,userId:n.userId,excludeId:r.id});s.nameId=i}return await $t({id:r.id,updates:s}),{success:!0}}async function Yr(e){const t=await P(),r=j.parse(e);return R(),await x({id:r.id,userId:t.id,permission:"own"}),await me({id:r.id}),await ht(r.id),{success:!0}}async function Xr(e){const t=await P(),r=j.parse(e);return R(),await x({id:r.id,userId:t.id,permission:"own-or-global"}),await fe({mcpConnectorId:r.id}),await ht(r.id),Q(r.id),{success:!0}}async function Qr(e){const t=await P(),r=Br.parse(e);return R(),await x({id:r.id,userId:t.id,permission:"own"}),await $t({id:r.id,updates:{enabled:r.enabled}}),{success:!0}}async function tn(e){const t=await P(),r=j.parse(e);R();const n=await x({id:r.id,userId:t.id,permission:"own-or-global"}),s=async()=>{U.debug({connectorId:n.id,url:n.url},"testing MCP connection (cache miss)");const i=await K({id:n.id,name:n.name,url:n.url,type:n.type}).attemptConnection();return U.debug({connectorId:n.id,status:i.status,needsAuth:i.needsAuth,error:i.error},"MCP connection test completed"),{status:i.status,needsAuth:i.needsAuth,error:i.error}};return Dt(n.id,s)()}async function en(e){const t=await P(),r=Jr.parse(e);R();const n=await x({id:r.id,userId:t.id,permission:"own-or-global"}),s=async()=>{U.debug({connectorId:n.id,url:n.url},"creating MCP client for discovery (cache miss)");const i=K({id:n.id,name:n.name,url:n.url,type:n.type});if(await i.connect(),i.status==="authorizing")throw new Error("Connector requires OAuth authorization");if(i.status!=="connected")throw new Error(`Failed to connect to MCP server (status: ${i.status})`);U.debug({connectorId:n.id},"MCP client connected, discovering capabilities");try{const[l,d,u]=await Promise.all([i.tools().then(a=>Object.entries(a).map(([c,h])=>({name:c,description:h.description??null}))).catch(a=>(U.warn({connectorId:n.id,err:a},"failed to list tools"),[])),i.listResources().then(a=>a.resources.map(c=>({name:c.name,uri:c.uri,description:c.description??null,mimeType:c.mimeType??null}))).catch(a=>(U.warn({connectorId:n.id,err:a},"failed to list resources"),[])),i.listPrompts().then(a=>a.prompts.map(c=>({name:c.name,description:c.description??null,arguments:c.arguments?.map(h=>({name:h.name,description:h.description??null,required:h.required??!1}))??[]}))).catch(a=>(U.warn({connectorId:n.id,err:a},"failed to list prompts"),[]))]);return U.info({connectorId:n.id,toolsCount:l.length,resourcesCount:d.length,promptsCount:u.length},"MCP discovery completed"),{tools:l,resources:d,prompts:u}}finally{U.debug({connectorId:n.id},"MCP discovery finished")}};return Ae(n.id,s)()}async function rn(e){const t=await P(),r=j.parse(e);R();const n=await x({id:r.id,userId:t.id,permission:"own-or-global"});U.info({connectorId:n.id},"Initiating OAuth authorization"),await ht(n.id);const s=K({id:n.id,name:n.name,url:n.url,type:n.type});if(await s.connect(),s.status!=="authorizing")throw new Error("Connector does not require OAuth authorization");const i=s.getAuthorizationUrl();if(!i)throw new Error("Failed to get authorization URL");return U.info({connectorId:n.id,authUrl:i.toString()},"OAuth authorization URL generated"),{authorizationUrl:i.toString()}}async function nn(e){const t=await P(),r=j.parse(e);R();const n=await x({id:r.id,userId:t.id,permission:"own-or-global"}),s=await xt({mcpConnectorId:n.id});return{isAuthenticated:!!s?.tokens,hasSession:!!s}}async function sn(e){const t=await P(),r=j.parse(e);R();const n=await x({id:r.id,userId:t.id,permission:"own-or-global"});await ht(n.id),Q(n.id);const s=K({id:n.id,name:n.name,url:n.url,type:n.type});return await s.connect(),{status:s.status,needsAuth:s.status==="authorizing"}}S(Wr,"/src/server/actions/mcp.ts","list");S(Zr,"/src/server/actions/mcp.ts","listConnected");S(Gr,"/src/server/actions/mcp.ts","create");S(Kr,"/src/server/actions/mcp.ts","update");S(Yr,"/src/server/actions/mcp.ts","deleteConnector");S(Xr,"/src/server/actions/mcp.ts","disconnect");S(Qr,"/src/server/actions/mcp.ts","toggleEnabled");S(tn,"/src/server/actions/mcp.ts","testConnection");S(en,"/src/server/actions/mcp.ts","discover");S(rn,"/src/server/actions/mcp.ts","authorize");S(nn,"/src/server/actions/mcp.ts","checkAuth");S(sn,"/src/server/actions/mcp.ts","refreshClient");export{rn as authorize,nn as checkAuth,Gr as create,Yr as deleteConnector,Xr as disconnect,en as discover,Wr as list,Zr as listConnected,sn as refreshClient,tn as testConnection,Qr as toggleEnabled,Kr as update};
//# sourceMappingURL=mcp-CVNwIaLh-D_Nl0265.mjs.map
