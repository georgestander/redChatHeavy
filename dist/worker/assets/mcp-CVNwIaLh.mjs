import{a6 as Ut,a7 as Tt,a8 as it,a9 as oe,aa as ie,ab as ae,ac as Q,ad as p,s as o,F as v,b as U,z as k,C as W,D as b,G as Ot,ae as Mt,af as kt,q as ft,ag as q,o as f,ah as zt,B as L,ai as ce,aj as le,x as ue,ak as he,$ as F,_ as xt,O as de,a as pe,r as me,c as R}from"./worker-entry-DwuZrGJP.mjs";import"/Users/georgestander/dev/tools/chatjs/node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/__intermediate_builds/ssr/ssr_bridge.js";import{randomUUID as fe}from"node:crypto";import{getSessionByState as yt,getAuthenticatedSession as Dt,createOAuthSession as we,updateSessionByState as ge,deleteSessionByState as Ct,setOAuthClientInfoOnceByState as ve,saveTokensAndCleanup as _e,setOAuthCodeVerifierOnceByState as ye,createMcpConnector as Ce,deleteMcpConnector as Se,deleteSessionsByConnectorId as Ae,getMcpConnectorsByUserId as $t,updateMcpConnector as Lt,getMcpConnectorById as Ie,getMcpConnectorByNameId as be}from"./mcp-queries-Ch9BqnxD.mjs";import"node:events";import"cloudflare:workers";import"async_hooks";import"node:os";import"node:diagnostics_channel";import"fs";import"events";import"util";import"path";import"assert";import"node:stream";import"module";import"node:path";import"url";import"buffer";import"crypto";const at=it("mcp-cache"),ct={connectionStatus:e=>`mcp-connection-status-${e}`,discovery:e=>`mcp-discovery-${e}`};function Vt(e,t){return Ut(()=>(at.debug({connectorId:e},"Fetching connection status (cache miss)"),t()),["mcp-connection-status",e],{revalidate:300,tags:[ct.connectionStatus(e)]})}function Re(e,t){return Ut(()=>(at.debug({connectorId:e},"Fetching discovery (cache miss)"),t()),["mcp-discovery",e],{revalidate:300,tags:[ct.discovery(e)]})}function Pe(e){at.debug({connectorId:e},"Invalidating connection status cache"),Tt(ct.connectionStatus(e))}function Ee(e){at.debug({connectorId:e},"Invalidating discovery cache"),Tt(ct.discovery(e))}function Y(e){Pe(e),Ee(e)}let wt;wt=globalThis.crypto;async function Ue(e){return(await wt).getRandomValues(new Uint8Array(e))}async function Te(e){const t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~",r=Math.pow(2,8)-Math.pow(2,8)%t.length;let n="";for(;n.length<e;){const s=await Ue(e-n.length);for(const i of s)i<r&&(n+=t[i%t.length])}return n}async function Oe(e){return await Te(e)}async function Me(e){const t=await(await wt).subtle.digest("SHA-256",new TextEncoder().encode(e));return btoa(String.fromCharCode(...new Uint8Array(t))).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,"")}async function ke(e){if(e||(e=43),e<43||e>128)throw`Expected a length between 43 and 128. Received ${e}.`;const t=await Oe(e),r=await Me(t);return{code_verifier:t,code_challenge:r}}var ze="AI_MCPClientError",qt=`vercel.ai.error.${ze}`,xe=Symbol.for(qt),St,At,_=class extends(At=Q,St=xe,At){constructor({name:e="MCPClientError",message:t,cause:r,data:n,code:s}){super({name:e,message:t,cause:r}),this[St]=!0,this.data=n,this.code=s}static isInstance(e){return Q.hasMarker(e,qt)}},N="2025-06-18",De=[N,"2025-03-26","2024-11-05"],$e=p(Ot(o(),W())),Le=q({name:o(),version:o()}),lt=q({_meta:p(f({}).loose())}),x=lt,Ht=f({method:o(),params:p(lt)}),Nt=f({applyDefaults:p(U())}).loose(),Ve=q({experimental:p(f({}).loose()),logging:p(f({}).loose()),prompts:p(q({listChanged:p(U())})),resources:p(q({subscribe:p(U()),listChanged:p(U())})),tools:p(q({listChanged:p(U())})),elicitation:p(Nt)});f({elicitation:p(Nt)}).loose();var qe=x.extend({protocolVersion:o(),capabilities:Ve,serverInfo:Le,instructions:p(o())}),gt=x.extend({nextCursor:p(o())}),He=f({name:o(),description:p(o()),inputSchema:f({type:b("object"),properties:p(f({}).loose())}).loose(),annotations:p(f({title:p(o())}).loose()),_meta:$e}).loose(),Ne=gt.extend({tools:v(He)}),jt=f({type:b("text"),text:o()}).loose(),Bt=f({type:b("image"),data:zt(),mimeType:o()}).loose(),je=f({uri:o(),name:o(),title:p(o()),description:p(o()),mimeType:p(o()),size:p(L())}).loose(),Be=gt.extend({resources:v(je)}),Gt=f({uri:o(),name:p(o()),title:p(o()),mimeType:p(o())}).loose(),Ft=Gt.extend({text:o()}),Jt=Gt.extend({blob:zt()}),Wt=f({type:b("resource"),resource:k([Ft,Jt])}).loose(),Ge=x.extend({content:v(k([jt,Bt,Wt])),isError:U().default(!1).optional()}).or(x.extend({toolResult:W()})),Fe=f({uriTemplate:o(),name:o(),title:p(o()),description:p(o()),mimeType:p(o())}).loose(),Je=x.extend({resourceTemplates:v(Fe)}),We=x.extend({contents:v(k([Ft,Jt]))}),Ze=f({name:o(),description:p(o()),required:p(U())}).loose(),Xe=f({name:o(),title:p(o()),description:p(o()),arguments:p(v(Ze))}).loose(),Ke=gt.extend({prompts:v(Xe)}),Qe=f({role:k([b("user"),b("assistant")]),content:k([jt,Bt,Wt])}).loose(),Ye=x.extend({description:p(o()),messages:v(Qe)}),tr=lt.extend({message:o(),requestedSchema:W()}),It=Ht.extend({method:b("elicitation/create"),params:tr}),er=x.extend({action:k([b("accept"),b("decline"),b("cancel")]),content:p(Ot(o(),W()))}),ut="2.0",rr=f({jsonrpc:b(ut),id:k([o(),L().int()])}).merge(Ht).strict(),nr=f({jsonrpc:b(ut),id:k([o(),L().int()]),result:x}).strict(),sr=f({jsonrpc:b(ut),id:k([o(),L().int()]),error:f({code:L().int(),message:o(),data:p(W())})}).strict(),or=f({jsonrpc:b(ut)}).merge(f({method:o(),params:p(lt)})).strict(),G=k([rr,or,nr,sr]),Zt=typeof __PACKAGE_VERSION__<"u"?__PACKAGE_VERSION__:"0.0.0-test",Xt=f({access_token:o(),id_token:o().optional(),token_type:o(),expires_in:L().optional(),scope:o().optional(),refresh_token:o().optional()}).strip(),I=o().url().superRefine((e,t)=>{if(!URL.canParse(e))return t.addIssue({code:ce.custom,message:"URL must be parseable",fatal:!0}),le}).refine(e=>{const t=new URL(e);return t.protocol!=="javascript:"&&t.protocol!=="data:"&&t.protocol!=="vbscript:"},{message:"URL cannot use javascript:, data:, or vbscript: scheme"}),ir=f({resource:o().url(),authorization_servers:v(I).optional(),jwks_uri:o().url().optional(),scopes_supported:v(o()).optional(),bearer_methods_supported:v(o()).optional(),resource_signing_alg_values_supported:v(o()).optional(),resource_name:o().optional(),resource_documentation:o().optional(),resource_policy_uri:o().url().optional(),resource_tos_uri:o().url().optional(),tls_client_certificate_bound_access_tokens:U().optional(),authorization_details_types_supported:v(o()).optional(),dpop_signing_alg_values_supported:v(o()).optional(),dpop_bound_access_tokens_required:U().optional()}).passthrough(),Kt=f({issuer:o(),authorization_endpoint:I,token_endpoint:I,registration_endpoint:I.optional(),scopes_supported:v(o()).optional(),response_types_supported:v(o()),grant_types_supported:v(o()).optional(),code_challenge_methods_supported:v(o()),token_endpoint_auth_methods_supported:v(o()).optional(),token_endpoint_auth_signing_alg_values_supported:v(o()).optional()}).passthrough(),ar=f({issuer:o(),authorization_endpoint:I,token_endpoint:I,userinfo_endpoint:I.optional(),jwks_uri:I,registration_endpoint:I.optional(),scopes_supported:v(o()).optional(),response_types_supported:v(o()),grant_types_supported:v(o()).optional(),subject_types_supported:v(o()),id_token_signing_alg_values_supported:v(o()),claims_supported:v(o()).optional(),token_endpoint_auth_methods_supported:v(o()).optional()}).passthrough(),cr=ar.merge(Kt.pick({code_challenge_methods_supported:!0})),lr=f({client_id:o(),client_secret:o().optional(),client_id_issued_at:L().optional(),client_secret_expires_at:L().optional()}).strip(),ur=f({redirect_uris:v(I),token_endpoint_auth_method:o().optional(),grant_types:v(o()).optional(),response_types:v(o()).optional(),client_name:o().optional(),client_uri:I.optional(),logo_uri:I.optional(),scope:o().optional(),contacts:v(o()).optional(),tos_uri:I.optional(),policy_uri:o().optional(),jwks_uri:I.optional(),jwks:ue().optional(),software_id:o().optional(),software_version:o().optional(),software_statement:o().optional()}).strip(),hr=f({error:o(),error_description:o().optional(),error_uri:o().optional()}),dr=ur.merge(lr),pr="AI_MCPClientOAuthError",Qt=`vercel.ai.error.${pr}`,mr=Symbol.for(Qt),bt,Rt,Z=class extends(Rt=Q,bt=mr,Rt){constructor({name:e="MCPClientOAuthError",message:t,cause:r}){super({name:e,message:t,cause:r}),this[bt]=!0}static isInstance(e){return Q.hasMarker(e,Qt)}},H=class extends Z{};H.errorCode="server_error";var tt=class extends Z{};tt.errorCode="invalid_client";var et=class extends Z{};et.errorCode="invalid_grant";var rt=class extends Z{};rt.errorCode="unauthorized_client";var fr={[H.errorCode]:H,[tt.errorCode]:tt,[et.errorCode]:et,[rt.errorCode]:rt};function wr(e){const t=typeof e=="string"?new URL(e):new URL(e.href);return t.hash="",t}function gr({requestedResource:e,configuredResource:t}){const r=typeof e=="string"?new URL(e):new URL(e.href),n=typeof t=="string"?new URL(t):new URL(t.href);if(r.origin!==n.origin||r.pathname.length<n.pathname.length)return!1;const s=r.pathname.endsWith("/")?r.pathname:r.pathname+"/",i=n.pathname.endsWith("/")?n.pathname:n.pathname+"/";return s.startsWith(i)}var nt=class extends Error{constructor(e="Unauthorized"){super(e),this.name="UnauthorizedError"}};function st(e){var t;const r=(t=e.headers.get("www-authenticate"))!=null?t:e.headers.get("WWW-Authenticate");if(!r)return;const[n,s]=r.split(" ");if(n.toLowerCase()!=="bearer"||!s)return;const i=/resource_metadata="([^"]*)"/,c=r.match(i);if(c)try{return new URL(c[1])}catch{return}}function vr(e,t="",r={}){return t.endsWith("/")&&(t=t.slice(0,-1)),r.prependPathname?`${t}/.well-known/${e}`:`/.well-known/${e}${t}`}async function vt(e,t,r=fetch){try{return await r(e,{headers:t})}catch(n){if(n instanceof TypeError)return t?vt(e,void 0,r):void 0;throw n}}async function Pt(e,t,r=fetch){return await vt(e,{"MCP-Protocol-Version":t},r)}function _r(e,t){return!e||e.status>=400&&e.status<500&&t!=="/"}async function yr(e,t,r,n){var s,i;const c=new URL(e),l=(s=n?.protocolVersion)!=null?s:N;let h;if(n?.metadataUrl)h=new URL(n.metadataUrl);else{const u=vr(t,c.pathname);h=new URL(u,(i=n?.metadataServerUrl)!=null?i:c),h.search=c.search}let a=await Pt(h,l,r);if(!n?.metadataUrl&&_r(a,c.pathname)){const u=new URL(`/.well-known/${t}`,c);a=await Pt(u,l,r)}return a}async function Cr(e,t,r=fetch){const n=await yr(e,"oauth-protected-resource",r,{protocolVersion:t?.protocolVersion,metadataUrl:t?.resourceMetadataUrl});if(!n||n.status===404)throw new Error("Resource server does not implement OAuth 2.0 Protected Resource Metadata.");if(!n.ok)throw new Error(`HTTP ${n.status} trying to load well-known OAuth protected resource metadata.`);return ir.parse(await n.json())}function Sr(e){const t=typeof e=="string"?new URL(e):e,r=t.pathname!=="/",n=[];if(!r)return n.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),n.push({url:new URL("/.well-known/openid-configuration",t.origin),type:"oidc"}),n;let s=t.pathname;return s.endsWith("/")&&(s=s.slice(0,-1)),n.push({url:new URL(`/.well-known/oauth-authorization-server${s}`,t.origin),type:"oauth"}),n.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),n.push({url:new URL(`/.well-known/openid-configuration${s}`,t.origin),type:"oidc"}),n.push({url:new URL(`${s}/.well-known/openid-configuration`,t.origin),type:"oidc"}),n}async function Ar(e,{fetchFn:t=fetch,protocolVersion:r=N}={}){var n;const s={"MCP-Protocol-Version":r},i=Sr(e);for(const{url:c,type:l}of i){const h=await vt(c,s,t);if(h){if(!h.ok){if(h.status>=400&&h.status<500)continue;throw new Error(`HTTP ${h.status} trying to load ${l==="oauth"?"OAuth":"OpenID provider"} metadata from ${c}`)}if(l==="oauth")return Kt.parse(await h.json());{const a=cr.parse(await h.json());if(!((n=a.code_challenge_methods_supported)!=null&&n.includes("S256")))throw new Error(`Incompatible OIDC provider at ${c}: does not support S256 code challenge method required by MCP specification`);return a}}}}async function Ir(e,{metadata:t,clientInformation:r,redirectUrl:n,scope:s,state:i,resource:c}){const l="code",h="S256";let a;if(t){if(a=new URL(t.authorization_endpoint),!t.response_types_supported.includes(l))throw new Error(`Incompatible auth server: does not support response type ${l}`);if(!t.code_challenge_methods_supported||!t.code_challenge_methods_supported.includes(h))throw new Error(`Incompatible auth server: does not support code challenge method ${h}`)}else a=new URL("/authorize",e);const u=await ke(),m=u.code_verifier,d=u.code_challenge;return a.searchParams.set("response_type",l),a.searchParams.set("client_id",r.client_id),a.searchParams.set("code_challenge",d),a.searchParams.set("code_challenge_method",h),a.searchParams.set("redirect_uri",String(n)),i&&a.searchParams.set("state",i),s&&a.searchParams.set("scope",s),s?.includes("offline_access")&&a.searchParams.append("prompt","consent"),c&&a.searchParams.set("resource",c.href),{authorizationUrl:a,codeVerifier:m}}function Yt(e,t){const r=e.client_secret!==void 0;return t.length===0?r?"client_secret_post":"none":r&&t.includes("client_secret_basic")?"client_secret_basic":r&&t.includes("client_secret_post")?"client_secret_post":t.includes("none")?"none":r?"client_secret_post":"none"}function te(e,t,r,n){const{client_id:s,client_secret:i}=t;switch(e){case"client_secret_basic":br(s,i,r);return;case"client_secret_post":Rr(s,i,n);return;case"none":Pr(s,n);return;default:throw new Error(`Unsupported client authentication method: ${e}`)}}function br(e,t,r){if(!t)throw new Error("client_secret_basic authentication requires a client_secret");const n=btoa(`${e}:${t}`);r.set("Authorization",`Basic ${n}`)}function Rr(e,t,r){r.set("client_id",e),t&&r.set("client_secret",t)}function Pr(e,t){t.set("client_id",e)}async function _t(e){const t=e instanceof Response?e.status:void 0,r=e instanceof Response?await e.text():e;try{const n=hr.parse(JSON.parse(r)),{error:s,error_description:i,error_uri:c}=n,l=fr[s]||H;return new l({message:i||"",cause:c})}catch(n){const s=`${t?`HTTP ${t}: `:""}Invalid OAuth error response: ${n}. Raw body: ${r}`;return new H({message:s})}}async function Er(e,{metadata:t,clientInformation:r,authorizationCode:n,codeVerifier:s,redirectUri:i,resource:c,addClientAuthentication:l,fetchFn:h}){var a;const u="authorization_code",m=t?.token_endpoint?new URL(t.token_endpoint):new URL("/token",e);if(t?.grant_types_supported&&!t.grant_types_supported.includes(u))throw new Error(`Incompatible auth server: does not support grant type ${u}`);const d=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),y=new URLSearchParams({grant_type:u,code:n,code_verifier:s,redirect_uri:String(i)});if(l)l(d,y,e,t);else{const g=(a=t?.token_endpoint_auth_methods_supported)!=null?a:[],C=Yt(r,g);te(C,r,d,y)}c&&y.set("resource",c.href);const w=await(h??fetch)(m,{method:"POST",headers:d,body:y});if(!w.ok)throw await _t(w);return Xt.parse(await w.json())}async function Ur(e,{metadata:t,clientInformation:r,refreshToken:n,resource:s,addClientAuthentication:i,fetchFn:c}){var l;const h="refresh_token";let a;if(t){if(a=new URL(t.token_endpoint),t.grant_types_supported&&!t.grant_types_supported.includes(h))throw new Error(`Incompatible auth server: does not support grant type ${h}`)}else a=new URL("/token",e);const u=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),m=new URLSearchParams({grant_type:h,refresh_token:n});if(i)i(u,m,e,t);else{const y=(l=t?.token_endpoint_auth_methods_supported)!=null?l:[],w=Yt(r,y);te(w,r,u,m)}s&&m.set("resource",s.href);const d=await(c??fetch)(a,{method:"POST",headers:u,body:m});if(!d.ok)throw await _t(d);return Xt.parse({refresh_token:n,...await d.json()})}async function Tr(e,{metadata:t,clientMetadata:r,fetchFn:n}){let s;if(t){if(!t.registration_endpoint)throw new Error("Incompatible auth server: does not support dynamic client registration");s=new URL(t.registration_endpoint)}else s=new URL("/register",e);const i=await(n??fetch)(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!i.ok)throw await _t(i);return dr.parse(await i.json())}async function J(e,t){var r,n;try{return await mt(e,t)}catch(s){if(s instanceof tt||s instanceof rt)return await((r=e.invalidateCredentials)==null?void 0:r.call(e,"all")),await mt(e,t);if(s instanceof et)return await((n=e.invalidateCredentials)==null?void 0:n.call(e,"tokens")),await mt(e,t);throw s}}async function Or(e,t,r){const n=wr(e);if(t.validateResourceURL)return await t.validateResourceURL(n,r?.resource);if(r){if(!gr({requestedResource:n,configuredResource:r.resource}))throw new Error(`Protected resource ${r.resource} does not match expected ${n} (or origin)`);return new URL(r.resource)}}async function mt(e,{serverUrl:t,authorizationCode:r,scope:n,resourceMetadataUrl:s,fetchFn:i}){let c,l;try{c=await Cr(t,{resourceMetadataUrl:s},i),c.authorization_servers&&c.authorization_servers.length>0&&(l=c.authorization_servers[0])}catch{}l||(l=t);const h=await Or(t,e,c),a=await Ar(l,{fetchFn:i});let u=await Promise.resolve(e.clientInformation());if(!u){if(r!==void 0)throw new Error("Existing OAuth client information is required when exchanging an authorization code");if(!e.saveClientInformation)throw new Error("OAuth client information must be saveable for dynamic registration");const g=await Tr(l,{metadata:a,clientMetadata:e.clientMetadata,fetchFn:i});await e.saveClientInformation(g),u=g}if(r!==void 0){const g=await e.codeVerifier(),C=await Er(l,{metadata:a,clientInformation:u,authorizationCode:r,codeVerifier:g,redirectUri:e.redirectUrl,resource:h,addClientAuthentication:e.addClientAuthentication,fetchFn:i});return await e.saveTokens(C),"AUTHORIZED"}const m=await e.tokens();if(m?.refresh_token)try{const g=await Ur(l,{metadata:a,clientInformation:u,refreshToken:m.refresh_token,resource:h,addClientAuthentication:e.addClientAuthentication,fetchFn:i});return await e.saveTokens(g),"AUTHORIZED"}catch(g){if(!(!(g instanceof Z)||g instanceof H))throw g}const d=e.state?await e.state():void 0,{authorizationUrl:y,codeVerifier:w}=await Ir(l,{metadata:a,clientInformation:u,state:d,redirectUrl:e.redirectUrl,scope:n||e.clientMetadata.scope,resource:h});return await e.saveCodeVerifier(w),await e.redirectToAuthorization(y),"REDIRECT"}var Mr=class{constructor({url:e,headers:t,authProvider:r}){this.connected=!1,this.url=new URL(e),this.headers=t,this.authProvider=r}async commonHeaders(e){const t={...this.headers,...e,"mcp-protocol-version":N};if(this.authProvider){const r=await this.authProvider.tokens();r?.access_token&&(t.Authorization=`Bearer ${r.access_token}`)}return Mt(t,`ai-sdk/${Zt}`,kt())}async start(){return new Promise((e,t)=>{if(this.connected)return e();this.abortController=new AbortController;const r=async(n=!1)=>{var s,i,c,l,h;try{const a=await this.commonHeaders({Accept:"text/event-stream"}),u=await fetch(this.url.href,{headers:a,signal:(s=this.abortController)==null?void 0:s.signal});if(u.status===401&&this.authProvider&&!n){this.resourceMetadataUrl=st(u);try{if(await J(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED"){const g=new nt;return(i=this.onerror)==null||i.call(this,g),t(g)}}catch(w){return(c=this.onerror)==null||c.call(this,w),t(w)}return r(!0)}if(!u.ok||!u.body){let w=`MCP SSE Transport Error: ${u.status} ${u.statusText}`;u.status===405&&(w+=". This server does not support SSE transport. Try using `http` transport instead");const g=new _({message:w});return(l=this.onerror)==null||l.call(this,g),t(g)}const d=u.body.pipeThrough(new TextDecoderStream).pipeThrough(new ft).getReader(),y=async()=>{var w,g,C;try{for(;;){const{done:S,value:A}=await d.read();if(S){if(this.connected)throw this.connected=!1,new _({message:"MCP SSE Transport Error: Connection closed unexpectedly"});return}const{event:O,data:V}=A;if(O==="endpoint"){if(this.endpoint=new URL(V,this.url),this.endpoint.origin!==this.url.origin)throw new _({message:`MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`});this.connected=!0,e()}else if(O==="message")try{const $=G.parse(JSON.parse(V));(w=this.onmessage)==null||w.call(this,$)}catch($){const M=new _({message:"MCP SSE Transport Error: Failed to parse message",cause:$});(g=this.onerror)==null||g.call(this,M)}}}catch(S){if(S instanceof Error&&S.name==="AbortError")return;(C=this.onerror)==null||C.call(this,S),t(S)}};this.sseConnection={close:()=>d.cancel()},y()}catch(a){if(a instanceof Error&&a.name==="AbortError")return;(h=this.onerror)==null||h.call(this,a),t(a)}};r()})}async close(){var e,t,r;this.connected=!1,(e=this.sseConnection)==null||e.close(),(t=this.abortController)==null||t.abort(),(r=this.onclose)==null||r.call(this)}async send(e){if(!this.endpoint||!this.connected)throw new _({message:"MCP SSE Transport Error: Not connected"});const t=this.endpoint,r=async(n=!1)=>{var s,i,c,l,h;try{const u={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json"}),body:JSON.stringify(e),signal:(s=this.abortController)==null?void 0:s.signal},m=await fetch(t,u);if(m.status===401&&this.authProvider&&!n){this.resourceMetadataUrl=st(m);try{if(await J(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED"){const y=new nt;(i=this.onerror)==null||i.call(this,y);return}}catch(d){(c=this.onerror)==null||c.call(this,d);return}return r(!0)}if(!m.ok){const d=await m.text().catch(()=>null),y=new _({message:`MCP SSE Transport Error: POSTing to endpoint (HTTP ${m.status}): ${d}`});(l=this.onerror)==null||l.call(this,y);return}}catch(a){(h=this.onerror)==null||h.call(this,a);return}};await r()}},kr=class{constructor({url:e,headers:t,authProvider:r}){this.inboundReconnectAttempts=0,this.reconnectionOptions={initialReconnectionDelay:1e3,maxReconnectionDelay:3e4,reconnectionDelayGrowFactor:1.5,maxRetries:2},this.url=new URL(e),this.headers=t,this.authProvider=r}async commonHeaders(e){const t={...this.headers,...e,"mcp-protocol-version":N};if(this.sessionId&&(t["mcp-session-id"]=this.sessionId),this.authProvider){const r=await this.authProvider.tokens();r?.access_token&&(t.Authorization=`Bearer ${r.access_token}`)}return Mt(t,`ai-sdk/${Zt}`,kt())}async start(){if(this.abortController)throw new _({message:"MCP HTTP Transport Error: Transport already started. Note: client.connect() calls start() automatically."});this.abortController=new AbortController,this.openInboundSse()}async close(){var e,t,r;(e=this.inboundSseConnection)==null||e.close();try{if(this.sessionId&&this.abortController&&!this.abortController.signal.aborted){const n=await this.commonHeaders({});await fetch(this.url,{method:"DELETE",headers:n,signal:this.abortController.signal}).catch(()=>{})}}catch{}(t=this.abortController)==null||t.abort(),(r=this.onclose)==null||r.call(this)}async send(e){const t=async(r=!1)=>{var n,s,i,c,l,h,a;try{const m={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json",Accept:"application/json, text/event-stream"}),body:JSON.stringify(e),signal:(n=this.abortController)==null?void 0:n.signal},d=await fetch(this.url,m),y=d.headers.get("mcp-session-id");if(y&&(this.sessionId=y),d.status===401&&this.authProvider&&!r){this.resourceMetadataUrl=st(d);try{if(await J(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED")throw new nt}catch(C){throw(s=this.onerror)==null||s.call(this,C),C}return t(!0)}if(d.status===202){this.inboundSseConnection||this.openInboundSse();return}if(!d.ok){const C=await d.text().catch(()=>null);let S=`MCP HTTP Transport Error: POSTing to endpoint (HTTP ${d.status}): ${C}`;d.status===404&&(S+=". This server does not support HTTP transport. Try using `sse` transport instead");const A=new _({message:S});throw(i=this.onerror)==null||i.call(this,A),A}const w=d.headers.get("content-type")||"";if(w.includes("application/json")){const C=await d.json(),S=Array.isArray(C)?C.map(A=>G.parse(A)):[G.parse(C)];for(const A of S)(c=this.onmessage)==null||c.call(this,A);return}if(w.includes("text/event-stream")){if(!d.body){const O=new _({message:"MCP HTTP Transport Error: text/event-stream response without body"});throw(l=this.onerror)==null||l.call(this,O),O}const S=d.body.pipeThrough(new TextDecoderStream).pipeThrough(new ft).getReader();(async()=>{var O,V,$;try{for(;;){const{done:M,value:B}=await S.read();if(M)return;const{event:dt,data:ne}=B;if(dt==="message")try{const pt=G.parse(JSON.parse(ne));(O=this.onmessage)==null||O.call(this,pt)}catch(pt){const se=new _({message:"MCP HTTP Transport Error: Failed to parse message",cause:pt});(V=this.onerror)==null||V.call(this,se)}}}catch(M){if(M instanceof Error&&M.name==="AbortError")return;($=this.onerror)==null||$.call(this,M)}})();return}const g=new _({message:`MCP HTTP Transport Error: Unexpected content type: ${w}`});throw(h=this.onerror)==null||h.call(this,g),g}catch(u){throw(a=this.onerror)==null||a.call(this,u),u}};await t()}getNextReconnectionDelay(e){const{initialReconnectionDelay:t,reconnectionDelayGrowFactor:r,maxReconnectionDelay:n}=this.reconnectionOptions;return Math.min(t*Math.pow(r,e),n)}scheduleInboundSseReconnection(){var e;const{maxRetries:t}=this.reconnectionOptions;if(t>0&&this.inboundReconnectAttempts>=t){(e=this.onerror)==null||e.call(this,new _({message:`MCP HTTP Transport Error: Maximum reconnection attempts (${t}) exceeded.`}));return}const r=this.getNextReconnectionDelay(this.inboundReconnectAttempts);this.inboundReconnectAttempts+=1,setTimeout(async()=>{var n;(n=this.abortController)!=null&&n.signal.aborted||await this.openInboundSse(!1,this.lastInboundEventId)},r)}async openInboundSse(e=!1,t){var r,n,s,i,c,l;try{const h=await this.commonHeaders({Accept:"text/event-stream"});t&&(h["last-event-id"]=t);const a=await fetch(this.url.href,{method:"GET",headers:h,signal:(r=this.abortController)==null?void 0:r.signal}),u=a.headers.get("mcp-session-id");if(u&&(this.sessionId=u),a.status===401&&this.authProvider&&!e){this.resourceMetadataUrl=st(a);try{if(await J(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})!=="AUTHORIZED"){const g=new nt;(n=this.onerror)==null||n.call(this,g);return}}catch(w){(s=this.onerror)==null||s.call(this,w);return}return this.openInboundSse(!0,t)}if(a.status===405)return;if(!a.ok||!a.body){const w=new _({message:`MCP HTTP Transport Error: GET SSE failed: ${a.status} ${a.statusText}`});(i=this.onerror)==null||i.call(this,w);return}const d=a.body.pipeThrough(new TextDecoderStream).pipeThrough(new ft).getReader(),y=async()=>{var w,g,C,S;try{for(;;){const{done:A,value:O}=await d.read();if(A)return;const{event:V,data:$,id:M}=O;if(M&&(this.lastInboundEventId=M),V==="message")try{const B=G.parse(JSON.parse($));(w=this.onmessage)==null||w.call(this,B)}catch(B){const dt=new _({message:"MCP HTTP Transport Error: Failed to parse message",cause:B});(g=this.onerror)==null||g.call(this,dt)}}}catch(A){if(A instanceof Error&&A.name==="AbortError")return;(C=this.onerror)==null||C.call(this,A),(S=this.abortController)!=null&&S.signal.aborted||this.scheduleInboundSseReconnection()}};this.inboundSseConnection={close:()=>d.cancel()},this.inboundReconnectAttempts=0,y()}catch(h){if(h instanceof Error&&h.name==="AbortError")return;(c=this.onerror)==null||c.call(this,h),(l=this.abortController)!=null&&l.signal.aborted||this.scheduleInboundSseReconnection()}}};function zr(e){switch(e.type){case"sse":return new Mr(e);case"http":return new kr(e);default:throw new _({message:"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface."})}}function xr(e){return"start"in e&&typeof e.start=="function"&&"send"in e&&typeof e.send=="function"&&"close"in e&&typeof e.close=="function"}var Dr="1.0.0";async function $r(e){const t=new Lr(e);return await t.init(),t}var Lr=class{constructor({transport:e,name:t="ai-sdk-mcp-client",version:r=Dr,onUncaughtError:n,capabilities:s}){this.requestMessageId=0,this.responseHandlers=new Map,this.serverCapabilities={},this.isClosed=!0,this.onUncaughtError=n,this.clientCapabilities=s??{},xr(e)?this.transport=e:this.transport=zr(e),this.transport.onclose=()=>this.onClose(),this.transport.onerror=i=>this.onError(i),this.transport.onmessage=i=>{if("method"in i){"id"in i?this.onRequestMessage(i):this.onError(new _({message:"Unsupported message type"}));return}this.onResponse(i)},this.clientInfo={name:t,version:r}}async init(){try{await this.transport.start(),this.isClosed=!1;const e=await this.request({request:{method:"initialize",params:{protocolVersion:N,capabilities:this.clientCapabilities,clientInfo:this.clientInfo}},resultSchema:qe});if(e===void 0)throw new _({message:"Server sent invalid initialize result"});if(!De.includes(e.protocolVersion))throw new _({message:`Server's protocol version is not supported: ${e.protocolVersion}`});return this.serverCapabilities=e.capabilities,await this.notification({method:"notifications/initialized"}),this}catch(e){throw await this.close(),e}}async close(){var e;this.isClosed||(await((e=this.transport)==null?void 0:e.close()),this.onClose())}assertCapability(e){switch(e){case"initialize":break;case"tools/list":case"tools/call":if(!this.serverCapabilities.tools)throw new _({message:"Server does not support tools"});break;case"resources/list":case"resources/read":case"resources/templates/list":if(!this.serverCapabilities.resources)throw new _({message:"Server does not support resources"});break;case"prompts/list":case"prompts/get":if(!this.serverCapabilities.prompts)throw new _({message:"Server does not support prompts"});break;default:throw new _({message:`Unsupported method: ${e}`})}}async request({request:e,resultSchema:t,options:r}){return new Promise((n,s)=>{if(this.isClosed)return s(new _({message:"Attempted to send a request from a closed client"}));this.assertCapability(e.method);const i=r?.signal;i?.throwIfAborted();const c=this.requestMessageId++,l={...e,jsonrpc:"2.0",id:c},h=()=>{this.responseHandlers.delete(c)};this.responseHandlers.set(c,a=>{if(i?.aborted)return s(new _({message:"Request was aborted",cause:i.reason}));if(a instanceof Error)return s(a);try{const u=t.parse(a.result);n(u)}catch(u){const m=new _({message:"Failed to parse server response",cause:u});s(m)}}),this.transport.send(l).catch(a=>{h(),s(a)})})}async listTools({params:e,options:t}={}){try{return this.request({request:{method:"tools/list",params:e},resultSchema:Ne,options:t})}catch(r){throw r}}async callTool({name:e,args:t,options:r}){try{return this.request({request:{method:"tools/call",params:{name:e,arguments:t}},resultSchema:Ge,options:{signal:r?.abortSignal}})}catch(n){throw n}}async listResourcesInternal({params:e,options:t}={}){try{return this.request({request:{method:"resources/list",params:e},resultSchema:Be,options:t})}catch(r){throw r}}async readResourceInternal({uri:e,options:t}){try{return this.request({request:{method:"resources/read",params:{uri:e}},resultSchema:We,options:t})}catch(r){throw r}}async listResourceTemplatesInternal({options:e}={}){try{return this.request({request:{method:"resources/templates/list"},resultSchema:Je,options:e})}catch(t){throw t}}async listPromptsInternal({params:e,options:t}={}){try{return this.request({request:{method:"prompts/list",params:e},resultSchema:Ke,options:t})}catch(r){throw r}}async getPromptInternal({name:e,args:t,options:r}){try{return this.request({request:{method:"prompts/get",params:{name:e,arguments:t}},resultSchema:Ye,options:r})}catch(n){throw n}}async notification(e){const t={...e,jsonrpc:"2.0"};await this.transport.send(t)}async tools({schemas:e="automatic"}={}){var t;const r={};try{const n=await this.listTools();for(const{name:s,description:i,inputSchema:c,annotations:l,_meta:h}of n.tools){const a=l?.title;if(e!=="automatic"&&!(s in e))continue;const u=this,m=async(y,w)=>{var g;return(g=w?.abortSignal)==null||g.throwIfAborted(),u.callTool({name:s,args:y,options:w})},d=e==="automatic"?oe({description:i,title:a,inputSchema:ie({...c,properties:(t=c.properties)!=null?t:{},additionalProperties:!1}),execute:m}):ae({description:i,title:a,inputSchema:e[s].inputSchema,execute:m});r[s]={...d,_meta:h}}return r}catch(n){throw n}}listResources({params:e,options:t}={}){return this.listResourcesInternal({params:e,options:t})}readResource({uri:e,options:t}){return this.readResourceInternal({uri:e,options:t})}listResourceTemplates({options:e}={}){return this.listResourceTemplatesInternal({options:e})}experimental_listPrompts({params:e,options:t}={}){return this.listPromptsInternal({params:e,options:t})}experimental_getPrompt({name:e,arguments:t,options:r}){return this.getPromptInternal({name:e,args:t,options:r})}onElicitationRequest(e,t){if(e!==It)throw new _({message:"Unsupported request schema. Only ElicitationRequestSchema is supported."});this.elicitationRequestHandler=t}async onRequestMessage(e){try{if(e.method!=="elicitation/create"){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32601,message:`Unsupported request method: ${e.method}`}});return}if(!this.elicitationRequestHandler){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32601,message:"No elicitation handler registered on client"}});return}const t=It.safeParse({method:e.method,params:e.params});if(!t.success){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32602,message:`Invalid elicitation request: ${t.error.message}`,data:t.error.issues}});return}try{const r=await this.elicitationRequestHandler(t.data),n=er.parse(r);await this.transport.send({jsonrpc:"2.0",id:e.id,result:n})}catch(r){await this.transport.send({jsonrpc:"2.0",id:e.id,error:{code:-32603,message:r instanceof Error?r.message:"Failed to handle elicitation request"}}),this.onError(r)}}catch(t){this.onError(t)}}onClose(){if(this.isClosed)return;this.isClosed=!0;const e=new _({message:"Connection closed"});for(const t of this.responseHandlers.values())t(e);this.responseHandlers.clear()}onError(e){this.onUncaughtError&&this.onUncaughtError(e)}onResponse(e){const t=Number(e.id),r=this.responseHandlers.get(t);if(r===void 0)throw new _({message:`Protocol error: Received a response for an unknown message ID: ${JSON.stringify(e)}`});this.responseHandlers.delete(t),r("result"in e?e:new _({message:e.error.message,code:e.error.code,data:e.error.data,cause:e.error}))}};const z=it("mcp-oauth-provider");class Et extends Error{authorizationUrl;constructor(t){super("OAuth user authorization required"),this.name="OAuthAuthorizationRequiredError",this.authorizationUrl=t}}class Vr{currentOAuthState="";cachedAuthData;initialized=!1;saveCodeVerifierPromise=null;cachedAuthorizationUrl=null;config;saveClientInformationPromise=null;constructor(t){this.config=t}initializationPromise=null;async initializeOAuth(){if(this.initializationPromise)return this.initializationPromise;if(!this.initialized){this.initializationPromise=this.doInitializeOAuth();try{await this.initializationPromise}finally{this.initializationPromise=null}}}async doInitializeOAuth(){if(this.config.state){const r=await yt({state:this.config.state});if(r&&r.mcpConnectorId===this.config.mcpConnectorId){this.currentOAuthState=r.state??"",this.cachedAuthData=r,this.initialized=!0;return}}const t=await Dt({mcpConnectorId:this.config.mcpConnectorId});if(t){this.currentOAuthState=t.state??"",this.cachedAuthData=t,this.initialized=!0;return}this.currentOAuthState=fe(),this.cachedAuthData=await we({mcpConnectorId:this.config.mcpConnectorId,serverUrl:this.config.serverUrl,state:this.currentOAuthState}),this.initialized=!0}async getAuthData(){return await this.initializeOAuth(),this.cachedAuthData}async updateAuthData(t){if(!this.currentOAuthState)throw new Error("OAuth not initialized");return this.cachedAuthData=await ge({state:this.currentOAuthState,updates:t}),this.cachedAuthData}get redirectUrl(){return this.config.clientMetadata.redirect_uris[0]}get clientMetadata(){return this.config.clientMetadata}state(){return this.currentOAuthState}async clientInformation(){const t=await this.getAuthData();if(t?.clientInfo){const r=t.clientInfo;if(!t.tokens&&r.redirect_uris[0]!==this.redirectUrl){z.warn({state:t.state,savedRedirectUri:r.redirect_uris[0],currentRedirectUri:this.redirectUrl},"clientInformation: redirect URI mismatch, invalidating session"),t.state&&await Ct({state:t.state}),this.cachedAuthData=void 0,this.initialized=!1;return}return r}}async saveClientInformation(t){if(this.saveClientInformationPromise){await this.saveClientInformationPromise;return}this.cachedAuthData?.clientInfo||(this.cachedAuthData&&(this.cachedAuthData={...this.cachedAuthData,clientInfo:t}),this.saveClientInformationPromise=ve({state:this.currentOAuthState,clientInfo:t}).then(r=>{this.cachedAuthData=r}).finally(()=>{this.saveClientInformationPromise=null}),await this.saveClientInformationPromise)}async tokens(){return(await this.getAuthData())?.tokens}async saveTokens(t){this.cachedAuthData=await _e({state:this.currentOAuthState,mcpConnectorId:this.config.mcpConnectorId,tokens:t})}async redirectToAuthorization(t){if(t.searchParams.set("state",this.state()),this.cachedAuthorizationUrl){await this.config.onRedirectToAuthorization(this.cachedAuthorizationUrl);return}this.cachedAuthorizationUrl=new URL(t.toString()),await this.config.onRedirectToAuthorization(t)}async saveCodeVerifier(t){if(this.saveCodeVerifierPromise){await this.saveCodeVerifierPromise;return}const r=this.cachedAuthData?.codeVerifier;if(r){z.info({state:this.currentOAuthState,existingVerifierPrefix:r.slice(0,10),newVerifierPrefix:t.slice(0,10)},"saveCodeVerifier: SKIPPING - verifier already exists");return}z.info({state:this.currentOAuthState,codeVerifierPrefix:t.slice(0,10)},"saveCodeVerifier: saving first verifier"),this.cachedAuthData&&(this.cachedAuthData={...this.cachedAuthData,codeVerifier:t}),this.saveCodeVerifierPromise=ye({state:this.currentOAuthState,codeVerifier:t}).then(n=>{this.cachedAuthData=n}).finally(()=>{this.saveCodeVerifierPromise=null}),await this.saveCodeVerifierPromise}async codeVerifier(){const t=await this.getAuthData();if(z.info({state:this.currentOAuthState,hasCodeVerifier:!!t?.codeVerifier,codeVerifierPrefix:t?.codeVerifier?.slice(0,10)},"codeVerifier called"),!t?.codeVerifier)throw new Error("OAuth code verifier not found");return t.codeVerifier}async adoptState(t){if(!t){z.warn("adoptState called with empty state");return}if(this.initialized&&this.currentOAuthState===t){z.info({state:t},"adoptState: already initialized with this state");return}const r=await yt({state:t});if(!r){z.warn({state:t},"adoptState: session not found");return}if(r.mcpConnectorId!==this.config.mcpConnectorId){z.warn({state:t,sessionConnectorId:r.mcpConnectorId,expectedConnectorId:this.config.mcpConnectorId},"adoptState: connector ID mismatch");return}z.info({state:t,previousState:this.currentOAuthState,wasInitialized:this.initialized,hasCodeVerifier:!!r.codeVerifier,hasClientInfo:!!r.clientInfo,hasTokens:!!r.tokens},"adoptState: adopting session (overriding previous state if any)"),this.currentOAuthState=t,this.cachedAuthData=r,this.initialized=!0}async invalidateCredentials(t){t==="all"?(await Ct({state:this.currentOAuthState}),this.cachedAuthData=void 0,this.initialized=!1,this.currentOAuthState=""):t==="tokens"?await this.updateAuthData({tokens:null}):t==="client"?(await this.updateAuthData({clientInfo:null}),this.initialized=!1,this.currentOAuthState="",this.cachedAuthData=void 0):t==="verifier"&&(await this.updateAuthData({codeVerifier:null}),this.cachedAuthorizationUrl=null)}}const K=it("mcp-client");class qr{client;oauthProvider;authorizationUrl;_status="disconnected";id;name;serverConfig;constructor(t,r,n){this.id=t,this.name=r,this.serverConfig=n;const s=he();this.oauthProvider=new Vr({mcpConnectorId:this.id,serverUrl:this.serverConfig.url,clientMetadata:{client_name:`${F.appPrefix}-${this.name}`,grant_types:["authorization_code","refresh_token"],response_types:["code"],token_endpoint_auth_method:"none",scope:"mcp:tools",redirect_uris:[`${s}/api/mcp/oauth/callback`],software_id:F.appPrefix,software_version:"1.0.0"},onRedirectToAuthorization:i=>{throw this.authorizationUrl=i,new Et(i)}})}get status(){return this.authorizationUrl?"authorizing":this.client?"connected":this._status}getAuthorizationUrl(){return this.authorizationUrl}async connect(t){if(this.status==="connected"&&this.client)return this.client;this._status="connecting",t&&await this.oauthProvider.adoptState(t);try{return this.client=await $r({transport:{type:this.serverConfig.type,url:this.serverConfig.url,headers:this.serverConfig.headers,authProvider:this.oauthProvider}}),this._status="connected",this.client}catch(r){if(r instanceof Et){this._status="authorizing",K.info({connectorId:this.id,authUrl:r.authorizationUrl.toString()},"OAuth authorization required");return}throw this._status="disconnected",r}}async attemptConnection(){if(this.status==="connected"&&this.client)return{status:"connected",needsAuth:!1};if(this.authorizationUrl)return{status:"authorizing",needsAuth:!0};try{return await this.connect(),this.authorizationUrl?{status:"authorizing",needsAuth:!0}:{status:this.client?"connected":"disconnected",needsAuth:!1}}catch(t){const r=t instanceof Error?t.message:String(t);return K.error({connectorId:this.id,errorMessage:r,errorStack:t instanceof Error?t.stack:void 0},"attemptConnection failed"),r.includes("does not support dynamic client registration")?(this._status="incompatible",{status:"incompatible",needsAuth:!1,error:"Server requires pre-configured OAuth credentials (does not support dynamic client registration)"}):{status:"disconnected",needsAuth:!1,error:r}}}async finishAuth(t,r){await this.oauthProvider.adoptState(r),await J(this.oauthProvider,{serverUrl:this.serverConfig.url,authorizationCode:t}),this.authorizationUrl=void 0}async tools(){if(!this.client)throw new Error("Client not connected");try{return await this.client.tools()}catch(t){throw this.handlePotentialAuthError(t),t}}async listResources(){if(!this.client)throw new Error("Client not connected");try{return await this.client.listResources()}catch(t){throw this.handlePotentialAuthError(t),t}}async listPrompts(){if(!this.client)throw new Error("Client not connected");try{return await this.client.experimental_listPrompts()}catch(t){throw this.handlePotentialAuthError(t),t}}async close(){try{await this.client?.close()}catch(t){K.error({error:t,connectorId:this.id},"Error closing MCP client")}this.client=void 0,this._status="disconnected",Y(this.id)}handlePotentialAuthError(t){const r=t instanceof Error?t.message:String(t);(r.includes("401")||r.includes("403")||r.includes("Unauthorized")||r.includes("Forbidden")||r.includes("token"))&&(K.warn({connectorId:this.id,errorMessage:r},"Auth error detected, invalidating caches"),Y(this.id))}}const ot=new Map;function X({id:e,name:t,url:r,type:n,headers:s}){let i=ot.get(e);return i||(i=new qr(e,t,{url:r,type:n,headers:s}),ot.set(e,i)),i}async function ht(e){const t=ot.get(e);t&&(await t.close(),ot.delete(e))}const Hr=/_+/g,Nr=/^_|_$/g,jr=/[^a-z0-9]/g,ee=20,Br="global";function Gr(e){const t=e.toLowerCase().replace(jr,"_").replace(Hr,"_").replace(Nr,"");return t?t===Br?{ok:!1,error:"reserved"}:{ok:!0,nameId:t}:{ok:!1,error:"empty"}}const Fr=f({name:o().min(1).max(ee),url:o().url(),type:xt(["http","sse"]),oauthClientId:o().optional(),oauthClientSecret:o().optional()}),Jr=f({id:o().uuid(),updates:f({name:o().min(1).max(ee).optional(),url:o().url().optional(),type:xt(["http","sse"]).optional(),oauthClientId:o().nullable().optional(),oauthClientSecret:o().nullable().optional(),enabled:U().optional()})}),j=f({id:o().uuid()}),Wr=f({id:o().uuid(),enabled:U()}),Zr=f({id:de()}),E=it("mcp.actions");function T(){if(!F.integrations.mcp)throw new Error("MCP integration disabled")}async function P(){const e=await pe.api.getSession({headers:me.request.headers});if(!e?.user)throw new Error("UNAUTHORIZED");const{id:t,...r}=e.user;if(!t)throw console.error("User ID missing in session callback"),new Error("UNAUTHORIZED");return{id:t,...r}}async function re({name:e,userId:t,excludeId:r}){T();const n=Gr(e);if(!n.ok)throw new Error(n.error==="empty"?"Connector name must contain at least one alphanumeric character":'Connector name cannot be "global" (reserved)');if(await be({userId:t,nameId:n.nameId,excludeId:r}))throw new Error(`A connector with namespace "${n.nameId}" already exists. Choose a different name.`);return n.nameId}async function D({id:e,userId:t,permission:r}){const n=await Ie({id:e});if(!n)throw new Error("Connector not found");const s=n.userId===t,i=n.userId===null;if(!(r==="own"?s:s||i))throw new Error("Cannot access this connector");return n}async function Xr(){const e=await P();return F.integrations.mcp?await $t({userId:e.id}):[]}async function Kr(){const e=await P();if(!F.integrations.mcp)return[];const t=await $t({userId:e.id});return(await Promise.all(t.map(async n=>{const s=async()=>{const l=await X({id:n.id,name:n.name,url:n.url,type:n.type}).attemptConnection();return{status:l.status,needsAuth:l.needsAuth,error:l.error}},i=Vt(n.id,s);try{const c=await i();return{connector:n,status:c}}catch{return{connector:n,status:null}}}))).filter(n=>n.status?.status==="connected").map(n=>n.connector)}async function Qr(e){const t=await P(),r=Fr.parse(e);T();const n=await re({name:r.name,userId:t.id});return await Ce({userId:t.id,name:r.name,nameId:n,url:r.url,type:r.type,oauthClientId:r.oauthClientId,oauthClientSecret:r.oauthClientSecret})}async function Yr(e){const t=await P(),r=Jr.parse(e);T();const n=await D({id:r.id,userId:t.id,permission:"own"}),s={...r.updates};if(s.name){const i=await re({name:s.name,userId:n.userId,excludeId:r.id});s.nameId=i}return await Lt({id:r.id,updates:s}),{success:!0}}async function tn(e){const t=await P(),r=j.parse(e);return T(),await D({id:r.id,userId:t.id,permission:"own"}),await Se({id:r.id}),await ht(r.id),{success:!0}}async function en(e){const t=await P(),r=j.parse(e);return T(),await D({id:r.id,userId:t.id,permission:"own-or-global"}),await Ae({mcpConnectorId:r.id}),await ht(r.id),Y(r.id),{success:!0}}async function rn(e){const t=await P(),r=Wr.parse(e);return T(),await D({id:r.id,userId:t.id,permission:"own"}),await Lt({id:r.id,updates:{enabled:r.enabled}}),{success:!0}}async function nn(e){const t=await P(),r=j.parse(e);T();const n=await D({id:r.id,userId:t.id,permission:"own-or-global"}),s=async()=>{E.debug({connectorId:n.id,url:n.url},"testing MCP connection (cache miss)");const l=await X({id:n.id,name:n.name,url:n.url,type:n.type}).attemptConnection();return E.debug({connectorId:n.id,status:l.status,needsAuth:l.needsAuth,error:l.error},"MCP connection test completed"),{status:l.status,needsAuth:l.needsAuth,error:l.error}};return Vt(n.id,s)()}async function sn(e){const t=await P(),r=Zr.parse(e);T();const n=await D({id:r.id,userId:t.id,permission:"own-or-global"}),s=async()=>{E.debug({connectorId:n.id,url:n.url},"creating MCP client for discovery (cache miss)");const c=X({id:n.id,name:n.name,url:n.url,type:n.type});if(await c.connect(),c.status==="authorizing")throw new Error("Connector requires OAuth authorization");if(c.status!=="connected")throw new Error(`Failed to connect to MCP server (status: ${c.status})`);E.debug({connectorId:n.id},"MCP client connected, discovering capabilities");try{const[l,h,a]=await Promise.all([c.tools().then(u=>Object.entries(u).map(([m,d])=>({name:m,description:d.description??null}))).catch(u=>(E.warn({connectorId:n.id,err:u},"failed to list tools"),[])),c.listResources().then(u=>u.resources.map(m=>({name:m.name,uri:m.uri,description:m.description??null,mimeType:m.mimeType??null}))).catch(u=>(E.warn({connectorId:n.id,err:u},"failed to list resources"),[])),c.listPrompts().then(u=>u.prompts.map(m=>({name:m.name,description:m.description??null,arguments:m.arguments?.map(d=>({name:d.name,description:d.description??null,required:d.required??!1}))??[]}))).catch(u=>(E.warn({connectorId:n.id,err:u},"failed to list prompts"),[]))]);return E.info({connectorId:n.id,toolsCount:l.length,resourcesCount:h.length,promptsCount:a.length},"MCP discovery completed"),{tools:l,resources:h,prompts:a}}finally{E.debug({connectorId:n.id},"MCP discovery finished")}};return Re(n.id,s)()}async function on(e){const t=await P(),r=j.parse(e);T();const n=await D({id:r.id,userId:t.id,permission:"own-or-global"});E.info({connectorId:n.id},"Initiating OAuth authorization"),await ht(n.id);const s=X({id:n.id,name:n.name,url:n.url,type:n.type});if(await s.connect(),s.status!=="authorizing")throw new Error("Connector does not require OAuth authorization");const i=s.getAuthorizationUrl();if(!i)throw new Error("Failed to get authorization URL");return E.info({connectorId:n.id,authUrl:i.toString()},"OAuth authorization URL generated"),{authorizationUrl:i.toString()}}async function an(e){const t=await P(),r=j.parse(e);T();const n=await D({id:r.id,userId:t.id,permission:"own-or-global"}),s=await Dt({mcpConnectorId:n.id});return{isAuthenticated:!!s?.tokens,hasSession:!!s}}async function cn(e){const t=await P(),r=j.parse(e);T();const n=await D({id:r.id,userId:t.id,permission:"own-or-global"});await ht(n.id),Y(n.id);const s=X({id:n.id,name:n.name,url:n.url,type:n.type});return await s.connect(),{status:s.status,needsAuth:s.status==="authorizing"}}R(Xr,"/src/server/actions/mcp.ts","list");R(Kr,"/src/server/actions/mcp.ts","listConnected");R(Qr,"/src/server/actions/mcp.ts","create");R(Yr,"/src/server/actions/mcp.ts","update");R(tn,"/src/server/actions/mcp.ts","deleteConnector");R(en,"/src/server/actions/mcp.ts","disconnect");R(rn,"/src/server/actions/mcp.ts","toggleEnabled");R(nn,"/src/server/actions/mcp.ts","testConnection");R(sn,"/src/server/actions/mcp.ts","discover");R(on,"/src/server/actions/mcp.ts","authorize");R(an,"/src/server/actions/mcp.ts","checkAuth");R(cn,"/src/server/actions/mcp.ts","refreshClient");export{on as authorize,an as checkAuth,Qr as create,tn as deleteConnector,en as disconnect,sn as discover,Xr as list,Kr as listConnected,cn as refreshClient,nn as testConnection,rn as toggleEnabled,Yr as update};
//# sourceMappingURL=mcp-CVNwIaLh.mjs.map
