import{az as N,aB as S,aC as X}from"./worker-entry-DwuZrGJP.mjs";import{aD as le}from"./worker-entry-DwuZrGJP.mjs";import"node:events";import"cloudflare:workers";import"/Users/georgestander/dev/tools/chatjs/node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/__intermediate_builds/ssr/ssr_bridge.js";import"async_hooks";import"node:os";import"node:diagnostics_channel";import"fs";import"events";import"util";import"path";import"assert";import"node:stream";import"module";import"node:path";import"url";import"buffer";import"crypto";import"node:crypto";const se=(F,m)=>{let O=null;const k=A=>({getFieldName:w,schema:I,getDefaultFieldName:G,getDefaultModelName:D,getFieldAttributes:L,getModelName:_})=>{const x=s=>{const u=[],i=[];if(s)for(const[n,r]of Object.entries(s)){const t=I[D(n)]?.fields,[e,a]=n.includes(".")?n.split("."):[void 0,n];if(t){t.id={type:"string"};for(const[o,p]of Object.entries(t))u.push(S`${S.ref(`join_${a}`)}.${S.ref(p.fieldName||o)} as ${S.ref(`_joined_${a}_${p.fieldName||o}`)}`),i.push({joinModel:n,joinModelRef:a,fieldName:p.fieldName||o})}}return{allSelectsStr:i,allSelects:u}},v=async(s,u,i,n)=>{let r;if(m?.type==="mysql"){await u.execute();const t=s.id?"id":n.length>0&&n[0]?.field?n[0].field:"id";if(!s.id&&n.length===0)return r=await A.selectFrom(i).selectAll().orderBy(w({model:i,field:t}),"desc").limit(1).executeTakeFirst(),r;const e=s[t]||n[0]?.value;return r=await A.selectFrom(i).selectAll().orderBy(w({model:i,field:t}),"desc").where(w({model:i,field:t}),"=",e).limit(1).executeTakeFirst(),r}return m?.type==="mssql"?(r=await u.outputAll("inserted").executeTakeFirst(),r):(r=await u.returningAll().executeTakeFirst(),r)};function M(s,u){if(!u)return{and:null,or:null};const i={and:[],or:[]};return u.forEach(n=>{const{field:r,value:t,operator:e="=",connector:a="AND"}=n,o=t,p=w({model:s,field:r}),y=f=>{const l=`${s}.${p}`;return e.toLowerCase()==="in"?f(l,"in",Array.isArray(o)?o:[o]):e.toLowerCase()==="not_in"?f(l,"not in",Array.isArray(o)?o:[o]):e==="contains"?f(l,"like",`%${o}%`):e==="starts_with"?f(l,"like",`${o}%`):e==="ends_with"?f(l,"like",`%${o}`):e==="eq"?f(l,"=",o):e==="ne"?f(l,"<>",o):e==="gt"?f(l,">",o):e==="gte"?f(l,">=",o):e==="lt"?f(l,"<",o):e==="lte"?f(l,"<=",o):f(l,e,o)};a==="OR"?i.or.push(y):i.and.push(y)}),{and:i.and.length?i.and:null,or:i.or.length?i.or:null}}function R(s,u,i){if(!u||!s.length)return s;const n=new Map;for(const t of s){const e={},a={};for(const[y]of Object.entries(u))a[_(y)]={};for(const[y,f]of Object.entries(t)){const l=String(y);let c=!1;for(const{joinModel:d,fieldName:h,joinModelRef:j}of i)if(l===`_joined_${j}_${h}`){a[_(d)][w({model:d,field:h})]=f,c=!0;break}c||(e[y]=f)}const o=e.id;if(!o)continue;if(!n.has(o)){const y={...e};for(const[f,l]of Object.entries(u))y[_(f)]=l.relation==="one-to-one"?null:[];n.set(o,y)}const p=n.get(o);for(const[y,f]of Object.entries(u)){const l=f.relation==="one-to-one",c=f.limit??100,d=a[_(y)],h=d&&Object.keys(d).length>0&&Object.values(d).some(j=>j!=null);if(l)p[_(y)]=h?d:null;else{const j=_(y);if(Array.isArray(p[j])&&h){if(p[j].length>=c)continue;const E=w({model:y,field:"id"}),T=d[E];T?!p[j].some(J=>J[E]===T)&&p[j].length<c&&p[j].push(d):p[j].length<c&&p[j].push(d)}}}}const r=Array.from(n.values());for(const t of r)for(const[e,a]of Object.entries(u))if(a.relation!=="one-to-one"){const o=_(e);if(Array.isArray(t[o])){const p=a.limit??100;t[o].length>p&&(t[o]=t[o].slice(0,p))}}return r}return{async create({data:s,model:u}){return await v(s,A.insertInto(u).values(s),u,[])},async findOne({model:s,where:u,select:i,join:n}){const{and:r,or:t}=M(s,u);let e=A.selectFrom(f=>{let l=f.selectFrom(s);return r&&(l=l.where(c=>c.and(r.map(d=>d(c))))),t&&(l=l.where(c=>c.or(t.map(d=>d(c))))),l.selectAll().as("primary")}).selectAll("primary");if(n)for(const[f,l]of Object.entries(n)){const[c,d]=f.includes(".")?f.split("."):[void 0,f];e=e.leftJoin(`${f} as join_${d}`,h=>h.onRef(`join_${d}.${l.on.to}`,"=",`primary.${l.on.from}`))}const{allSelectsStr:a,allSelects:o}=x(n);e=e.select(o);const p=await e.execute();if(!p||!Array.isArray(p)||p.length===0)return null;const y=p[0];return n?R(p,n,a)[0]:y},async findMany({model:s,where:u,limit:i,offset:n,sortBy:r,join:t}){const{and:e,or:a}=M(s,u);let o=A.selectFrom(l=>{let c=l.selectFrom(s);return m?.type==="mssql"?n!==void 0?(r||(c=c.orderBy(w({model:s,field:"id"}))),c=c.offset(n).fetch(i||100)):i!==void 0&&(c=c.top(i)):(i!==void 0&&(c=c.limit(i)),n!==void 0&&(c=c.offset(n))),r?.field&&(c=c.orderBy(`${w({model:s,field:r.field})}`,r.direction)),e&&(c=c.where(d=>d.and(e.map(h=>h(d))))),a&&(c=c.where(d=>d.or(a.map(h=>h(d))))),c.selectAll().as("primary")}).selectAll("primary");if(t)for(const[l,c]of Object.entries(t)){const[d,h]=l.includes(".")?l.split("."):[void 0,l];o=o.leftJoin(`${l} as join_${h}`,j=>j.onRef(`join_${h}.${c.on.to}`,"=",`primary.${c.on.from}`))}const{allSelectsStr:p,allSelects:y}=x(t);o=o.select(y),r?.field&&(o=o.orderBy(`${w({model:s,field:r.field})}`,r.direction));const f=await o.execute();return f?t?R(f,t,p):f:[]},async update({model:s,where:u,update:i}){const{and:n,or:r}=M(s,u);let t=A.updateTable(s).set(i);return n&&(t=t.where(e=>e.and(n.map(a=>a(e))))),r&&(t=t.where(e=>e.or(r.map(a=>a(e))))),await v(i,t,s,u)},async updateMany({model:s,where:u,update:i}){const{and:n,or:r}=M(s,u);let t=A.updateTable(s).set(i);n&&(t=t.where(a=>a.and(n.map(o=>o(a))))),r&&(t=t.where(a=>a.or(r.map(o=>o(a)))));const e=(await t.executeTakeFirst()).numUpdatedRows;return e>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:Number(e)},async count({model:s,where:u}){const{and:i,or:n}=M(s,u);let r=A.selectFrom(s).select(A.fn.count("id").as("count"));i&&(r=r.where(e=>e.and(i.map(a=>a(e))))),n&&(r=r.where(e=>e.or(n.map(a=>a(e)))));const t=await r.execute();return typeof t[0].count=="number"?t[0].count:typeof t[0].count=="bigint"?Number(t[0].count):parseInt(t[0].count)},async delete({model:s,where:u}){const{and:i,or:n}=M(s,u);let r=A.deleteFrom(s);i&&(r=r.where(t=>t.and(i.map(e=>e(t))))),n&&(r=r.where(t=>t.or(n.map(e=>e(t))))),await r.execute()},async deleteMany({model:s,where:u}){const{and:i,or:n}=M(s,u);let r=A.deleteFrom(s);i&&(r=r.where(e=>e.and(i.map(a=>a(e))))),n&&(r=r.where(e=>e.or(n.map(a=>a(e)))));const t=(await r.executeTakeFirst()).numDeletedRows;return t>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:Number(t)},options:m}};let q=null;q={config:{adapterId:"kysely",adapterName:"Kysely Adapter",usePlural:m?.usePlural,debugLogs:m?.debugLogs,supportsBooleans:!(m?.type==="sqlite"||m?.type==="mssql"||m?.type==="mysql"||!m?.type),supportsDates:!(m?.type==="sqlite"||m?.type==="mssql"||!m?.type),supportsJSON:m?.type==="postgres",supportsArrays:!1,supportsUUIDs:m?.type==="postgres",transaction:m?.transaction?A=>F.transaction().execute(w=>A(N({config:q.config,adapter:k(w)})(O))):!1},adapter:k(F)};const $=N(q);return A=>(O=A,$(A))};export{X as createKyselyAdapter,le as getKyselyDatabaseType,se as kyselyAdapter};
//# sourceMappingURL=index-BZUOGsgi.mjs.map
