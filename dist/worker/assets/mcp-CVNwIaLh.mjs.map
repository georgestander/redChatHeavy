{"version":3,"file":"mcp-CVNwIaLh.mjs","sources":["../../../lib/ai/mcp/cache.ts","../../../node_modules/.pnpm/pkce-challenge@5.0.1/node_modules/pkce-challenge/dist/index.browser.js","../../../node_modules/.pnpm/@ai-sdk+mcp@1.0.0_zod@4.3.6/node_modules/@ai-sdk/mcp/dist/index.mjs","../../../lib/ai/mcp/mcp-oauth-provider.ts","../../../lib/ai/mcp/mcp-client.ts","../../../lib/ai/mcp-name-id.ts","../../../src/lib/schemas/mcp.ts","../../../src/server/actions/mcp.ts"],"sourcesContent":["import { revalidateTag, unstable_cache } from \"@/lib/cache/kv-cache\";\nimport { createModuleLogger } from \"@/lib/logger\";\n\nconst log = createModuleLogger(\"mcp-cache\");\n\n// Cache tags\nconst mcpCacheTags = {\n  connectionStatus: (connectorId: string) =>\n    `mcp-connection-status-${connectorId}`,\n  discovery: (connectorId: string) => `mcp-discovery-${connectorId}`,\n} as const;\n\n// Types for cached results\nexport type ConnectionStatusResult = {\n  status:\n    | \"disconnected\"\n    | \"connecting\"\n    | \"connected\"\n    | \"authorizing\"\n    | \"incompatible\";\n  needsAuth: boolean;\n  error?: string;\n};\n\nexport type DiscoveryResult = {\n  tools: Array<{ name: string; description: string | null }>;\n  resources: Array<{\n    name: string;\n    uri: string;\n    description: string | null;\n    mimeType: string | null;\n  }>;\n  prompts: Array<{\n    name: string;\n    description: string | null;\n    arguments: Array<{\n      name: string;\n      description: string | null;\n      required: boolean;\n    }>;\n  }>;\n};\n\n/**\n * Create a cached connection status fetcher for a specific connector.\n * Cache duration: 5 minutes\n */\nexport function createCachedConnectionStatus(\n  connectorId: string,\n  fetcher: () => Promise<ConnectionStatusResult>\n) {\n  return unstable_cache(\n    () => {\n      log.debug({ connectorId }, \"Fetching connection status (cache miss)\");\n      return fetcher();\n    },\n    [\"mcp-connection-status\", connectorId],\n    {\n      revalidate: 300,\n      tags: [mcpCacheTags.connectionStatus(connectorId)],\n    }\n  );\n}\n\n/**\n * Create a cached discovery fetcher for a specific connector.\n * Cache duration: 5 minutes (tools/resources/prompts rarely change)\n */\nexport function createCachedDiscovery(\n  connectorId: string,\n  fetcher: () => Promise<DiscoveryResult>\n) {\n  return unstable_cache(\n    () => {\n      log.debug({ connectorId }, \"Fetching discovery (cache miss)\");\n      return fetcher();\n    },\n    [\"mcp-discovery\", connectorId],\n    {\n      revalidate: 300,\n      tags: [mcpCacheTags.discovery(connectorId)],\n    }\n  );\n}\n\n/**\n * Invalidate connection status cache for a connector.\n * Call this on: auth errors, disconnect, OAuth completion\n */\nfunction invalidateConnectionStatus(connectorId: string) {\n  log.debug({ connectorId }, \"Invalidating connection status cache\");\n  revalidateTag(mcpCacheTags.connectionStatus(connectorId), \"max\");\n}\n\n/**\n * Invalidate discovery cache for a connector.\n * Call this on: disconnect, OAuth completion, refreshClient\n */\nfunction invalidateDiscovery(connectorId: string) {\n  log.debug({ connectorId }, \"Invalidating discovery cache\");\n  revalidateTag(mcpCacheTags.discovery(connectorId), \"max\");\n}\n\n/**\n * Invalidate all MCP caches for a connector.\n */\nexport function invalidateAllMcpCaches(connectorId: string) {\n  invalidateConnectionStatus(connectorId);\n  invalidateDiscovery(connectorId);\n}\n","let crypto;\ncrypto = globalThis.crypto; // web browsers\n/**\n * Creates an array of length `size` of random bytes\n * @param size\n * @returns Array of random ints (0 to 255)\n */\nasync function getRandomValues(size) {\n    return (await crypto).getRandomValues(new Uint8Array(size));\n}\n/** Generate cryptographically strong random string\n * @param size The desired length of the string\n * @returns The random string\n */\nasync function random(size) {\n    const mask = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~\";\n    const evenDistCutoff = Math.pow(2, 8) - Math.pow(2, 8) % mask.length;\n    let result = \"\";\n    while (result.length < size) {\n        const randomBytes = await getRandomValues(size - result.length);\n        for (const randomByte of randomBytes) {\n            if (randomByte < evenDistCutoff) {\n                result += mask[randomByte % mask.length];\n            }\n        }\n    }\n    return result;\n}\n/** Generate a PKCE challenge verifier\n * @param length Length of the verifier\n * @returns A random verifier `length` characters long\n */\nasync function generateVerifier(length) {\n    return await random(length);\n}\n/** Generate a PKCE code challenge from a code verifier\n * @param code_verifier\n * @returns The base64 url encoded code challenge\n */\nexport async function generateChallenge(code_verifier) {\n    const buffer = await (await crypto).subtle.digest(\"SHA-256\", new TextEncoder().encode(code_verifier));\n    // Generate base64url string\n    // btoa is deprecated in Node.js but is used here for web browser compatibility\n    // (which has no good replacement yet, see also https://github.com/whatwg/html/issues/6811)\n    return btoa(String.fromCharCode(...new Uint8Array(buffer)))\n        .replace(/\\//g, '_')\n        .replace(/\\+/g, '-')\n        .replace(/=/g, '');\n}\n/** Generate a PKCE challenge pair\n * @param length Length of the verifer (between 43-128). Defaults to 43.\n * @returns PKCE challenge pair\n */\nexport default async function pkceChallenge(length) {\n    if (!length)\n        length = 43;\n    if (length < 43 || length > 128) {\n        throw `Expected a length between 43 and 128. Received ${length}.`;\n    }\n    const verifier = await generateVerifier(length);\n    const challenge = await generateChallenge(verifier);\n    return {\n        code_verifier: verifier,\n        code_challenge: challenge,\n    };\n}\n/** Verify that a code_verifier produces the expected code challenge\n * @param code_verifier\n * @param expectedChallenge The code challenge to verify\n * @returns True if challenges are equal. False otherwise.\n */\nexport async function verifyChallenge(code_verifier, expectedChallenge) {\n    const actualChallenge = await generateChallenge(code_verifier);\n    return actualChallenge === expectedChallenge;\n}\n","// src/tool/mcp-client.ts\nimport {\n  dynamicTool,\n  jsonSchema,\n  tool\n} from \"@ai-sdk/provider-utils\";\n\n// src/error/mcp-client-error.ts\nimport { AISDKError } from \"@ai-sdk/provider\";\nvar name = \"AI_MCPClientError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a, _b;\nvar MCPClientError = class extends (_b = AISDKError, _a = symbol, _b) {\n  constructor({\n    name: name3 = \"MCPClientError\",\n    message,\n    cause,\n    data,\n    code\n  }) {\n    super({ name: name3, message, cause });\n    this[_a] = true;\n    this.data = data;\n    this.code = code;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker);\n  }\n};\n\n// src/tool/mcp-sse-transport.ts\nimport {\n  EventSourceParserStream,\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent\n} from \"@ai-sdk/provider-utils\";\n\n// src/tool/json-rpc-message.ts\nimport { z as z2 } from \"zod/v4\";\n\n// src/tool/types.ts\nimport { z } from \"zod/v4\";\nvar LATEST_PROTOCOL_VERSION = \"2025-06-18\";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2025-03-26\",\n  \"2024-11-05\"\n];\nvar ToolMetaSchema = z.optional(z.record(z.string(), z.unknown()));\nvar ClientOrServerImplementationSchema = z.looseObject({\n  name: z.string(),\n  version: z.string()\n});\nvar BaseParamsSchema = z.looseObject({\n  _meta: z.optional(z.object({}).loose())\n});\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseParamsSchema)\n});\nvar ElicitationCapabilitySchema = z.object({\n  applyDefaults: z.optional(z.boolean())\n}).loose();\nvar ServerCapabilitiesSchema = z.looseObject({\n  experimental: z.optional(z.object({}).loose()),\n  logging: z.optional(z.object({}).loose()),\n  prompts: z.optional(\n    z.looseObject({\n      listChanged: z.optional(z.boolean())\n    })\n  ),\n  resources: z.optional(\n    z.looseObject({\n      subscribe: z.optional(z.boolean()),\n      listChanged: z.optional(z.boolean())\n    })\n  ),\n  tools: z.optional(\n    z.looseObject({\n      listChanged: z.optional(z.boolean())\n    })\n  ),\n  elicitation: z.optional(ElicitationCapabilitySchema)\n});\nvar ClientCapabilitiesSchema = z.object({\n  elicitation: z.optional(ElicitationCapabilitySchema)\n}).loose();\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: z.optional(z.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: z.optional(z.string())\n});\nvar ToolSchema = z.object({\n  name: z.string(),\n  description: z.optional(z.string()),\n  inputSchema: z.object({\n    type: z.literal(\"object\"),\n    properties: z.optional(z.object({}).loose())\n  }).loose(),\n  annotations: z.optional(\n    z.object({\n      title: z.optional(z.string())\n    }).loose()\n  ),\n  _meta: ToolMetaSchema\n}).loose();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema)\n});\nvar TextContentSchema = z.object({\n  type: z.literal(\"text\"),\n  text: z.string()\n}).loose();\nvar ImageContentSchema = z.object({\n  type: z.literal(\"image\"),\n  data: z.base64(),\n  mimeType: z.string()\n}).loose();\nvar ResourceSchema = z.object({\n  uri: z.string(),\n  name: z.string(),\n  title: z.optional(z.string()),\n  description: z.optional(z.string()),\n  mimeType: z.optional(z.string()),\n  size: z.optional(z.number())\n}).loose();\nvar ListResourcesResultSchema = PaginatedResultSchema.extend({\n  resources: z.array(ResourceSchema)\n});\nvar ResourceContentsSchema = z.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: z.string(),\n  /**\n   * Optional display name of the resource content.\n   */\n  name: z.optional(z.string()),\n  /**\n   * Optional human readable title.\n   */\n  title: z.optional(z.string()),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: z.optional(z.string())\n}).loose();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: z.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: z.base64()\n});\nvar EmbeddedResourceSchema = z.object({\n  type: z.literal(\"resource\"),\n  resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).loose();\nvar CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])\n  ),\n  isError: z.boolean().default(false).optional()\n}).or(\n  ResultSchema.extend({\n    toolResult: z.unknown()\n  })\n);\nvar ResourceTemplateSchema = z.object({\n  uriTemplate: z.string(),\n  name: z.string(),\n  title: z.optional(z.string()),\n  description: z.optional(z.string()),\n  mimeType: z.optional(z.string())\n}).loose();\nvar ListResourceTemplatesResultSchema = ResultSchema.extend({\n  resourceTemplates: z.array(ResourceTemplateSchema)\n});\nvar ReadResourceResultSchema = ResultSchema.extend({\n  contents: z.array(\n    z.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n  )\n});\nvar PromptArgumentSchema = z.object({\n  name: z.string(),\n  description: z.optional(z.string()),\n  required: z.optional(z.boolean())\n}).loose();\nvar PromptSchema = z.object({\n  name: z.string(),\n  title: z.optional(z.string()),\n  description: z.optional(z.string()),\n  arguments: z.optional(z.array(PromptArgumentSchema))\n}).loose();\nvar ListPromptsResultSchema = PaginatedResultSchema.extend({\n  prompts: z.array(PromptSchema)\n});\nvar PromptMessageSchema = z.object({\n  role: z.union([z.literal(\"user\"), z.literal(\"assistant\")]),\n  content: z.union([\n    TextContentSchema,\n    ImageContentSchema,\n    EmbeddedResourceSchema\n  ])\n}).loose();\nvar GetPromptResultSchema = ResultSchema.extend({\n  description: z.optional(z.string()),\n  messages: z.array(PromptMessageSchema)\n});\nvar ElicitationRequestParamsSchema = BaseParamsSchema.extend({\n  message: z.string(),\n  requestedSchema: z.unknown()\n});\nvar ElicitationRequestSchema = RequestSchema.extend({\n  method: z.literal(\"elicitation/create\"),\n  params: ElicitationRequestParamsSchema\n});\nvar ElicitResultSchema = ResultSchema.extend({\n  action: z.union([\n    z.literal(\"accept\"),\n    z.literal(\"decline\"),\n    z.literal(\"cancel\")\n  ]),\n  content: z.optional(z.record(z.string(), z.unknown()))\n});\n\n// src/tool/json-rpc-message.ts\nvar JSONRPC_VERSION = \"2.0\";\nvar JSONRPCRequestSchema = z2.object({\n  jsonrpc: z2.literal(JSONRPC_VERSION),\n  id: z2.union([z2.string(), z2.number().int()])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = z2.object({\n  jsonrpc: z2.literal(JSONRPC_VERSION),\n  id: z2.union([z2.string(), z2.number().int()]),\n  result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = z2.object({\n  jsonrpc: z2.literal(JSONRPC_VERSION),\n  id: z2.union([z2.string(), z2.number().int()]),\n  error: z2.object({\n    code: z2.number().int(),\n    message: z2.string(),\n    data: z2.optional(z2.unknown())\n  })\n}).strict();\nvar JSONRPCNotificationSchema = z2.object({\n  jsonrpc: z2.literal(JSONRPC_VERSION)\n}).merge(\n  z2.object({\n    method: z2.string(),\n    params: z2.optional(BaseParamsSchema)\n  })\n).strict();\nvar JSONRPCMessageSchema = z2.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\n\n// src/version.ts\nvar VERSION = typeof __PACKAGE_VERSION__ !== \"undefined\" ? __PACKAGE_VERSION__ : \"0.0.0-test\";\n\n// src/tool/oauth.ts\nimport pkceChallenge from \"pkce-challenge\";\n\n// src/tool/oauth-types.ts\nimport { z as z3 } from \"zod/v4\";\nvar OAuthTokensSchema = z3.object({\n  access_token: z3.string(),\n  id_token: z3.string().optional(),\n  // Optional for OAuth 2.1, but necessary in OpenID Connect\n  token_type: z3.string(),\n  expires_in: z3.number().optional(),\n  scope: z3.string().optional(),\n  refresh_token: z3.string().optional()\n}).strip();\nvar SafeUrlSchema = z3.string().url().superRefine((val, ctx) => {\n  if (!URL.canParse(val)) {\n    ctx.addIssue({\n      code: z3.ZodIssueCode.custom,\n      message: \"URL must be parseable\",\n      fatal: true\n    });\n    return z3.NEVER;\n  }\n}).refine(\n  (url) => {\n    const u = new URL(url);\n    return u.protocol !== \"javascript:\" && u.protocol !== \"data:\" && u.protocol !== \"vbscript:\";\n  },\n  { message: \"URL cannot use javascript:, data:, or vbscript: scheme\" }\n);\nvar OAuthProtectedResourceMetadataSchema = z3.object({\n  resource: z3.string().url(),\n  authorization_servers: z3.array(SafeUrlSchema).optional(),\n  jwks_uri: z3.string().url().optional(),\n  scopes_supported: z3.array(z3.string()).optional(),\n  bearer_methods_supported: z3.array(z3.string()).optional(),\n  resource_signing_alg_values_supported: z3.array(z3.string()).optional(),\n  resource_name: z3.string().optional(),\n  resource_documentation: z3.string().optional(),\n  resource_policy_uri: z3.string().url().optional(),\n  resource_tos_uri: z3.string().url().optional(),\n  tls_client_certificate_bound_access_tokens: z3.boolean().optional(),\n  authorization_details_types_supported: z3.array(z3.string()).optional(),\n  dpop_signing_alg_values_supported: z3.array(z3.string()).optional(),\n  dpop_bound_access_tokens_required: z3.boolean().optional()\n}).passthrough();\nvar OAuthMetadataSchema = z3.object({\n  issuer: z3.string(),\n  authorization_endpoint: SafeUrlSchema,\n  token_endpoint: SafeUrlSchema,\n  registration_endpoint: SafeUrlSchema.optional(),\n  scopes_supported: z3.array(z3.string()).optional(),\n  response_types_supported: z3.array(z3.string()),\n  grant_types_supported: z3.array(z3.string()).optional(),\n  code_challenge_methods_supported: z3.array(z3.string()),\n  token_endpoint_auth_methods_supported: z3.array(z3.string()).optional(),\n  token_endpoint_auth_signing_alg_values_supported: z3.array(z3.string()).optional()\n}).passthrough();\nvar OpenIdProviderMetadataSchema = z3.object({\n  issuer: z3.string(),\n  authorization_endpoint: SafeUrlSchema,\n  token_endpoint: SafeUrlSchema,\n  userinfo_endpoint: SafeUrlSchema.optional(),\n  jwks_uri: SafeUrlSchema,\n  registration_endpoint: SafeUrlSchema.optional(),\n  scopes_supported: z3.array(z3.string()).optional(),\n  response_types_supported: z3.array(z3.string()),\n  grant_types_supported: z3.array(z3.string()).optional(),\n  subject_types_supported: z3.array(z3.string()),\n  id_token_signing_alg_values_supported: z3.array(z3.string()),\n  claims_supported: z3.array(z3.string()).optional(),\n  token_endpoint_auth_methods_supported: z3.array(z3.string()).optional()\n}).passthrough();\nvar OpenIdProviderDiscoveryMetadataSchema = OpenIdProviderMetadataSchema.merge(\n  OAuthMetadataSchema.pick({\n    code_challenge_methods_supported: true\n  })\n);\nvar OAuthClientInformationSchema = z3.object({\n  client_id: z3.string(),\n  client_secret: z3.string().optional(),\n  client_id_issued_at: z3.number().optional(),\n  client_secret_expires_at: z3.number().optional()\n}).strip();\nvar OAuthClientMetadataSchema = z3.object({\n  redirect_uris: z3.array(SafeUrlSchema),\n  token_endpoint_auth_method: z3.string().optional(),\n  grant_types: z3.array(z3.string()).optional(),\n  response_types: z3.array(z3.string()).optional(),\n  client_name: z3.string().optional(),\n  client_uri: SafeUrlSchema.optional(),\n  logo_uri: SafeUrlSchema.optional(),\n  scope: z3.string().optional(),\n  contacts: z3.array(z3.string()).optional(),\n  tos_uri: SafeUrlSchema.optional(),\n  policy_uri: z3.string().optional(),\n  jwks_uri: SafeUrlSchema.optional(),\n  jwks: z3.any().optional(),\n  software_id: z3.string().optional(),\n  software_version: z3.string().optional(),\n  software_statement: z3.string().optional()\n}).strip();\nvar OAuthErrorResponseSchema = z3.object({\n  error: z3.string(),\n  error_description: z3.string().optional(),\n  error_uri: z3.string().optional()\n});\nvar OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(\n  OAuthClientInformationSchema\n);\n\n// src/error/oauth-error.ts\nimport { AISDKError as AISDKError2 } from \"@ai-sdk/provider\";\nvar name2 = \"AI_MCPClientOAuthError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2, _b2;\nvar MCPClientOAuthError = class extends (_b2 = AISDKError2, _a2 = symbol2, _b2) {\n  constructor({\n    name: name3 = \"MCPClientOAuthError\",\n    message,\n    cause\n  }) {\n    super({ name: name3, message, cause });\n    this[_a2] = true;\n  }\n  static isInstance(error) {\n    return AISDKError2.hasMarker(error, marker2);\n  }\n};\nvar ServerError = class extends MCPClientOAuthError {\n};\nServerError.errorCode = \"server_error\";\nvar InvalidClientError = class extends MCPClientOAuthError {\n};\nInvalidClientError.errorCode = \"invalid_client\";\nvar InvalidGrantError = class extends MCPClientOAuthError {\n};\nInvalidGrantError.errorCode = \"invalid_grant\";\nvar UnauthorizedClientError = class extends MCPClientOAuthError {\n};\nUnauthorizedClientError.errorCode = \"unauthorized_client\";\nvar OAUTH_ERRORS = {\n  [ServerError.errorCode]: ServerError,\n  [InvalidClientError.errorCode]: InvalidClientError,\n  [InvalidGrantError.errorCode]: InvalidGrantError,\n  [UnauthorizedClientError.errorCode]: UnauthorizedClientError\n};\n\n// src/util/oauth-util.ts\nfunction resourceUrlFromServerUrl(url) {\n  const resourceURL = typeof url === \"string\" ? new URL(url) : new URL(url.href);\n  resourceURL.hash = \"\";\n  return resourceURL;\n}\nfunction checkResourceAllowed({\n  requestedResource,\n  configuredResource\n}) {\n  const requested = typeof requestedResource === \"string\" ? new URL(requestedResource) : new URL(requestedResource.href);\n  const configured = typeof configuredResource === \"string\" ? new URL(configuredResource) : new URL(configuredResource.href);\n  if (requested.origin !== configured.origin) {\n    return false;\n  }\n  if (requested.pathname.length < configured.pathname.length) {\n    return false;\n  }\n  const requestedPath = requested.pathname.endsWith(\"/\") ? requested.pathname : requested.pathname + \"/\";\n  const configuredPath = configured.pathname.endsWith(\"/\") ? configured.pathname : configured.pathname + \"/\";\n  return requestedPath.startsWith(configuredPath);\n}\n\n// src/tool/oauth.ts\nvar UnauthorizedError = class extends Error {\n  constructor(message = \"Unauthorized\") {\n    super(message);\n    this.name = \"UnauthorizedError\";\n  }\n};\nfunction extractResourceMetadataUrl(response) {\n  var _a3;\n  const header = (_a3 = response.headers.get(\"www-authenticate\")) != null ? _a3 : response.headers.get(\"WWW-Authenticate\");\n  if (!header) {\n    return void 0;\n  }\n  const [type, scheme] = header.split(\" \");\n  if (type.toLowerCase() !== \"bearer\" || !scheme) {\n    return void 0;\n  }\n  const regex = /resource_metadata=\"([^\"]*)\"/;\n  const match = header.match(regex);\n  if (!match) {\n    return void 0;\n  }\n  try {\n    return new URL(match[1]);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction buildWellKnownPath(wellKnownPrefix, pathname = \"\", options = {}) {\n  if (pathname.endsWith(\"/\")) {\n    pathname = pathname.slice(0, -1);\n  }\n  return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;\n}\nasync function fetchWithCorsRetry(url, headers, fetchFn = fetch) {\n  try {\n    return await fetchFn(url, { headers });\n  } catch (error) {\n    if (error instanceof TypeError) {\n      if (headers) {\n        return fetchWithCorsRetry(url, void 0, fetchFn);\n      } else {\n        return void 0;\n      }\n    }\n    throw error;\n  }\n}\nasync function tryMetadataDiscovery(url, protocolVersion, fetchFn = fetch) {\n  const headers = {\n    \"MCP-Protocol-Version\": protocolVersion\n  };\n  return await fetchWithCorsRetry(url, headers, fetchFn);\n}\nfunction shouldAttemptFallback(response, pathname) {\n  return !response || response.status >= 400 && response.status < 500 && pathname !== \"/\";\n}\nasync function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {\n  var _a3, _b3;\n  const issuer = new URL(serverUrl);\n  const protocolVersion = (_a3 = opts == null ? void 0 : opts.protocolVersion) != null ? _a3 : LATEST_PROTOCOL_VERSION;\n  let url;\n  if (opts == null ? void 0 : opts.metadataUrl) {\n    url = new URL(opts.metadataUrl);\n  } else {\n    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);\n    url = new URL(wellKnownPath, (_b3 = opts == null ? void 0 : opts.metadataServerUrl) != null ? _b3 : issuer);\n    url.search = issuer.search;\n  }\n  let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);\n  if (!(opts == null ? void 0 : opts.metadataUrl) && shouldAttemptFallback(response, issuer.pathname)) {\n    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);\n    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);\n  }\n  return response;\n}\nasync function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {\n  const response = await discoverMetadataWithFallback(\n    serverUrl,\n    \"oauth-protected-resource\",\n    fetchFn,\n    {\n      protocolVersion: opts == null ? void 0 : opts.protocolVersion,\n      metadataUrl: opts == null ? void 0 : opts.resourceMetadataUrl\n    }\n  );\n  if (!response || response.status === 404) {\n    throw new Error(\n      `Resource server does not implement OAuth 2.0 Protected Resource Metadata.`\n    );\n  }\n  if (!response.ok) {\n    throw new Error(\n      `HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`\n    );\n  }\n  return OAuthProtectedResourceMetadataSchema.parse(await response.json());\n}\nfunction buildDiscoveryUrls(authorizationServerUrl) {\n  const url = typeof authorizationServerUrl === \"string\" ? new URL(authorizationServerUrl) : authorizationServerUrl;\n  const hasPath = url.pathname !== \"/\";\n  const urlsToTry = [];\n  if (!hasPath) {\n    urlsToTry.push({\n      url: new URL(\"/.well-known/oauth-authorization-server\", url.origin),\n      type: \"oauth\"\n    });\n    urlsToTry.push({\n      url: new URL(\"/.well-known/openid-configuration\", url.origin),\n      type: \"oidc\"\n    });\n    return urlsToTry;\n  }\n  let pathname = url.pathname;\n  if (pathname.endsWith(\"/\")) {\n    pathname = pathname.slice(0, -1);\n  }\n  urlsToTry.push({\n    url: new URL(\n      `/.well-known/oauth-authorization-server${pathname}`,\n      url.origin\n    ),\n    type: \"oauth\"\n  });\n  urlsToTry.push({\n    url: new URL(\"/.well-known/oauth-authorization-server\", url.origin),\n    type: \"oauth\"\n  });\n  urlsToTry.push({\n    url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),\n    type: \"oidc\"\n  });\n  urlsToTry.push({\n    url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),\n    type: \"oidc\"\n  });\n  return urlsToTry;\n}\nasync function discoverAuthorizationServerMetadata(authorizationServerUrl, {\n  fetchFn = fetch,\n  protocolVersion = LATEST_PROTOCOL_VERSION\n} = {}) {\n  var _a3;\n  const headers = { \"MCP-Protocol-Version\": protocolVersion };\n  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);\n  for (const { url: endpointUrl, type } of urlsToTry) {\n    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);\n    if (!response) {\n      continue;\n    }\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 500) {\n        continue;\n      }\n      throw new Error(\n        `HTTP ${response.status} trying to load ${type === \"oauth\" ? \"OAuth\" : \"OpenID provider\"} metadata from ${endpointUrl}`\n      );\n    }\n    if (type === \"oauth\") {\n      return OAuthMetadataSchema.parse(await response.json());\n    } else {\n      const metadata = OpenIdProviderDiscoveryMetadataSchema.parse(\n        await response.json()\n      );\n      if (!((_a3 = metadata.code_challenge_methods_supported) == null ? void 0 : _a3.includes(\"S256\"))) {\n        throw new Error(\n          `Incompatible OIDC provider at ${endpointUrl}: does not support S256 code challenge method required by MCP specification`\n        );\n      }\n      return metadata;\n    }\n  }\n  return void 0;\n}\nasync function startAuthorization(authorizationServerUrl, {\n  metadata,\n  clientInformation,\n  redirectUrl,\n  scope,\n  state,\n  resource\n}) {\n  const responseType = \"code\";\n  const codeChallengeMethod = \"S256\";\n  let authorizationUrl;\n  if (metadata) {\n    authorizationUrl = new URL(metadata.authorization_endpoint);\n    if (!metadata.response_types_supported.includes(responseType)) {\n      throw new Error(\n        `Incompatible auth server: does not support response type ${responseType}`\n      );\n    }\n    if (!metadata.code_challenge_methods_supported || !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)) {\n      throw new Error(\n        `Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`\n      );\n    }\n  } else {\n    authorizationUrl = new URL(\"/authorize\", authorizationServerUrl);\n  }\n  const challenge = await pkceChallenge();\n  const codeVerifier = challenge.code_verifier;\n  const codeChallenge = challenge.code_challenge;\n  authorizationUrl.searchParams.set(\"response_type\", responseType);\n  authorizationUrl.searchParams.set(\"client_id\", clientInformation.client_id);\n  authorizationUrl.searchParams.set(\"code_challenge\", codeChallenge);\n  authorizationUrl.searchParams.set(\n    \"code_challenge_method\",\n    codeChallengeMethod\n  );\n  authorizationUrl.searchParams.set(\"redirect_uri\", String(redirectUrl));\n  if (state) {\n    authorizationUrl.searchParams.set(\"state\", state);\n  }\n  if (scope) {\n    authorizationUrl.searchParams.set(\"scope\", scope);\n  }\n  if (scope == null ? void 0 : scope.includes(\"offline_access\")) {\n    authorizationUrl.searchParams.append(\"prompt\", \"consent\");\n  }\n  if (resource) {\n    authorizationUrl.searchParams.set(\"resource\", resource.href);\n  }\n  return { authorizationUrl, codeVerifier };\n}\nfunction selectClientAuthMethod(clientInformation, supportedMethods) {\n  const hasClientSecret = clientInformation.client_secret !== void 0;\n  if (supportedMethods.length === 0) {\n    return hasClientSecret ? \"client_secret_post\" : \"none\";\n  }\n  if (hasClientSecret && supportedMethods.includes(\"client_secret_basic\")) {\n    return \"client_secret_basic\";\n  }\n  if (hasClientSecret && supportedMethods.includes(\"client_secret_post\")) {\n    return \"client_secret_post\";\n  }\n  if (supportedMethods.includes(\"none\")) {\n    return \"none\";\n  }\n  return hasClientSecret ? \"client_secret_post\" : \"none\";\n}\nfunction applyClientAuthentication(method, clientInformation, headers, params) {\n  const { client_id, client_secret } = clientInformation;\n  switch (method) {\n    case \"client_secret_basic\":\n      applyBasicAuth(client_id, client_secret, headers);\n      return;\n    case \"client_secret_post\":\n      applyPostAuth(client_id, client_secret, params);\n      return;\n    case \"none\":\n      applyPublicAuth(client_id, params);\n      return;\n    default:\n      throw new Error(`Unsupported client authentication method: ${method}`);\n  }\n}\nfunction applyBasicAuth(clientId, clientSecret, headers) {\n  if (!clientSecret) {\n    throw new Error(\n      \"client_secret_basic authentication requires a client_secret\"\n    );\n  }\n  const credentials = btoa(`${clientId}:${clientSecret}`);\n  headers.set(\"Authorization\", `Basic ${credentials}`);\n}\nfunction applyPostAuth(clientId, clientSecret, params) {\n  params.set(\"client_id\", clientId);\n  if (clientSecret) {\n    params.set(\"client_secret\", clientSecret);\n  }\n}\nfunction applyPublicAuth(clientId, params) {\n  params.set(\"client_id\", clientId);\n}\nasync function parseErrorResponse(input) {\n  const statusCode = input instanceof Response ? input.status : void 0;\n  const body = input instanceof Response ? await input.text() : input;\n  try {\n    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));\n    const { error, error_description, error_uri } = result;\n    const errorClass = OAUTH_ERRORS[error] || ServerError;\n    return new errorClass({\n      message: error_description || \"\",\n      cause: error_uri\n    });\n  } catch (error) {\n    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : \"\"}Invalid OAuth error response: ${error}. Raw body: ${body}`;\n    return new ServerError({ message: errorMessage });\n  }\n}\nasync function exchangeAuthorization(authorizationServerUrl, {\n  metadata,\n  clientInformation,\n  authorizationCode,\n  codeVerifier,\n  redirectUri,\n  resource,\n  addClientAuthentication,\n  fetchFn\n}) {\n  var _a3;\n  const grantType = \"authorization_code\";\n  const tokenUrl = (metadata == null ? void 0 : metadata.token_endpoint) ? new URL(metadata.token_endpoint) : new URL(\"/token\", authorizationServerUrl);\n  if ((metadata == null ? void 0 : metadata.grant_types_supported) && !metadata.grant_types_supported.includes(grantType)) {\n    throw new Error(\n      `Incompatible auth server: does not support grant type ${grantType}`\n    );\n  }\n  const headers = new Headers({\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    Accept: \"application/json\"\n  });\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    code: authorizationCode,\n    code_verifier: codeVerifier,\n    redirect_uri: String(redirectUri)\n  });\n  if (addClientAuthentication) {\n    addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n  } else {\n    const supportedMethods = (_a3 = metadata == null ? void 0 : metadata.token_endpoint_auth_methods_supported) != null ? _a3 : [];\n    const authMethod = selectClientAuthMethod(\n      clientInformation,\n      supportedMethods\n    );\n    applyClientAuthentication(authMethod, clientInformation, headers, params);\n  }\n  if (resource) {\n    params.set(\"resource\", resource.href);\n  }\n  const response = await (fetchFn != null ? fetchFn : fetch)(tokenUrl, {\n    method: \"POST\",\n    headers,\n    body: params\n  });\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n  return OAuthTokensSchema.parse(await response.json());\n}\nasync function refreshAuthorization(authorizationServerUrl, {\n  metadata,\n  clientInformation,\n  refreshToken,\n  resource,\n  addClientAuthentication,\n  fetchFn\n}) {\n  var _a3;\n  const grantType = \"refresh_token\";\n  let tokenUrl;\n  if (metadata) {\n    tokenUrl = new URL(metadata.token_endpoint);\n    if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {\n      throw new Error(\n        `Incompatible auth server: does not support grant type ${grantType}`\n      );\n    }\n  } else {\n    tokenUrl = new URL(\"/token\", authorizationServerUrl);\n  }\n  const headers = new Headers({\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    Accept: \"application/json\"\n  });\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    refresh_token: refreshToken\n  });\n  if (addClientAuthentication) {\n    addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n  } else {\n    const supportedMethods = (_a3 = metadata == null ? void 0 : metadata.token_endpoint_auth_methods_supported) != null ? _a3 : [];\n    const authMethod = selectClientAuthMethod(\n      clientInformation,\n      supportedMethods\n    );\n    applyClientAuthentication(authMethod, clientInformation, headers, params);\n  }\n  if (resource) {\n    params.set(\"resource\", resource.href);\n  }\n  const response = await (fetchFn != null ? fetchFn : fetch)(tokenUrl, {\n    method: \"POST\",\n    headers,\n    body: params\n  });\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n  return OAuthTokensSchema.parse({\n    refresh_token: refreshToken,\n    ...await response.json()\n  });\n}\nasync function registerClient(authorizationServerUrl, {\n  metadata,\n  clientMetadata,\n  fetchFn\n}) {\n  let registrationUrl;\n  if (metadata) {\n    if (!metadata.registration_endpoint) {\n      throw new Error(\n        \"Incompatible auth server: does not support dynamic client registration\"\n      );\n    }\n    registrationUrl = new URL(metadata.registration_endpoint);\n  } else {\n    registrationUrl = new URL(\"/register\", authorizationServerUrl);\n  }\n  const response = await (fetchFn != null ? fetchFn : fetch)(registrationUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(clientMetadata)\n  });\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n  return OAuthClientInformationFullSchema.parse(await response.json());\n}\nasync function auth(provider, options) {\n  var _a3, _b3;\n  try {\n    return await authInternal(provider, options);\n  } catch (error) {\n    if (error instanceof InvalidClientError || error instanceof UnauthorizedClientError) {\n      await ((_a3 = provider.invalidateCredentials) == null ? void 0 : _a3.call(provider, \"all\"));\n      return await authInternal(provider, options);\n    } else if (error instanceof InvalidGrantError) {\n      await ((_b3 = provider.invalidateCredentials) == null ? void 0 : _b3.call(provider, \"tokens\"));\n      return await authInternal(provider, options);\n    }\n    throw error;\n  }\n}\nasync function selectResourceURL(serverUrl, provider, resourceMetadata) {\n  const defaultResource = resourceUrlFromServerUrl(serverUrl);\n  if (provider.validateResourceURL) {\n    return await provider.validateResourceURL(\n      defaultResource,\n      resourceMetadata == null ? void 0 : resourceMetadata.resource\n    );\n  }\n  if (!resourceMetadata) {\n    return void 0;\n  }\n  if (!checkResourceAllowed({\n    requestedResource: defaultResource,\n    configuredResource: resourceMetadata.resource\n  })) {\n    throw new Error(\n      `Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`\n    );\n  }\n  return new URL(resourceMetadata.resource);\n}\nasync function authInternal(provider, {\n  serverUrl,\n  authorizationCode,\n  scope,\n  resourceMetadataUrl,\n  fetchFn\n}) {\n  let resourceMetadata;\n  let authorizationServerUrl;\n  try {\n    resourceMetadata = await discoverOAuthProtectedResourceMetadata(\n      serverUrl,\n      { resourceMetadataUrl },\n      fetchFn\n    );\n    if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {\n      authorizationServerUrl = resourceMetadata.authorization_servers[0];\n    }\n  } catch (e) {\n  }\n  if (!authorizationServerUrl) {\n    authorizationServerUrl = serverUrl;\n  }\n  const resource = await selectResourceURL(\n    serverUrl,\n    provider,\n    resourceMetadata\n  );\n  const metadata = await discoverAuthorizationServerMetadata(\n    authorizationServerUrl,\n    {\n      fetchFn\n    }\n  );\n  let clientInformation = await Promise.resolve(provider.clientInformation());\n  if (!clientInformation) {\n    if (authorizationCode !== void 0) {\n      throw new Error(\n        \"Existing OAuth client information is required when exchanging an authorization code\"\n      );\n    }\n    if (!provider.saveClientInformation) {\n      throw new Error(\n        \"OAuth client information must be saveable for dynamic registration\"\n      );\n    }\n    const fullInformation = await registerClient(authorizationServerUrl, {\n      metadata,\n      clientMetadata: provider.clientMetadata,\n      fetchFn\n    });\n    await provider.saveClientInformation(fullInformation);\n    clientInformation = fullInformation;\n  }\n  if (authorizationCode !== void 0) {\n    const codeVerifier2 = await provider.codeVerifier();\n    const tokens2 = await exchangeAuthorization(authorizationServerUrl, {\n      metadata,\n      clientInformation,\n      authorizationCode,\n      codeVerifier: codeVerifier2,\n      redirectUri: provider.redirectUrl,\n      resource,\n      addClientAuthentication: provider.addClientAuthentication,\n      fetchFn\n    });\n    await provider.saveTokens(tokens2);\n    return \"AUTHORIZED\";\n  }\n  const tokens = await provider.tokens();\n  if (tokens == null ? void 0 : tokens.refresh_token) {\n    try {\n      const newTokens = await refreshAuthorization(authorizationServerUrl, {\n        metadata,\n        clientInformation,\n        refreshToken: tokens.refresh_token,\n        resource,\n        addClientAuthentication: provider.addClientAuthentication,\n        fetchFn\n      });\n      await provider.saveTokens(newTokens);\n      return \"AUTHORIZED\";\n    } catch (error) {\n      if (\n        // If this is a ServerError, or an unknown type, log it out and try to continue. Otherwise, escalate so we can fix things and retry.\n        !(error instanceof MCPClientOAuthError) || error instanceof ServerError\n      ) {\n      } else {\n        throw error;\n      }\n    }\n  }\n  const state = provider.state ? await provider.state() : void 0;\n  const { authorizationUrl, codeVerifier } = await startAuthorization(\n    authorizationServerUrl,\n    {\n      metadata,\n      clientInformation,\n      state,\n      redirectUrl: provider.redirectUrl,\n      scope: scope || provider.clientMetadata.scope,\n      resource\n    }\n  );\n  await provider.saveCodeVerifier(codeVerifier);\n  await provider.redirectToAuthorization(authorizationUrl);\n  return \"REDIRECT\";\n}\n\n// src/tool/mcp-sse-transport.ts\nvar SseMCPTransport = class {\n  constructor({\n    url,\n    headers,\n    authProvider\n  }) {\n    this.connected = false;\n    this.url = new URL(url);\n    this.headers = headers;\n    this.authProvider = authProvider;\n  }\n  async commonHeaders(base) {\n    const headers = {\n      ...this.headers,\n      ...base,\n      \"mcp-protocol-version\": LATEST_PROTOCOL_VERSION\n    };\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens == null ? void 0 : tokens.access_token) {\n        headers[\"Authorization\"] = `Bearer ${tokens.access_token}`;\n      }\n    }\n    return withUserAgentSuffix(\n      headers,\n      `ai-sdk/${VERSION}`,\n      getRuntimeEnvironmentUserAgent()\n    );\n  }\n  async start() {\n    return new Promise((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n      this.abortController = new AbortController();\n      const establishConnection = async (triedAuth = false) => {\n        var _a3, _b3, _c, _d, _e;\n        try {\n          const headers = await this.commonHeaders({\n            Accept: \"text/event-stream\"\n          });\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: (_a3 = this.abortController) == null ? void 0 : _a3.signal\n          });\n          if (response.status === 401 && this.authProvider && !triedAuth) {\n            this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n            try {\n              const result = await auth(this.authProvider, {\n                serverUrl: this.url,\n                resourceMetadataUrl: this.resourceMetadataUrl\n              });\n              if (result !== \"AUTHORIZED\") {\n                const error = new UnauthorizedError();\n                (_b3 = this.onerror) == null ? void 0 : _b3.call(this, error);\n                return reject(error);\n              }\n            } catch (error) {\n              (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n              return reject(error);\n            }\n            return establishConnection(true);\n          }\n          if (!response.ok || !response.body) {\n            let errorMessage = `MCP SSE Transport Error: ${response.status} ${response.statusText}`;\n            if (response.status === 405) {\n              errorMessage += \". This server does not support SSE transport. Try using `http` transport instead\";\n            }\n            const error = new MCPClientError({\n              message: errorMessage\n            });\n            (_d = this.onerror) == null ? void 0 : _d.call(this, error);\n            return reject(error);\n          }\n          const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream());\n          const reader = stream.getReader();\n          const processEvents = async () => {\n            var _a4, _b4, _c2;\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message: \"MCP SSE Transport Error: Connection closed unexpectedly\"\n                    });\n                  }\n                  return;\n                }\n                const { event, data } = value;\n                if (event === \"endpoint\") {\n                  this.endpoint = new URL(data, this.url);\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`\n                    });\n                  }\n                  this.connected = true;\n                  resolve();\n                } else if (event === \"message\") {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data)\n                    );\n                    (_a4 = this.onmessage) == null ? void 0 : _a4.call(this, message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message: \"MCP SSE Transport Error: Failed to parse message\",\n                      cause: error\n                    });\n                    (_b4 = this.onerror) == null ? void 0 : _b4.call(this, e);\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === \"AbortError\") {\n                return;\n              }\n              (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);\n              reject(error);\n            }\n          };\n          this.sseConnection = {\n            close: () => reader.cancel()\n          };\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === \"AbortError\") {\n            return;\n          }\n          (_e = this.onerror) == null ? void 0 : _e.call(this, error);\n          reject(error);\n        }\n      };\n      void establishConnection();\n    });\n  }\n  async close() {\n    var _a3, _b3, _c;\n    this.connected = false;\n    (_a3 = this.sseConnection) == null ? void 0 : _a3.close();\n    (_b3 = this.abortController) == null ? void 0 : _b3.abort();\n    (_c = this.onclose) == null ? void 0 : _c.call(this);\n  }\n  async send(message) {\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: \"MCP SSE Transport Error: Not connected\"\n      });\n    }\n    const endpoint = this.endpoint;\n    const attempt = async (triedAuth = false) => {\n      var _a3, _b3, _c, _d, _e;\n      try {\n        const headers = await this.commonHeaders({\n          \"Content-Type\": \"application/json\"\n        });\n        const init = {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(message),\n          signal: (_a3 = this.abortController) == null ? void 0 : _a3.signal\n        };\n        const response = await fetch(endpoint, init);\n        if (response.status === 401 && this.authProvider && !triedAuth) {\n          this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n          try {\n            const result = await auth(this.authProvider, {\n              serverUrl: this.url,\n              resourceMetadataUrl: this.resourceMetadataUrl\n            });\n            if (result !== \"AUTHORIZED\") {\n              const error = new UnauthorizedError();\n              (_b3 = this.onerror) == null ? void 0 : _b3.call(this, error);\n              return;\n            }\n          } catch (error) {\n            (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n            return;\n          }\n          return attempt(true);\n        }\n        if (!response.ok) {\n          const text = await response.text().catch(() => null);\n          const error = new MCPClientError({\n            message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`\n          });\n          (_d = this.onerror) == null ? void 0 : _d.call(this, error);\n          return;\n        }\n      } catch (error) {\n        (_e = this.onerror) == null ? void 0 : _e.call(this, error);\n        return;\n      }\n    };\n    await attempt();\n  }\n};\n\n// src/tool/mcp-http-transport.ts\nimport {\n  EventSourceParserStream as EventSourceParserStream2,\n  withUserAgentSuffix as withUserAgentSuffix2,\n  getRuntimeEnvironmentUserAgent as getRuntimeEnvironmentUserAgent2\n} from \"@ai-sdk/provider-utils\";\nvar HttpMCPTransport = class {\n  constructor({\n    url,\n    headers,\n    authProvider\n  }) {\n    this.inboundReconnectAttempts = 0;\n    this.reconnectionOptions = {\n      initialReconnectionDelay: 1e3,\n      maxReconnectionDelay: 3e4,\n      reconnectionDelayGrowFactor: 1.5,\n      maxRetries: 2\n    };\n    this.url = new URL(url);\n    this.headers = headers;\n    this.authProvider = authProvider;\n  }\n  async commonHeaders(base) {\n    const headers = {\n      ...this.headers,\n      ...base,\n      \"mcp-protocol-version\": LATEST_PROTOCOL_VERSION\n    };\n    if (this.sessionId) {\n      headers[\"mcp-session-id\"] = this.sessionId;\n    }\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens == null ? void 0 : tokens.access_token) {\n        headers[\"Authorization\"] = `Bearer ${tokens.access_token}`;\n      }\n    }\n    return withUserAgentSuffix2(\n      headers,\n      `ai-sdk/${VERSION}`,\n      getRuntimeEnvironmentUserAgent2()\n    );\n  }\n  async start() {\n    if (this.abortController) {\n      throw new MCPClientError({\n        message: \"MCP HTTP Transport Error: Transport already started. Note: client.connect() calls start() automatically.\"\n      });\n    }\n    this.abortController = new AbortController();\n    void this.openInboundSse();\n  }\n  async close() {\n    var _a3, _b3, _c;\n    (_a3 = this.inboundSseConnection) == null ? void 0 : _a3.close();\n    try {\n      if (this.sessionId && this.abortController && !this.abortController.signal.aborted) {\n        const headers = await this.commonHeaders({});\n        await fetch(this.url, {\n          method: \"DELETE\",\n          headers,\n          signal: this.abortController.signal\n        }).catch(() => void 0);\n      }\n    } catch (e) {\n    }\n    (_b3 = this.abortController) == null ? void 0 : _b3.abort();\n    (_c = this.onclose) == null ? void 0 : _c.call(this);\n  }\n  async send(message) {\n    const attempt = async (triedAuth = false) => {\n      var _a3, _b3, _c, _d, _e, _f, _g;\n      try {\n        const headers = await this.commonHeaders({\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\"\n        });\n        const init = {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(message),\n          signal: (_a3 = this.abortController) == null ? void 0 : _a3.signal\n        };\n        const response = await fetch(this.url, init);\n        const sessionId = response.headers.get(\"mcp-session-id\");\n        if (sessionId) {\n          this.sessionId = sessionId;\n        }\n        if (response.status === 401 && this.authProvider && !triedAuth) {\n          this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n          try {\n            const result = await auth(this.authProvider, {\n              serverUrl: this.url,\n              resourceMetadataUrl: this.resourceMetadataUrl\n            });\n            if (result !== \"AUTHORIZED\") {\n              const error2 = new UnauthorizedError();\n              throw error2;\n            }\n          } catch (error2) {\n            (_b3 = this.onerror) == null ? void 0 : _b3.call(this, error2);\n            throw error2;\n          }\n          return attempt(true);\n        }\n        if (response.status === 202) {\n          if (!this.inboundSseConnection) {\n            void this.openInboundSse();\n          }\n          return;\n        }\n        if (!response.ok) {\n          const text = await response.text().catch(() => null);\n          let errorMessage = `MCP HTTP Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`;\n          if (response.status === 404) {\n            errorMessage += \". This server does not support HTTP transport. Try using `sse` transport instead\";\n          }\n          const error2 = new MCPClientError({\n            message: errorMessage\n          });\n          (_c = this.onerror) == null ? void 0 : _c.call(this, error2);\n          throw error2;\n        }\n        const contentType = response.headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          const data = await response.json();\n          const messages = Array.isArray(data) ? data.map((m) => JSONRPCMessageSchema.parse(m)) : [JSONRPCMessageSchema.parse(data)];\n          for (const m of messages) (_d = this.onmessage) == null ? void 0 : _d.call(this, m);\n          return;\n        }\n        if (contentType.includes(\"text/event-stream\")) {\n          if (!response.body) {\n            const error2 = new MCPClientError({\n              message: \"MCP HTTP Transport Error: text/event-stream response without body\"\n            });\n            (_e = this.onerror) == null ? void 0 : _e.call(this, error2);\n            throw error2;\n          }\n          const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream2());\n          const reader = stream.getReader();\n          const processEvents = async () => {\n            var _a4, _b4, _c2;\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) return;\n                const { event, data } = value;\n                if (event === \"message\") {\n                  try {\n                    const msg = JSONRPCMessageSchema.parse(JSON.parse(data));\n                    (_a4 = this.onmessage) == null ? void 0 : _a4.call(this, msg);\n                  } catch (error2) {\n                    const e = new MCPClientError({\n                      message: \"MCP HTTP Transport Error: Failed to parse message\",\n                      cause: error2\n                    });\n                    (_b4 = this.onerror) == null ? void 0 : _b4.call(this, e);\n                  }\n                }\n              }\n            } catch (error2) {\n              if (error2 instanceof Error && error2.name === \"AbortError\") {\n                return;\n              }\n              (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error2);\n            }\n          };\n          processEvents();\n          return;\n        }\n        const error = new MCPClientError({\n          message: `MCP HTTP Transport Error: Unexpected content type: ${contentType}`\n        });\n        (_f = this.onerror) == null ? void 0 : _f.call(this, error);\n        throw error;\n      } catch (error) {\n        (_g = this.onerror) == null ? void 0 : _g.call(this, error);\n        throw error;\n      }\n    };\n    await attempt();\n  }\n  getNextReconnectionDelay(attempt) {\n    const {\n      initialReconnectionDelay,\n      reconnectionDelayGrowFactor,\n      maxReconnectionDelay\n    } = this.reconnectionOptions;\n    return Math.min(\n      initialReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, attempt),\n      maxReconnectionDelay\n    );\n  }\n  scheduleInboundSseReconnection() {\n    var _a3;\n    const { maxRetries } = this.reconnectionOptions;\n    if (maxRetries > 0 && this.inboundReconnectAttempts >= maxRetries) {\n      (_a3 = this.onerror) == null ? void 0 : _a3.call(\n        this,\n        new MCPClientError({\n          message: `MCP HTTP Transport Error: Maximum reconnection attempts (${maxRetries}) exceeded.`\n        })\n      );\n      return;\n    }\n    const delay = this.getNextReconnectionDelay(this.inboundReconnectAttempts);\n    this.inboundReconnectAttempts += 1;\n    setTimeout(async () => {\n      var _a4;\n      if ((_a4 = this.abortController) == null ? void 0 : _a4.signal.aborted) return;\n      await this.openInboundSse(false, this.lastInboundEventId);\n    }, delay);\n  }\n  // Open optional inbound SSE stream; best-effort and resumable\n  async openInboundSse(triedAuth = false, resumeToken) {\n    var _a3, _b3, _c, _d, _e, _f;\n    try {\n      const headers = await this.commonHeaders({\n        Accept: \"text/event-stream\"\n      });\n      if (resumeToken) {\n        headers[\"last-event-id\"] = resumeToken;\n      }\n      const response = await fetch(this.url.href, {\n        method: \"GET\",\n        headers,\n        signal: (_a3 = this.abortController) == null ? void 0 : _a3.signal\n      });\n      const sessionId = response.headers.get(\"mcp-session-id\");\n      if (sessionId) {\n        this.sessionId = sessionId;\n      }\n      if (response.status === 401 && this.authProvider && !triedAuth) {\n        this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n        try {\n          const result = await auth(this.authProvider, {\n            serverUrl: this.url,\n            resourceMetadataUrl: this.resourceMetadataUrl\n          });\n          if (result !== \"AUTHORIZED\") {\n            const error = new UnauthorizedError();\n            (_b3 = this.onerror) == null ? void 0 : _b3.call(this, error);\n            return;\n          }\n        } catch (error) {\n          (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n          return;\n        }\n        return this.openInboundSse(true, resumeToken);\n      }\n      if (response.status === 405) {\n        return;\n      }\n      if (!response.ok || !response.body) {\n        const error = new MCPClientError({\n          message: `MCP HTTP Transport Error: GET SSE failed: ${response.status} ${response.statusText}`\n        });\n        (_d = this.onerror) == null ? void 0 : _d.call(this, error);\n        return;\n      }\n      const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream2());\n      const reader = stream.getReader();\n      const processEvents = async () => {\n        var _a4, _b4, _c2, _d2;\n        try {\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) return;\n            const { event, data, id } = value;\n            if (id) {\n              this.lastInboundEventId = id;\n            }\n            if (event === \"message\") {\n              try {\n                const msg = JSONRPCMessageSchema.parse(JSON.parse(data));\n                (_a4 = this.onmessage) == null ? void 0 : _a4.call(this, msg);\n              } catch (error) {\n                const e = new MCPClientError({\n                  message: \"MCP HTTP Transport Error: Failed to parse message\",\n                  cause: error\n                });\n                (_b4 = this.onerror) == null ? void 0 : _b4.call(this, e);\n              }\n            }\n          }\n        } catch (error) {\n          if (error instanceof Error && error.name === \"AbortError\") {\n            return;\n          }\n          (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);\n          if (!((_d2 = this.abortController) == null ? void 0 : _d2.signal.aborted)) {\n            this.scheduleInboundSseReconnection();\n          }\n        }\n      };\n      this.inboundSseConnection = {\n        close: () => reader.cancel()\n      };\n      this.inboundReconnectAttempts = 0;\n      processEvents();\n    } catch (error) {\n      if (error instanceof Error && error.name === \"AbortError\") {\n        return;\n      }\n      (_e = this.onerror) == null ? void 0 : _e.call(this, error);\n      if (!((_f = this.abortController) == null ? void 0 : _f.signal.aborted)) {\n        this.scheduleInboundSseReconnection();\n      }\n    }\n  }\n};\n\n// src/tool/mcp-transport.ts\nfunction createMcpTransport(config) {\n  switch (config.type) {\n    case \"sse\":\n      return new SseMCPTransport(config);\n    case \"http\":\n      return new HttpMCPTransport(config);\n    default:\n      throw new MCPClientError({\n        message: \"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.\"\n      });\n  }\n}\nfunction isCustomMcpTransport(transport) {\n  return \"start\" in transport && typeof transport.start === \"function\" && \"send\" in transport && typeof transport.send === \"function\" && \"close\" in transport && typeof transport.close === \"function\";\n}\n\n// src/tool/mcp-client.ts\nvar CLIENT_VERSION = \"1.0.0\";\nasync function createMCPClient(config) {\n  const client = new DefaultMCPClient(config);\n  await client.init();\n  return client;\n}\nvar DefaultMCPClient = class {\n  constructor({\n    transport: transportConfig,\n    name: name3 = \"ai-sdk-mcp-client\",\n    version = CLIENT_VERSION,\n    onUncaughtError,\n    capabilities\n  }) {\n    this.requestMessageId = 0;\n    this.responseHandlers = /* @__PURE__ */ new Map();\n    this.serverCapabilities = {};\n    this.isClosed = true;\n    this.onUncaughtError = onUncaughtError;\n    this.clientCapabilities = capabilities != null ? capabilities : {};\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error) => this.onError(error);\n    this.transport.onmessage = (message) => {\n      if (\"method\" in message) {\n        if (\"id\" in message) {\n          this.onRequestMessage(message);\n        } else {\n          this.onError(\n            new MCPClientError({\n              message: \"Unsupported message type\"\n            })\n          );\n        }\n        return;\n      }\n      this.onResponse(message);\n    };\n    this.clientInfo = {\n      name: name3,\n      version\n    };\n  }\n  async init() {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n      const result = await this.request({\n        request: {\n          method: \"initialize\",\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: this.clientCapabilities,\n            clientInfo: this.clientInfo\n          }\n        },\n        resultSchema: InitializeResultSchema\n      });\n      if (result === void 0) {\n        throw new MCPClientError({\n          message: \"Server sent invalid initialize result\"\n        });\n      }\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`\n        });\n      }\n      this.serverCapabilities = result.capabilities;\n      await this.notification({\n        method: \"notifications/initialized\"\n      });\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n  async close() {\n    var _a3;\n    if (this.isClosed) return;\n    await ((_a3 = this.transport) == null ? void 0 : _a3.close());\n    this.onClose();\n  }\n  assertCapability(method) {\n    switch (method) {\n      case \"initialize\":\n        break;\n      case \"tools/list\":\n      case \"tools/call\":\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`\n          });\n        }\n        break;\n      case \"resources/list\":\n      case \"resources/read\":\n      case \"resources/templates/list\":\n        if (!this.serverCapabilities.resources) {\n          throw new MCPClientError({\n            message: `Server does not support resources`\n          });\n        }\n        break;\n      case \"prompts/list\":\n      case \"prompts/get\":\n        if (!this.serverCapabilities.prompts) {\n          throw new MCPClientError({\n            message: `Server does not support prompts`\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`\n        });\n    }\n  }\n  async request({\n    request,\n    resultSchema,\n    options\n  }) {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: \"Attempted to send a request from a closed client\"\n          })\n        );\n      }\n      this.assertCapability(request.method);\n      const signal = options == null ? void 0 : options.signal;\n      signal == null ? void 0 : signal.throwIfAborted();\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest = {\n        ...request,\n        jsonrpc: \"2.0\",\n        id: messageId\n      };\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n      this.responseHandlers.set(messageId, (response) => {\n        if (signal == null ? void 0 : signal.aborted) {\n          return reject(\n            new MCPClientError({\n              message: \"Request was aborted\",\n              cause: signal.reason\n            })\n          );\n        }\n        if (response instanceof Error) {\n          return reject(response);\n        }\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: \"Failed to parse server response\",\n            cause: error\n          });\n          reject(parseError);\n        }\n      });\n      this.transport.send(jsonrpcRequest).catch((error) => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n  async listTools({\n    params,\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"tools/list\", params },\n        resultSchema: ListToolsResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async callTool({\n    name: name3,\n    args,\n    options\n  }) {\n    try {\n      return this.request({\n        request: { method: \"tools/call\", params: { name: name3, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options == null ? void 0 : options.abortSignal\n        }\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async listResourcesInternal({\n    params,\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"resources/list\", params },\n        resultSchema: ListResourcesResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async readResourceInternal({\n    uri,\n    options\n  }) {\n    try {\n      return this.request({\n        request: { method: \"resources/read\", params: { uri } },\n        resultSchema: ReadResourceResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async listResourceTemplatesInternal({\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"resources/templates/list\" },\n        resultSchema: ListResourceTemplatesResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async listPromptsInternal({\n    params,\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"prompts/list\", params },\n        resultSchema: ListPromptsResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async getPromptInternal({\n    name: name3,\n    args,\n    options\n  }) {\n    try {\n      return this.request({\n        request: { method: \"prompts/get\", params: { name: name3, arguments: args } },\n        resultSchema: GetPromptResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async notification(notification) {\n    const jsonrpcNotification = {\n      ...notification,\n      jsonrpc: \"2.0\"\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools({\n    schemas = \"automatic\"\n  } = {}) {\n    var _a3;\n    const tools = {};\n    try {\n      const listToolsResult = await this.listTools();\n      for (const {\n        name: name3,\n        description,\n        inputSchema,\n        annotations,\n        _meta\n      } of listToolsResult.tools) {\n        const title = annotations == null ? void 0 : annotations.title;\n        if (schemas !== \"automatic\" && !(name3 in schemas)) {\n          continue;\n        }\n        const self = this;\n        const execute = async (args, options) => {\n          var _a4;\n          (_a4 = options == null ? void 0 : options.abortSignal) == null ? void 0 : _a4.throwIfAborted();\n          return self.callTool({ name: name3, args, options });\n        };\n        const toolWithExecute = schemas === \"automatic\" ? dynamicTool({\n          description,\n          title,\n          inputSchema: jsonSchema({\n            ...inputSchema,\n            properties: (_a3 = inputSchema.properties) != null ? _a3 : {},\n            additionalProperties: false\n          }),\n          execute\n        }) : tool({\n          description,\n          title,\n          inputSchema: schemas[name3].inputSchema,\n          execute\n        });\n        tools[name3] = { ...toolWithExecute, _meta };\n      }\n      return tools;\n    } catch (error) {\n      throw error;\n    }\n  }\n  listResources({\n    params,\n    options\n  } = {}) {\n    return this.listResourcesInternal({ params, options });\n  }\n  readResource({\n    uri,\n    options\n  }) {\n    return this.readResourceInternal({ uri, options });\n  }\n  listResourceTemplates({\n    options\n  } = {}) {\n    return this.listResourceTemplatesInternal({ options });\n  }\n  experimental_listPrompts({\n    params,\n    options\n  } = {}) {\n    return this.listPromptsInternal({ params, options });\n  }\n  experimental_getPrompt({\n    name: name3,\n    arguments: args,\n    options\n  }) {\n    return this.getPromptInternal({ name: name3, args, options });\n  }\n  onElicitationRequest(schema, handler) {\n    if (schema !== ElicitationRequestSchema) {\n      throw new MCPClientError({\n        message: \"Unsupported request schema. Only ElicitationRequestSchema is supported.\"\n      });\n    }\n    this.elicitationRequestHandler = handler;\n  }\n  async onRequestMessage(request) {\n    try {\n      if (request.method !== \"elicitation/create\") {\n        await this.transport.send({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          error: {\n            code: -32601,\n            message: `Unsupported request method: ${request.method}`\n          }\n        });\n        return;\n      }\n      if (!this.elicitationRequestHandler) {\n        await this.transport.send({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          error: {\n            code: -32601,\n            message: \"No elicitation handler registered on client\"\n          }\n        });\n        return;\n      }\n      const parsedRequest = ElicitationRequestSchema.safeParse({\n        method: request.method,\n        params: request.params\n      });\n      if (!parsedRequest.success) {\n        await this.transport.send({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          error: {\n            code: -32602,\n            message: `Invalid elicitation request: ${parsedRequest.error.message}`,\n            data: parsedRequest.error.issues\n          }\n        });\n        return;\n      }\n      try {\n        const result = await this.elicitationRequestHandler(parsedRequest.data);\n        const validatedResult = ElicitResultSchema.parse(result);\n        await this.transport.send({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          result: validatedResult\n        });\n      } catch (error) {\n        await this.transport.send({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          error: {\n            code: -32603,\n            message: error instanceof Error ? error.message : \"Failed to handle elicitation request\"\n          }\n        });\n        this.onError(error);\n      }\n    } catch (error) {\n      this.onError(error);\n    }\n  }\n  onClose() {\n    if (this.isClosed) return;\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: \"Connection closed\"\n    });\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n    this.responseHandlers.clear();\n  }\n  onError(error) {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n  onResponse(response) {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n    if (handler === void 0) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response\n        )}`\n      });\n    }\n    this.responseHandlers.delete(messageId);\n    handler(\n      \"result\" in response ? response : new MCPClientError({\n        message: response.error.message,\n        code: response.error.code,\n        data: response.error.data,\n        cause: response.error\n      })\n    );\n  }\n};\nexport {\n  ElicitResultSchema,\n  ElicitationRequestSchema,\n  UnauthorizedError,\n  auth,\n  createMCPClient,\n  createMCPClient as experimental_createMCPClient\n};\n//# sourceMappingURL=index.mjs.map","import { randomUUID } from \"node:crypto\";\nimport type {\n  OAuthClientMetadata,\n  OAuthClientProvider,\n  OAuthTokens,\n} from \"@ai-sdk/mcp\";\nimport {\n  createOAuthSession,\n  deleteSessionByState,\n  getAuthenticatedSession,\n  getSessionByState,\n  type OAuthClientInformationFull,\n  saveTokensAndCleanup,\n  setOAuthClientInfoOnceByState,\n  setOAuthCodeVerifierOnceByState,\n  updateSessionByState,\n} from \"@/lib/db/mcp-queries\";\nimport type { McpOAuthSession } from \"@/lib/db/schema\";\nimport { createModuleLogger } from \"@/lib/logger\";\n\nconst log = createModuleLogger(\"mcp-oauth-provider\");\n\n/**\n * Custom error thrown when OAuth authorization is required.\n * The client should catch this and redirect the user to the authorization URL.\n */\nexport class OAuthAuthorizationRequiredError extends Error {\n  authorizationUrl: URL;\n\n  constructor(authorizationUrl: URL) {\n    super(\"OAuth user authorization required\");\n    this.name = \"OAuthAuthorizationRequiredError\";\n    this.authorizationUrl = authorizationUrl;\n  }\n}\n\n/**\n * PostgreSQL-backed OAuth client provider for MCP.\n * Implements the OAuthClientProvider interface from the AI SDK.\n * Persists OAuth state, PKCE verifier, client info, and tokens to the database.\n */\nexport class McpOAuthClientProvider implements OAuthClientProvider {\n  private currentOAuthState = \"\";\n  private cachedAuthData: McpOAuthSession | undefined;\n  private initialized = false;\n  private saveCodeVerifierPromise: Promise<void> | null = null;\n  private cachedAuthorizationUrl: URL | null = null;\n  private readonly config: {\n    mcpConnectorId: string;\n    serverUrl: string;\n    clientMetadata: OAuthClientMetadata;\n    onRedirectToAuthorization: (authUrl: URL) => Promise<void>;\n    state?: string; // Optional: adopt existing state (for callback reconciliation)\n  };\n  private saveClientInformationPromise: Promise<void> | null = null;\n\n  constructor(config: {\n    mcpConnectorId: string;\n    serverUrl: string;\n    clientMetadata: OAuthClientMetadata;\n    onRedirectToAuthorization: (authUrl: URL) => Promise<void>;\n    state?: string; // Optional: adopt existing state (for callback reconciliation)\n  }) {\n    this.config = config;\n  }\n\n  private initializationPromise: Promise<void> | null = null;\n\n  private async initializeOAuth() {\n    // Prevent concurrent initialization - return existing promise if in progress\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n\n    if (this.initialized) {\n      return;\n    }\n\n    this.initializationPromise = this.doInitializeOAuth();\n    try {\n      await this.initializationPromise;\n    } finally {\n      this.initializationPromise = null;\n    }\n  }\n\n  private async doInitializeOAuth() {\n    // If state was provided (e.g., from callback), adopt it\n    if (this.config.state) {\n      const session = await getSessionByState({ state: this.config.state });\n      if (session && session.mcpConnectorId === this.config.mcpConnectorId) {\n        this.currentOAuthState = session.state ?? \"\";\n        this.cachedAuthData = session;\n        this.initialized = true;\n        return;\n      }\n    }\n\n    // Check for existing authenticated session\n    const authenticated = await getAuthenticatedSession({\n      mcpConnectorId: this.config.mcpConnectorId,\n    });\n    if (authenticated) {\n      this.currentOAuthState = authenticated.state ?? \"\";\n      this.cachedAuthData = authenticated;\n      this.initialized = true;\n      return;\n    }\n\n    // Create new in-progress session\n    this.currentOAuthState = randomUUID();\n    this.cachedAuthData = await createOAuthSession({\n      mcpConnectorId: this.config.mcpConnectorId,\n      serverUrl: this.config.serverUrl,\n      state: this.currentOAuthState,\n    });\n    this.initialized = true;\n  }\n\n  private async getAuthData() {\n    await this.initializeOAuth();\n    return this.cachedAuthData;\n  }\n\n  private async updateAuthData(data: {\n    tokens?: OAuthTokens | null;\n    clientInfo?: OAuthClientInformationFull | null;\n    codeVerifier?: string | null;\n  }) {\n    if (!this.currentOAuthState) {\n      throw new Error(\"OAuth not initialized\");\n    }\n\n    this.cachedAuthData = await updateSessionByState({\n      state: this.currentOAuthState,\n      updates: data,\n    });\n\n    return this.cachedAuthData;\n  }\n\n  get redirectUrl(): string {\n    return this.config.clientMetadata.redirect_uris[0];\n  }\n\n  get clientMetadata(): OAuthClientMetadata {\n    return this.config.clientMetadata;\n  }\n\n  state(): string {\n    return this.currentOAuthState;\n  }\n\n  async clientInformation(): Promise<OAuthClientInformationFull | undefined> {\n    const authData = await this.getAuthData();\n    if (authData?.clientInfo) {\n      const clientInfo = authData.clientInfo as OAuthClientInformationFull;\n      // Security: if redirect URI changed and no tokens yet, invalidate\n      if (\n        !authData.tokens &&\n        clientInfo.redirect_uris[0] !== this.redirectUrl\n      ) {\n        log.warn(\n          {\n            state: authData.state,\n            savedRedirectUri: clientInfo.redirect_uris[0],\n            currentRedirectUri: this.redirectUrl,\n          },\n          \"clientInformation: redirect URI mismatch, invalidating session\"\n        );\n        if (authData.state) {\n          await deleteSessionByState({ state: authData.state });\n        }\n        this.cachedAuthData = undefined;\n        this.initialized = false;\n        return;\n      }\n      return clientInfo;\n    }\n    return;\n  }\n\n  async saveClientInformation(\n    clientCredentials: OAuthClientInformationFull\n  ): Promise<void> {\n    if (this.saveClientInformationPromise) {\n      await this.saveClientInformationPromise;\n      return;\n    }\n\n    // If we already have a client registered for this state, keep it stable.\n    // Some OAuth servers treat authorization codes as bound to client_id.\n    if (this.cachedAuthData?.clientInfo) {\n      return;\n    }\n\n    // Optimistic set so subsequent calls in this instance skip.\n    if (this.cachedAuthData) {\n      this.cachedAuthData = {\n        ...this.cachedAuthData,\n        clientInfo: clientCredentials,\n      };\n    }\n\n    this.saveClientInformationPromise = setOAuthClientInfoOnceByState({\n      state: this.currentOAuthState,\n      clientInfo: clientCredentials,\n    })\n      .then((session) => {\n        this.cachedAuthData = session;\n      })\n      .finally(() => {\n        this.saveClientInformationPromise = null;\n      });\n    await this.saveClientInformationPromise;\n  }\n\n  async tokens(): Promise<OAuthTokens | undefined> {\n    const authData = await this.getAuthData();\n    return authData?.tokens as OAuthTokens | undefined;\n  }\n\n  async saveTokens(tokens: OAuthTokens): Promise<void> {\n    this.cachedAuthData = await saveTokensAndCleanup({\n      state: this.currentOAuthState,\n      mcpConnectorId: this.config.mcpConnectorId,\n      tokens,\n    });\n  }\n\n  async redirectToAuthorization(authorizationUrl: URL): Promise<void> {\n    authorizationUrl.searchParams.set(\"state\", this.state());\n\n    // If the SDK calls redirect twice, keep the first URL stable.\n    // Otherwise the UI might open URL #1 while the DB ended up with verifier #2.\n    if (this.cachedAuthorizationUrl) {\n      await this.config.onRedirectToAuthorization(this.cachedAuthorizationUrl);\n      return;\n    }\n    this.cachedAuthorizationUrl = new URL(authorizationUrl.toString());\n\n    await this.config.onRedirectToAuthorization(authorizationUrl);\n  }\n\n  async saveCodeVerifier(pkceVerifier: string): Promise<void> {\n    if (this.saveCodeVerifierPromise) {\n      await this.saveCodeVerifierPromise;\n      return;\n    }\n\n    // Only save verifier ONCE - the AI SDK calls this multiple times\n    // but the code_challenge is generated from the FIRST verifier.\n    // If we already have a verifier for this session, keep it.\n    const existingVerifier = this.cachedAuthData?.codeVerifier;\n\n    if (existingVerifier) {\n      log.info(\n        {\n          state: this.currentOAuthState,\n          existingVerifierPrefix: existingVerifier.slice(0, 10),\n          newVerifierPrefix: pkceVerifier.slice(0, 10),\n        },\n        \"saveCodeVerifier: SKIPPING - verifier already exists\"\n      );\n\n      return;\n    }\n\n    log.info(\n      {\n        state: this.currentOAuthState,\n        codeVerifierPrefix: pkceVerifier.slice(0, 10),\n      },\n      \"saveCodeVerifier: saving first verifier\"\n    );\n\n    // Optimistic in-memory set so a concurrent call in this instance will skip.\n    if (this.cachedAuthData) {\n      this.cachedAuthData = {\n        ...this.cachedAuthData,\n        codeVerifier: pkceVerifier,\n      };\n    }\n\n    // Serialize and make the DB write immutable (DB-side also guards against overwrite).\n    this.saveCodeVerifierPromise = setOAuthCodeVerifierOnceByState({\n      state: this.currentOAuthState,\n      codeVerifier: pkceVerifier,\n    })\n      .then((session) => {\n        this.cachedAuthData = session;\n      })\n      .finally(() => {\n        this.saveCodeVerifierPromise = null;\n      });\n    await this.saveCodeVerifierPromise;\n  }\n\n  async codeVerifier(): Promise<string> {\n    const authData = await this.getAuthData();\n    log.info(\n      {\n        state: this.currentOAuthState,\n        hasCodeVerifier: !!authData?.codeVerifier,\n        codeVerifierPrefix: authData?.codeVerifier?.slice(0, 10),\n      },\n      \"codeVerifier called\"\n    );\n    if (!authData?.codeVerifier) {\n      throw new Error(\"OAuth code verifier not found\");\n    }\n    return authData.codeVerifier;\n  }\n\n  /**\n   * Adopt state from another instance (multi-instance support).\n   * Used when the callback needs to reconcile with an existing session.\n   */\n  async adoptState(state: string): Promise<void> {\n    if (!state) {\n      log.warn(\"adoptState called with empty state\");\n      return;\n    }\n\n    // If already initialized with this exact state, skip DB lookup\n    if (this.initialized && this.currentOAuthState === state) {\n      log.info({ state }, \"adoptState: already initialized with this state\");\n      return;\n    }\n\n    const session = await getSessionByState({ state });\n    if (!session) {\n      log.warn({ state }, \"adoptState: session not found\");\n      return;\n    }\n    if (session.mcpConnectorId !== this.config.mcpConnectorId) {\n      log.warn(\n        {\n          state,\n          sessionConnectorId: session.mcpConnectorId,\n          expectedConnectorId: this.config.mcpConnectorId,\n        },\n        \"adoptState: connector ID mismatch\"\n      );\n      return;\n    }\n    log.info(\n      {\n        state,\n        previousState: this.currentOAuthState,\n        wasInitialized: this.initialized,\n        hasCodeVerifier: !!session.codeVerifier,\n        hasClientInfo: !!session.clientInfo,\n        hasTokens: !!session.tokens,\n      },\n      \"adoptState: adopting session (overriding previous state if any)\"\n    );\n    this.currentOAuthState = state;\n    this.cachedAuthData = session;\n    this.initialized = true;\n  }\n\n  async invalidateCredentials(\n    scope: \"all\" | \"client\" | \"tokens\" | \"verifier\"\n  ): Promise<void> {\n    if (scope === \"all\") {\n      await deleteSessionByState({ state: this.currentOAuthState });\n      this.cachedAuthData = undefined;\n      this.initialized = false;\n      this.currentOAuthState = \"\";\n    } else if (scope === \"tokens\") {\n      await this.updateAuthData({ tokens: null });\n    } else if (scope === \"client\") {\n      // Clear client credentials - this forces re-registration with the OAuth server\n      await this.updateAuthData({ clientInfo: null });\n      // Reset state since client info is foundational to the OAuth flow\n      this.initialized = false;\n      this.currentOAuthState = \"\";\n      this.cachedAuthData = undefined;\n    } else if (scope === \"verifier\") {\n      // Clear the PKCE verifier - this invalidates any pending authorization\n      await this.updateAuthData({ codeVerifier: null });\n      // Clear cached authorization URL since it's tied to the old verifier\n      this.cachedAuthorizationUrl = null;\n    }\n  }\n}\n","import {\n  auth,\n  experimental_createMCPClient as createMCPClient,\n} from \"@ai-sdk/mcp\";\nimport type {\n  ListPromptsResult,\n  ListResourcesResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { Tool } from \"ai\";\nimport { config } from \"@/lib/config\";\nimport { createModuleLogger } from \"@/lib/logger\";\nimport { getBaseUrl } from \"@/lib/url\";\nimport { invalidateAllMcpCaches } from \"./cache\";\nimport {\n  McpOAuthClientProvider,\n  OAuthAuthorizationRequiredError,\n} from \"./mcp-oauth-provider\";\n\nconst log = createModuleLogger(\"mcp-client\");\n\ntype McpClientInstance = Awaited<ReturnType<typeof createMCPClient>>;\n\ntype McpClientStatus =\n  | \"disconnected\"\n  | \"connecting\"\n  | \"connected\"\n  | \"authorizing\"\n  | \"incompatible\";\n\n/**\n * MCP Client wrapper with OAuth support.\n * Uses @ai-sdk/mcp's createMCPClient with authProvider for OAuth flow.\n */\nexport class MCPClient {\n  private client?: McpClientInstance;\n  private readonly oauthProvider: McpOAuthClientProvider;\n  private authorizationUrl?: URL;\n  private _status: McpClientStatus = \"disconnected\";\n\n  private readonly id: string;\n  private readonly name: string;\n  private readonly serverConfig: {\n    url: string;\n    type: \"http\" | \"sse\";\n    headers?: Record<string, string>;\n  };\n\n  constructor(\n    id: string,\n    name: string,\n    serverConfig: {\n      url: string;\n      type: \"http\" | \"sse\";\n      headers?: Record<string, string>;\n    }\n  ) {\n    this.id = id;\n    this.name = name;\n    this.serverConfig = serverConfig;\n    const baseUrl = getBaseUrl();\n\n    this.oauthProvider = new McpOAuthClientProvider({\n      mcpConnectorId: this.id,\n      serverUrl: this.serverConfig.url,\n      clientMetadata: {\n        client_name: `${config.appPrefix}-${this.name}`,\n        grant_types: [\"authorization_code\", \"refresh_token\"],\n        response_types: [\"code\"],\n        token_endpoint_auth_method: \"none\", // PKCE\n        scope: \"mcp:tools\",\n        redirect_uris: [`${baseUrl}/api/mcp/oauth/callback`],\n        software_id: config.appPrefix,\n        software_version: \"1.0.0\",\n      },\n      onRedirectToAuthorization: (authorizationUrl: URL) => {\n        this.authorizationUrl = authorizationUrl;\n        throw new OAuthAuthorizationRequiredError(authorizationUrl);\n      },\n    });\n  }\n\n  get status(): McpClientStatus {\n    if (this.authorizationUrl) {\n      return \"authorizing\";\n    }\n    if (this.client) {\n      return \"connected\";\n    }\n    return this._status;\n  }\n\n  getAuthorizationUrl(): URL | undefined {\n    return this.authorizationUrl;\n  }\n\n  async connect(oauthState?: string): Promise<McpClientInstance | undefined> {\n    if (this.status === \"connected\" && this.client) {\n      return this.client;\n    }\n\n    this._status = \"connecting\";\n\n    // Adopt state if provided (for callback reconciliation)\n    if (oauthState) {\n      await this.oauthProvider.adoptState(oauthState);\n    }\n\n    try {\n      // AI SDK handles 401 internally and calls auth() with the provider\n      this.client = await createMCPClient({\n        transport: {\n          type: this.serverConfig.type,\n          url: this.serverConfig.url,\n          headers: this.serverConfig.headers,\n          authProvider: this.oauthProvider,\n        },\n      });\n\n      this._status = \"connected\";\n      return this.client;\n    } catch (error) {\n      // If OAuth required error, status becomes \"authorizing\"\n      if (error instanceof OAuthAuthorizationRequiredError) {\n        this._status = \"authorizing\";\n        log.info(\n          { connectorId: this.id, authUrl: error.authorizationUrl.toString() },\n          \"OAuth authorization required\"\n        );\n        return;\n      }\n\n      this._status = \"disconnected\";\n      throw error;\n    }\n  }\n\n  /**\n   * Lightweight connection test - just checks if we can connect without full discovery.\n   * Returns connection status without fetching tools/resources/prompts.\n   */\n  async attemptConnection(): Promise<{\n    status: McpClientStatus;\n    needsAuth: boolean;\n    error?: string;\n  }> {\n    // If already connected, return current status\n    if (this.status === \"connected\" && this.client) {\n      return { status: \"connected\", needsAuth: false };\n    }\n\n    // If already in authorizing state, return that\n    if (this.authorizationUrl) {\n      return { status: \"authorizing\", needsAuth: true };\n    }\n\n    try {\n      await this.connect();\n      // Check if OAuth is required (authorizationUrl gets set during connect)\n      if (this.authorizationUrl) {\n        return { status: \"authorizing\", needsAuth: true };\n      }\n      return {\n        status: this.client ? \"connected\" : \"disconnected\",\n        needsAuth: false,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      log.error(\n        {\n          connectorId: this.id,\n          errorMessage,\n          errorStack: error instanceof Error ? error.stack : undefined,\n        },\n        \"attemptConnection failed\"\n      );\n\n      // Detect incompatible server errors\n      if (\n        errorMessage.includes(\"does not support dynamic client registration\")\n      ) {\n        this._status = \"incompatible\";\n        return {\n          status: \"incompatible\",\n          needsAuth: false,\n          error:\n            \"Server requires pre-configured OAuth credentials (does not support dynamic client registration)\",\n        };\n      }\n\n      return { status: \"disconnected\", needsAuth: false, error: errorMessage };\n    }\n  }\n\n  /**\n   * Called after callback receives code to complete the OAuth flow.\n   */\n  async finishAuth(code: string, state: string): Promise<void> {\n    // Always adopt the state from the callback to load the session with code verifier\n    await this.oauthProvider.adoptState(state);\n\n    // Use the auth function from @ai-sdk/mcp to complete the OAuth flow\n    await auth(this.oauthProvider, {\n      serverUrl: this.serverConfig.url,\n      authorizationCode: code,\n    });\n\n    this.authorizationUrl = undefined;\n    // Don't set to connected - tokens are saved, next connect() will use them\n  }\n\n  /**\n   * Get tools from the MCP server, already in AI SDK format.\n   */\n  async tools(): Promise<Record<string, Tool>> {\n    if (!this.client) {\n      throw new Error(\"Client not connected\");\n    }\n    try {\n      return await this.client.tools();\n    } catch (error) {\n      this.handlePotentialAuthError(error);\n      throw error;\n    }\n  }\n\n  /**\n   * List resources from the MCP server.\n   */\n  async listResources(): Promise<ListResourcesResult> {\n    if (!this.client) {\n      throw new Error(\"Client not connected\");\n    }\n    try {\n      return await this.client.listResources();\n    } catch (error) {\n      this.handlePotentialAuthError(error);\n      throw error;\n    }\n  }\n\n  /**\n   * List prompts from the MCP server.\n   */\n  async listPrompts(): Promise<ListPromptsResult> {\n    if (!this.client) {\n      throw new Error(\"Client not connected\");\n    }\n    try {\n      return await this.client.experimental_listPrompts();\n    } catch (error) {\n      this.handlePotentialAuthError(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Close the connection to the MCP server.\n   */\n  async close(): Promise<void> {\n    try {\n      await this.client?.close();\n    } catch (error) {\n      log.error({ error, connectorId: this.id }, \"Error closing MCP client\");\n    }\n    this.client = undefined;\n    this._status = \"disconnected\";\n    // Invalidate caches since connection state changed\n    invalidateAllMcpCaches(this.id);\n  }\n\n  /**\n   * Check if an error is an auth error (401/403) and invalidate caches if so.\n   */\n  private handlePotentialAuthError(error: unknown): void {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const isAuthError =\n      errorMessage.includes(\"401\") ||\n      errorMessage.includes(\"403\") ||\n      errorMessage.includes(\"Unauthorized\") ||\n      errorMessage.includes(\"Forbidden\") ||\n      errorMessage.includes(\"token\");\n\n    if (isAuthError) {\n      log.warn(\n        { connectorId: this.id, errorMessage },\n        \"Auth error detected, invalidating caches\"\n      );\n      invalidateAllMcpCaches(this.id);\n    }\n  }\n}\n\n// Map to store active MCP clients by connector ID\nconst clientsMap = new Map<string, MCPClient>();\n\n/**\n * Get or create an MCP client for a connector.\n */\nexport function getOrCreateMcpClient({\n  id,\n  name,\n  url,\n  type,\n  headers,\n}: {\n  id: string;\n  name: string;\n  url: string;\n  type: \"http\" | \"sse\";\n  headers?: Record<string, string>;\n}): MCPClient {\n  let client = clientsMap.get(id);\n\n  if (!client) {\n    client = new MCPClient(id, name, { url, type, headers });\n    clientsMap.set(id, client);\n  }\n\n  return client;\n}\n\n/**\n * Remove an MCP client from the cache and close it.\n */\nexport async function removeMcpClient(id: string): Promise<void> {\n  const client = clientsMap.get(id);\n  if (client) {\n    await client.close();\n    clientsMap.delete(id);\n  }\n}\n\n/**\n * Get an existing MCP client by ID.\n */\nfunction _getMcpClient(id: string): MCPClient | undefined {\n  return clientsMap.get(id);\n}\n\n/**\n * Create a fresh MCP client for OAuth callback handling.\n * Does NOT use the cache - creates a new instance to avoid state conflicts.\n */\nexport function createMcpClientForCallback({\n  id,\n  name,\n  url,\n  type,\n  headers,\n}: {\n  id: string;\n  name: string;\n  url: string;\n  type: \"http\" | \"sse\";\n  headers?: Record<string, string>;\n}): MCPClient {\n  return new MCPClient(id, name, { url, type, headers });\n}\n","const UNDERSCORE_COLLAPSE_REGEX = /_+/g;\nconst UNDERSCORE_TRIM_REGEX = /^_|_$/g;\nconst NON_ALPHANUMERIC_REGEX = /[^a-z0-9]/g;\n\n/** Maximum length for connector names */\nexport const MCP_NAME_MAX_LENGTH = 20;\n\n/** Reserved namespace prefix for global connectors (userId = null) */\nconst GLOBAL_NAMESPACE_PREFIX = \"global\";\n\n/** Separator between namespace and tool name (OpenAI requires ^[a-zA-Z0-9_-]+$) */\nconst TOOL_ID_SEPARATOR = \"__\";\n\nexport type GenerateMcpNameIdResult =\n  | { ok: true; nameId: string }\n  | { ok: false; error: \"empty\" | \"reserved\" };\n\n/**\n * Generates a namespace (nameId) from a connector name.\n * Rules:\n * - Lowercase, replace non-alphanumeric with underscores\n * - Collapse consecutive underscores, trim leading/trailing\n * - Cannot equal \"global\" exactly (reserved for global connectors)\n * - Cannot result in empty string\n */\nexport function generateMcpNameId(name: string): GenerateMcpNameIdResult {\n  const nameId = name\n    .toLowerCase()\n    .replace(NON_ALPHANUMERIC_REGEX, \"_\")\n    .replace(UNDERSCORE_COLLAPSE_REGEX, \"_\")\n    .replace(UNDERSCORE_TRIM_REGEX, \"\");\n\n  if (!nameId) {\n    return { ok: false, error: \"empty\" };\n  }\n\n  if (nameId === GLOBAL_NAMESPACE_PREFIX) {\n    return { ok: false, error: \"reserved\" };\n  }\n\n  return { ok: true, nameId };\n}\n\n/**\n * Creates a fully qualified tool ID from namespace and tool name.\n * Format: `{namespace}__{toolName}`\n * For global connectors: `global__{nameId}__{toolName}`\n * Uses `__` separator for OpenAI compatibility (requires ^[a-zA-Z0-9_-]+$)\n */\nexport function createToolId(\n  namespace: string,\n  toolName: string,\n  isGlobal: boolean\n): string {\n  if (isGlobal) {\n    return `${GLOBAL_NAMESPACE_PREFIX}${TOOL_ID_SEPARATOR}${namespace}${TOOL_ID_SEPARATOR}${toolName}`;\n  }\n  return `${namespace}${TOOL_ID_SEPARATOR}${toolName}`;\n}\n\n/**\n * Parses a tool ID back into its components.\n * Splits on `__` separator to get namespace and tool name.\n * For global tools, returns { isGlobal: true, namespace, toolName }\n */\nexport function parseToolId(toolId: string): {\n  isGlobal: boolean;\n  namespace: string;\n  toolName: string;\n} | null {\n  const firstSep = toolId.indexOf(TOOL_ID_SEPARATOR);\n  if (firstSep === -1) {\n    return null; // No namespace, not an MCP tool\n  }\n\n  const firstPart = toolId.slice(0, firstSep);\n  const rest = toolId.slice(firstSep + TOOL_ID_SEPARATOR.length);\n\n  if (firstPart === GLOBAL_NAMESPACE_PREFIX) {\n    // Global tool: global__{namespace}__{toolName}\n    const secondSep = rest.indexOf(TOOL_ID_SEPARATOR);\n    if (secondSep === -1) {\n      return null; // Malformed\n    }\n    return {\n      isGlobal: true,\n      namespace: rest.slice(0, secondSep),\n      toolName: rest.slice(secondSep + TOOL_ID_SEPARATOR.length),\n    };\n  }\n\n  // User tool: {namespace}__{toolName}\n  return {\n    isGlobal: false,\n    namespace: firstPart,\n    toolName: rest,\n  };\n}\n","import { z } from \"zod\";\nimport { MCP_NAME_MAX_LENGTH } from \"@/lib/ai/mcp-name-id\";\n\nexport const mcpCreateInputSchema = z.object({\n  name: z.string().min(1).max(MCP_NAME_MAX_LENGTH),\n  url: z.string().url(),\n  type: z.enum([\"http\", \"sse\"]),\n  oauthClientId: z.string().optional(),\n  oauthClientSecret: z.string().optional(),\n});\n\nexport const mcpUpdateInputSchema = z.object({\n  id: z.string().uuid(),\n  updates: z.object({\n    name: z.string().min(1).max(MCP_NAME_MAX_LENGTH).optional(),\n    url: z.string().url().optional(),\n    type: z.enum([\"http\", \"sse\"]).optional(),\n    oauthClientId: z.string().nullable().optional(),\n    oauthClientSecret: z.string().nullable().optional(),\n    enabled: z.boolean().optional(),\n  }),\n});\n\nexport const mcpIdInputSchema = z.object({ id: z.string().uuid() });\n\nexport const mcpToggleEnabledInputSchema = z.object({\n  id: z.string().uuid(),\n  enabled: z.boolean(),\n});\n\nexport const mcpDiscoverInputSchema = z.object({ id: z.uuid() });\n","\"use server\";\n\nimport { requestInfo } from \"rwsdk/worker\";\nimport type { z } from \"zod\";\nimport {\n  type ConnectionStatusResult,\n  createCachedConnectionStatus,\n  createCachedDiscovery,\n  type DiscoveryResult,\n  invalidateAllMcpCaches,\n} from \"@/lib/ai/mcp/cache\";\nimport { getOrCreateMcpClient, removeMcpClient } from \"@/lib/ai/mcp/mcp-client\";\nimport { generateMcpNameId } from \"@/lib/ai/mcp-name-id\";\nimport { auth } from \"@/lib/auth\";\nimport { config } from \"@/lib/config\";\nimport {\n  createMcpConnector,\n  deleteMcpConnector,\n  deleteSessionsByConnectorId,\n  getAuthenticatedSession,\n  getMcpConnectorById,\n  getMcpConnectorByNameId,\n  getMcpConnectorsByUserId,\n  updateMcpConnector,\n} from \"@/lib/db/mcp-queries\";\nimport { createModuleLogger } from \"@/lib/logger\";\nimport {\n  mcpCreateInputSchema,\n  mcpDiscoverInputSchema,\n  mcpIdInputSchema,\n  mcpToggleEnabledInputSchema,\n  mcpUpdateInputSchema,\n} from \"@/lib/schemas/mcp\";\n\nconst log = createModuleLogger(\"mcp.actions\");\n\ntype Permission = \"own\" | \"own-or-global\";\n\ntype McpCreateInput = z.infer<typeof mcpCreateInputSchema>;\ntype McpUpdateInput = z.infer<typeof mcpUpdateInputSchema>;\ntype McpIdInput = z.infer<typeof mcpIdInputSchema>;\ntype McpToggleEnabledInput = z.infer<typeof mcpToggleEnabledInputSchema>;\ntype McpDiscoverInput = z.infer<typeof mcpDiscoverInputSchema>;\n\nfunction assertMcpEnabled() {\n  if (!config.integrations.mcp) {\n    throw new Error(\"MCP integration disabled\");\n  }\n}\n\nasync function requireUser() {\n  const session = await auth.api.getSession({\n    headers: requestInfo.request.headers,\n  });\n\n  if (!session?.user) {\n    throw new Error(\"UNAUTHORIZED\");\n  }\n\n  const { id, ...rest } = session.user;\n  if (!id) {\n    console.error(\"User ID missing in session callback\");\n    throw new Error(\"UNAUTHORIZED\");\n  }\n\n  return { id, ...rest };\n}\n\n/**\n * Validates and generates a nameId from a connector name.\n * Throws Error if the name is invalid or the namespace already exists.\n */\nasync function validateAndGenerateNameId({\n  name,\n  userId,\n  excludeId,\n}: {\n  name: string;\n  userId: string | null;\n  excludeId?: string;\n}): Promise<string> {\n  assertMcpEnabled();\n  const result = generateMcpNameId(name);\n  if (!result.ok) {\n    throw new Error(\n      result.error === \"empty\"\n        ? \"Connector name must contain at least one alphanumeric character\"\n        : 'Connector name cannot be \"global\" (reserved)'\n    );\n  }\n\n  const existing = await getMcpConnectorByNameId({\n    userId,\n    nameId: result.nameId,\n    excludeId,\n  });\n\n  if (existing) {\n    throw new Error(\n      `A connector with namespace \"${result.nameId}\" already exists. Choose a different name.`\n    );\n  }\n\n  return result.nameId;\n}\n\n/**\n * Fetches connector and validates user permission.\n * - \"own\": user must own the connector (userId === ctx.user.id)\n * - \"own-or-global\": user must own OR connector is global (userId === null)\n */\nasync function getConnectorWithPermission({\n  id,\n  userId,\n  permission,\n}: {\n  id: string;\n  userId: string;\n  permission: Permission;\n}) {\n  const connector = await getMcpConnectorById({ id });\n  if (!connector) {\n    throw new Error(\"Connector not found\");\n  }\n\n  const isOwner = connector.userId === userId;\n  const isGlobal = connector.userId === null;\n\n  const hasPermission = permission === \"own\" ? isOwner : isOwner || isGlobal;\n\n  if (!hasPermission) {\n    throw new Error(\"Cannot access this connector\");\n  }\n\n  return connector;\n}\n\nexport async function list() {\n  const user = await requireUser();\n  if (!config.integrations.mcp) {\n    return [];\n  }\n  return await getMcpConnectorsByUserId({ userId: user.id });\n}\n\n/**\n * List connectors with their connection status.\n * Returns only connectors that have a valid connection (for use in dropdowns, etc.)\n * Still includes enabled/disabled state so UI can show toggles.\n */\nexport async function listConnected() {\n  const user = await requireUser();\n  if (!config.integrations.mcp) {\n    return [];\n  }\n  const connectors = await getMcpConnectorsByUserId({ userId: user.id });\n\n  const results = await Promise.all(\n    connectors.map(async (connector) => {\n      const fetchConnectionStatus =\n        async (): Promise<ConnectionStatusResult> => {\n          const mcpClient = getOrCreateMcpClient({\n            id: connector.id,\n            name: connector.name,\n            url: connector.url,\n            type: connector.type,\n          });\n          const result = await mcpClient.attemptConnection();\n          return {\n            status: result.status,\n            needsAuth: result.needsAuth,\n            error: result.error,\n          };\n        };\n\n      const cachedFetch = createCachedConnectionStatus(\n        connector.id,\n        fetchConnectionStatus\n      );\n\n      try {\n        const status = await cachedFetch();\n        return { connector, status };\n      } catch {\n        return { connector, status: null };\n      }\n    })\n  );\n\n  return results\n    .filter((r) => r.status?.status === \"connected\")\n    .map((r) => r.connector);\n}\n\nexport async function create(input: McpCreateInput) {\n  const user = await requireUser();\n  const parsed = mcpCreateInputSchema.parse(input);\n  assertMcpEnabled();\n  const nameId = await validateAndGenerateNameId({\n    name: parsed.name,\n    userId: user.id,\n  });\n\n  return await createMcpConnector({\n    userId: user.id,\n    name: parsed.name,\n    nameId,\n    url: parsed.url,\n    type: parsed.type,\n    oauthClientId: parsed.oauthClientId,\n    oauthClientSecret: parsed.oauthClientSecret,\n  });\n}\n\nexport async function update(input: McpUpdateInput) {\n  const user = await requireUser();\n  const parsed = mcpUpdateInputSchema.parse(input);\n  assertMcpEnabled();\n  const connector = await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own\",\n  });\n\n  const updates = { ...parsed.updates };\n  if (updates.name) {\n    const nameId = await validateAndGenerateNameId({\n      name: updates.name,\n      userId: connector.userId,\n      excludeId: parsed.id,\n    });\n    (updates as typeof updates & { nameId: string }).nameId = nameId;\n  }\n\n  await updateMcpConnector({ id: parsed.id, updates });\n  return { success: true };\n}\n\nexport async function deleteConnector(input: McpIdInput) {\n  const user = await requireUser();\n  const parsed = mcpIdInputSchema.parse(input);\n  assertMcpEnabled();\n  await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own\",\n  });\n  await deleteMcpConnector({ id: parsed.id });\n  await removeMcpClient(parsed.id);\n  return { success: true };\n}\n\nexport async function disconnect(input: McpIdInput) {\n  const user = await requireUser();\n  const parsed = mcpIdInputSchema.parse(input);\n  assertMcpEnabled();\n  await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own-or-global\",\n  });\n  await deleteSessionsByConnectorId({ mcpConnectorId: parsed.id });\n  await removeMcpClient(parsed.id);\n  invalidateAllMcpCaches(parsed.id);\n  return { success: true };\n}\n\nexport async function toggleEnabled(input: McpToggleEnabledInput) {\n  const user = await requireUser();\n  const parsed = mcpToggleEnabledInputSchema.parse(input);\n  assertMcpEnabled();\n  await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own\",\n  });\n  await updateMcpConnector({\n    id: parsed.id,\n    updates: { enabled: parsed.enabled },\n  });\n  return { success: true };\n}\n\n/**\n * Lightweight connection test - just checks if we can connect without full discovery.\n * Much faster than discover since it doesn't fetch tools/resources/prompts.\n * Cached for 60 seconds.\n */\nexport async function testConnection(input: McpIdInput) {\n  const user = await requireUser();\n  const parsed = mcpIdInputSchema.parse(input);\n  assertMcpEnabled();\n  const connector = await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own-or-global\",\n  });\n\n  const fetchConnectionStatus = async (): Promise<ConnectionStatusResult> => {\n    log.debug(\n      { connectorId: connector.id, url: connector.url },\n      \"testing MCP connection (cache miss)\"\n    );\n\n    const mcpClient = getOrCreateMcpClient({\n      id: connector.id,\n      name: connector.name,\n      url: connector.url,\n      type: connector.type,\n    });\n\n    const result = await mcpClient.attemptConnection();\n\n    log.debug(\n      {\n        connectorId: connector.id,\n        status: result.status,\n        needsAuth: result.needsAuth,\n        error: result.error,\n      },\n      \"MCP connection test completed\"\n    );\n\n    return {\n      status: result.status,\n      needsAuth: result.needsAuth,\n      error: result.error,\n    };\n  };\n\n  const cachedFetch = createCachedConnectionStatus(\n    connector.id,\n    fetchConnectionStatus\n  );\n\n  return cachedFetch();\n}\n\n/**\n * Discover tools, resources, and prompts from an MCP server.\n * Cached for 5 minutes.\n */\nexport async function discover(input: McpDiscoverInput) {\n  const user = await requireUser();\n  const parsed = mcpDiscoverInputSchema.parse(input);\n  assertMcpEnabled();\n  const connector = await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own-or-global\",\n  });\n\n  const fetchDiscovery = async (): Promise<DiscoveryResult> => {\n    log.debug(\n      { connectorId: connector.id, url: connector.url },\n      \"creating MCP client for discovery (cache miss)\"\n    );\n\n    // Use OAuth-aware client\n    const mcpClient = getOrCreateMcpClient({\n      id: connector.id,\n      name: connector.name,\n      url: connector.url,\n      type: connector.type,\n    });\n\n    await mcpClient.connect();\n\n    // Check if authorization is needed\n    if (mcpClient.status === \"authorizing\") {\n      throw new Error(\"Connector requires OAuth authorization\");\n    }\n\n    if (mcpClient.status !== \"connected\") {\n      throw new Error(\n        `Failed to connect to MCP server (status: ${mcpClient.status})`\n      );\n    }\n\n    log.debug(\n      { connectorId: connector.id },\n      \"MCP client connected, discovering capabilities\"\n    );\n\n    try {\n      const [toolsResult, resourcesResult, promptsResult] = await Promise.all([\n        mcpClient\n          .tools()\n          .then((tools) =>\n            Object.entries(tools).map(([name, tool]) => ({\n              name,\n              description: tool.description ?? null,\n            }))\n          )\n          .catch((err) => {\n            log.warn(\n              { connectorId: connector.id, err },\n              \"failed to list tools\"\n            );\n            return [];\n          }),\n        mcpClient\n          .listResources()\n          .then((r) =>\n            r.resources.map((res) => ({\n              name: res.name,\n              uri: res.uri,\n              description: res.description ?? null,\n              mimeType: res.mimeType ?? null,\n            }))\n          )\n          .catch((err) => {\n            log.warn(\n              { connectorId: connector.id, err },\n              \"failed to list resources\"\n            );\n            return [];\n          }),\n        mcpClient\n          .listPrompts()\n          .then((r) =>\n            r.prompts.map((p) => ({\n              name: p.name,\n              description: p.description ?? null,\n              arguments:\n                p.arguments?.map((arg) => ({\n                  name: arg.name,\n                  description: arg.description ?? null,\n                  required: arg.required ?? false,\n                })) ?? [],\n            }))\n          )\n          .catch((err) => {\n            log.warn(\n              { connectorId: connector.id, err },\n              \"failed to list prompts\"\n            );\n            return [];\n          }),\n      ]);\n\n      log.info(\n        {\n          connectorId: connector.id,\n          toolsCount: toolsResult.length,\n          resourcesCount: resourcesResult.length,\n          promptsCount: promptsResult.length,\n        },\n        \"MCP discovery completed\"\n      );\n\n      return {\n        tools: toolsResult,\n        resources: resourcesResult,\n        prompts: promptsResult,\n      };\n    } finally {\n      // Don't close the client - keep it cached for reuse\n      log.debug({ connectorId: connector.id }, \"MCP discovery finished\");\n    }\n  };\n\n  const cachedFetch = createCachedDiscovery(connector.id, fetchDiscovery);\n\n  return cachedFetch();\n}\n\n/**\n * Initiate OAuth authorization for an MCP connector.\n * Returns the authorization URL that the client should open in a popup.\n */\nexport async function authorize(input: McpIdInput) {\n  const user = await requireUser();\n  const parsed = mcpIdInputSchema.parse(input);\n  assertMcpEnabled();\n  const connector = await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own-or-global\",\n  });\n\n  log.info({ connectorId: connector.id }, \"Initiating OAuth authorization\");\n\n  // Remove any existing client to force a fresh connection\n  await removeMcpClient(connector.id);\n\n  // Create a new client and attempt to connect\n  const mcpClient = getOrCreateMcpClient({\n    id: connector.id,\n    name: connector.name,\n    url: connector.url,\n    type: connector.type,\n  });\n\n  await mcpClient.connect();\n\n  if (mcpClient.status !== \"authorizing\") {\n    throw new Error(\"Connector does not require OAuth authorization\");\n  }\n\n  const authUrl = mcpClient.getAuthorizationUrl();\n  if (!authUrl) {\n    throw new Error(\"Failed to get authorization URL\");\n  }\n\n  log.info(\n    { connectorId: connector.id, authUrl: authUrl.toString() },\n    \"OAuth authorization URL generated\"\n  );\n\n  return { authorizationUrl: authUrl.toString() };\n}\n\n/**\n * Check if a connector has valid OAuth tokens.\n */\nexport async function checkAuth(input: McpIdInput) {\n  const user = await requireUser();\n  const parsed = mcpIdInputSchema.parse(input);\n  assertMcpEnabled();\n  const connector = await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own-or-global\",\n  });\n\n  const session = await getAuthenticatedSession({\n    mcpConnectorId: connector.id,\n  });\n\n  return {\n    isAuthenticated: !!session?.tokens,\n    hasSession: !!session,\n  };\n}\n\n/**\n * Refresh/reconnect an MCP client after OAuth completion.\n */\nexport async function refreshClient(input: McpIdInput) {\n  const user = await requireUser();\n  const parsed = mcpIdInputSchema.parse(input);\n  assertMcpEnabled();\n  const connector = await getConnectorWithPermission({\n    id: parsed.id,\n    userId: user.id,\n    permission: \"own-or-global\",\n  });\n\n  await removeMcpClient(connector.id);\n  invalidateAllMcpCaches(connector.id);\n\n  const mcpClient = getOrCreateMcpClient({\n    id: connector.id,\n    name: connector.name,\n    url: connector.url,\n    type: connector.type,\n  });\n\n  await mcpClient.connect();\n\n  return {\n    status: mcpClient.status,\n    needsAuth: mcpClient.status === \"authorizing\",\n  };\n}\n"],"names":["log","createModuleLogger","mcpCacheTags","connectorId","createCachedConnectionStatus","fetcher","unstable_cache","createCachedDiscovery","invalidateConnectionStatus","revalidateTag","invalidateDiscovery","invalidateAllMcpCaches","crypto","getRandomValues","size","random","mask","evenDistCutoff","result","randomBytes","randomByte","generateVerifier","length","generateChallenge","code_verifier","buffer","pkceChallenge","verifier","challenge","name","marker","symbol","_a","_b","MCPClientError","AISDKError","name3","message","cause","data","code","error","LATEST_PROTOCOL_VERSION","SUPPORTED_PROTOCOL_VERSIONS","ToolMetaSchema","z.optional","z.record","z.string","z.unknown","ClientOrServerImplementationSchema","z.looseObject","BaseParamsSchema","z.object","ResultSchema","RequestSchema","ElicitationCapabilitySchema","z.boolean","ServerCapabilitiesSchema","InitializeResultSchema","PaginatedResultSchema","ToolSchema","z.literal","ListToolsResultSchema","z.array","TextContentSchema","ImageContentSchema","z.base64","ResourceSchema","z.number","ListResourcesResultSchema","ResourceContentsSchema","TextResourceContentsSchema","BlobResourceContentsSchema","EmbeddedResourceSchema","z.union","CallToolResultSchema","ResourceTemplateSchema","ListResourceTemplatesResultSchema","ReadResourceResultSchema","PromptArgumentSchema","PromptSchema","ListPromptsResultSchema","PromptMessageSchema","GetPromptResultSchema","ElicitationRequestParamsSchema","ElicitationRequestSchema","ElicitResultSchema","JSONRPC_VERSION","JSONRPCRequestSchema","z2.object","z2.literal","z2.union","z2.string","z2.number","JSONRPCResponseSchema","JSONRPCErrorSchema","z2.optional","z2.unknown","JSONRPCNotificationSchema","JSONRPCMessageSchema","VERSION","OAuthTokensSchema","z3.object","z3.string","z3.number","SafeUrlSchema","val","ctx","z3.ZodIssueCode","z3.NEVER","url","u","OAuthProtectedResourceMetadataSchema","z3.array","z3.boolean","OAuthMetadataSchema","OpenIdProviderMetadataSchema","OpenIdProviderDiscoveryMetadataSchema","OAuthClientInformationSchema","OAuthClientMetadataSchema","z3.any","OAuthErrorResponseSchema","OAuthClientInformationFullSchema","name2","marker2","symbol2","_a2","_b2","MCPClientOAuthError","AISDKError2","ServerError","InvalidClientError","InvalidGrantError","UnauthorizedClientError","OAUTH_ERRORS","resourceUrlFromServerUrl","resourceURL","checkResourceAllowed","requestedResource","configuredResource","requested","configured","requestedPath","configuredPath","UnauthorizedError","extractResourceMetadataUrl","response","_a3","header","type","scheme","regex","match","buildWellKnownPath","wellKnownPrefix","pathname","options","fetchWithCorsRetry","headers","fetchFn","tryMetadataDiscovery","protocolVersion","shouldAttemptFallback","discoverMetadataWithFallback","serverUrl","wellKnownType","opts","_b3","issuer","wellKnownPath","rootUrl","discoverOAuthProtectedResourceMetadata","buildDiscoveryUrls","authorizationServerUrl","hasPath","urlsToTry","discoverAuthorizationServerMetadata","endpointUrl","metadata","startAuthorization","clientInformation","redirectUrl","scope","state","resource","responseType","codeChallengeMethod","authorizationUrl","codeVerifier","codeChallenge","selectClientAuthMethod","supportedMethods","hasClientSecret","applyClientAuthentication","method","params","client_id","client_secret","applyBasicAuth","applyPostAuth","applyPublicAuth","clientId","clientSecret","credentials","parseErrorResponse","input","statusCode","body","error_description","error_uri","errorClass","errorMessage","exchangeAuthorization","authorizationCode","redirectUri","addClientAuthentication","grantType","tokenUrl","authMethod","refreshAuthorization","refreshToken","registerClient","clientMetadata","registrationUrl","auth","provider","authInternal","selectResourceURL","resourceMetadata","defaultResource","resourceMetadataUrl","fullInformation","codeVerifier2","tokens2","tokens","newTokens","SseMCPTransport","authProvider","base","withUserAgentSuffix","getRuntimeEnvironmentUserAgent","resolve","reject","establishConnection","triedAuth","_c","_d","_e","reader","EventSourceParserStream","processEvents","_a4","_b4","_c2","done","value","event","e","endpoint","attempt","init","text","HttpMCPTransport","withUserAgentSuffix2","getRuntimeEnvironmentUserAgent2","_f","_g","sessionId","error2","contentType","messages","m","EventSourceParserStream2","msg","initialReconnectionDelay","reconnectionDelayGrowFactor","maxReconnectionDelay","maxRetries","delay","resumeToken","_d2","id","createMcpTransport","config","isCustomMcpTransport","transport","CLIENT_VERSION","createMCPClient","client","DefaultMCPClient","transportConfig","version","onUncaughtError","capabilities","request","resultSchema","signal","messageId","jsonrpcRequest","cleanup","parseError","args","uri","notification","jsonrpcNotification","schemas","tools","listToolsResult","description","inputSchema","annotations","_meta","title","self","execute","toolWithExecute","dynamicTool","jsonSchema","tool","schema","handler","parsedRequest","validatedResult","OAuthAuthorizationRequiredError","McpOAuthClientProvider","session","getSessionByState","authenticated","getAuthenticatedSession","randomUUID","createOAuthSession","updateSessionByState","authData","clientInfo","deleteSessionByState","clientCredentials","setOAuthClientInfoOnceByState","saveTokensAndCleanup","pkceVerifier","existingVerifier","setOAuthCodeVerifierOnceByState","MCPClient","serverConfig","baseUrl","getBaseUrl","oauthState","clientsMap","getOrCreateMcpClient","removeMcpClient","UNDERSCORE_COLLAPSE_REGEX","UNDERSCORE_TRIM_REGEX","NON_ALPHANUMERIC_REGEX","MCP_NAME_MAX_LENGTH","GLOBAL_NAMESPACE_PREFIX","generateMcpNameId","nameId","mcpCreateInputSchema","z.enum","mcpUpdateInputSchema","mcpIdInputSchema","mcpToggleEnabledInputSchema","mcpDiscoverInputSchema","z.uuid","assertMcpEnabled","requireUser","requestInfo","rest","validateAndGenerateNameId","userId","excludeId","getMcpConnectorByNameId","getConnectorWithPermission","permission","connector","getMcpConnectorById","isOwner","isGlobal","list","user","getMcpConnectorsByUserId","listConnected","connectors","fetchConnectionStatus","cachedFetch","status","r","create","parsed","createMcpConnector","update","updates","updateMcpConnector","deleteConnector","deleteMcpConnector","disconnect","deleteSessionsByConnectorId","toggleEnabled","testConnection","discover","fetchDiscovery","mcpClient","toolsResult","resourcesResult","promptsResult","err","res","p","arg","authorize","authUrl","checkAuth","refreshClient"],"mappings":"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","x_google_ignoreList":[1,2]}