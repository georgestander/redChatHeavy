import{aE as s,aF as n,aG as i,aH as o,aC as c}from"./index-CPesPnUn.mjs";import"node:events";import"cloudflare:workers";import"async_hooks";import"node:os";import"node:diagnostics_channel";import"fs";import"events";import"util";import"path";import"assert";import"node:stream";import"module";import"node:path";import"url";import"buffer";import"crypto";import"node:crypto";var l=class{get supportsCreateIfNotExists(){return!0}get supportsTransactionalDdl(){return!1}get supportsReturning(){return!0}async acquireMigrationLock(){}async releaseMigrationLock(){}get supportsOutput(){return!0}},u=class{#e;#t=new p;#r;#a;constructor(e){this.#e={...e}}async init(){this.#r=this.#e.database,this.#a=new m(this.#r),this.#e.onCreateConnection&&await this.#e.onCreateConnection(this.#a)}async acquireConnection(){return await this.#t.lock(),this.#a}async beginTransaction(e){await e.executeQuery(s.raw("begin"))}async commitTransaction(e){await e.executeQuery(s.raw("commit"))}async rollbackTransaction(e){await e.executeQuery(s.raw("rollback"))}async releaseConnection(){this.#t.unlock()}async destroy(){this.#r?.close()}},m=class{#e;constructor(e){this.#e=e}executeQuery(e){const{sql:r,parameters:a}=e,t=this.#e.prepare(r).all(...a);return Promise.resolve({rows:t})}async*streamQuery(){throw new Error("Streaming query is not supported by SQLite driver.")}},p=class{#e;#t;async lock(){for(;await this.#e;)await this.#e;this.#e=new Promise(e=>{this.#t=e})}unlock(){const e=this.#t;this.#e=void 0,this.#t=void 0,e?.()}},h=class{#e;constructor(e){this.#e=e}async getSchemas(){return[]}async getTables(e={withInternalKyselyTables:!1}){let r=this.#e.selectFrom("sqlite_schema").where("type","=","table").where("name","not like","sqlite_%").select("name").$castTo();e.withInternalKyselyTables||(r=r.where("name","!=",i).where("name","!=",o));const a=await r.execute();return Promise.all(a.map(({name:t})=>this.#t(t)))}async getMetadata(e){return{tables:await this.getTables(e)}}async#t(e){const r=this.#e,a=(await r.selectFrom("sqlite_master").where("name","=",e).select("sql").$castTo().execute())[0]?.sql?.split(/[\(\),]/)?.find(t=>t.toLowerCase().includes("autoincrement"))?.split(/\s+/)?.[0]?.replace(/["`]/g,"");return{name:e,columns:(await r.selectFrom(c`pragma_table_info(${e})`.as("table_info")).select(["name","type","notnull","dflt_value"]).execute()).map(t=>({name:t.name,dataType:t.type,isNullable:!t.notnull,isAutoIncrementing:t.name===a,hasDefaultValue:t.dflt_value!=null})),isView:!0}}},w=class extends n{getCurrentParameterPlaceholder(){return"?"}getLeftIdentifierWrapper(){return'"'}getRightIdentifierWrapper(){return'"'}getAutoIncrement(){return"autoincrement"}},M=class{#e;constructor(e){this.#e={...e}}createDriver(){return new u(this.#e)}createQueryCompiler(){return new w}createAdapter(){return new l}createIntrospector(e){return new h(e)}};export{M as NodeSqliteDialect};
//# sourceMappingURL=node-sqlite-dialect-DdrqUnes-CbP7ffHB.mjs.map
