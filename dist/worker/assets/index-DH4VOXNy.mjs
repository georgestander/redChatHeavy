import{az as S,aA as I}from"./worker-entry-DwuZrGJP.mjs";import"node:events";import"cloudflare:workers";import"/Users/georgestander/dev/tools/chatjs/node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/__intermediate_builds/ssr/ssr_bridge.js";import"async_hooks";import"node:os";import"node:diagnostics_channel";import"fs";import"events";import"util";import"path";import"assert";import"node:stream";import"module";import"node:path";import"url";import"buffer";import"crypto";import"node:crypto";const Q=(f,R)=>{let w=null;const j=S({config:{adapterId:"memory",adapterName:"Memory Adapter",usePlural:!1,debugLogs:R?.debugLogs||!1,supportsArrays:!0,customTransformInput(d){return(d.options.advanced?.database?.useNumberId||d.options.advanced?.database?.generateId==="serial")&&d.field==="id"&&d.action==="create"?f[d.model].length+1:d.data},transaction:async d=>{const M=structuredClone(f);try{return await d(j(w))}catch(b){throw Object.keys(f).forEach(v=>{f[v]=M[v]}),b}}},adapter:({getFieldName:d,options:M,getModelName:b})=>{const v=(e,n,c)=>n?e.sort((o,i)=>{const y=d({model:c,field:n.field}),u=o[y],t=i[y];let r=0;return u==null&&t==null?r=0:u==null?r=-1:t==null?r=1:typeof u=="string"&&typeof t=="string"?r=u.localeCompare(t):u instanceof Date&&t instanceof Date?r=u.getTime()-t.getTime():typeof u=="number"&&typeof t=="number"?r=u-t:typeof u=="boolean"&&typeof t=="boolean"?r=u===t?0:u?1:-1:r=String(u).localeCompare(String(t)),n.direction==="asc"?r:-r}):e;function h(e,n,c){const o=(t,r)=>{const m=f[r];if(!m)throw I.error(`[MemoryAdapter] Model ${r} not found in the DB`,Object.keys(f)),new Error(`Model ${r} not found`);const g=(s,p)=>{const{field:l,value:a,operator:A}=p;switch(A){case"in":if(!Array.isArray(a))throw new Error("Value must be an array");return a.includes(s[l]);case"not_in":if(!Array.isArray(a))throw new Error("Value must be an array");return!a.includes(s[l]);case"contains":return s[l].includes(a);case"starts_with":return s[l].startsWith(a);case"ends_with":return s[l].endsWith(a);case"ne":return s[l]!==a;case"gt":return a!=null&&s[l]>a;case"gte":return a!=null&&s[l]>=a;case"lt":return a!=null&&s[l]<a;case"lte":return a!=null&&s[l]<=a;default:return s[l]===a}};return m.filter(s=>{if(!t.length||t.length===0)return!0;let p=g(s,t[0]);for(const l of t){const a=g(s,l);l.connector==="OR"?p=p||a:p=p&&a}return p})};if(!c)return o(e,n);const i=o(e,n),y=new Map,u=new Map;for(const t of i){const r=String(t.id);if(!y.has(r)){const g={...t};for(const[s,p]of Object.entries(c)){const l=b(s);p.relation==="one-to-one"?g[l]=null:(g[l]=[],u.set(`${r}-${s}`,new Set))}y.set(r,g)}const m=y.get(r);for(const[g,s]of Object.entries(c)){const p=b(g),l=f[p];if(!l)throw I.error(`[MemoryAdapter] JoinOption model ${p} not found in the DB`,Object.keys(f)),new Error(`JoinOption model ${p} not found`);const a=l.filter(A=>A[s.on.to]===t[s.on.from]);if(s.relation==="one-to-one")m[p]=a[0]||null;else{const A=u.get(`${r}-${g}`),C=s.limit??100;let E=0;for(const O of a){if(E>=C)break;A.has(O.id)||(m[p].push(O),A.add(O.id),E++)}}}}return Array.from(y.values())}return{create:async({model:e,data:n})=>((M.advanced?.database?.useNumberId||M.advanced?.database?.generateId==="serial")&&(n.id=f[b(e)].length+1),f[e]||(f[e]=[]),f[e].push(n),n),findOne:async({model:e,where:n,join:c})=>{const o=h(n,e,c);if(c){const i=o;return i.length?i[0]:null}return o[0]||null},findMany:async({model:e,where:n,sortBy:c,limit:o,offset:i,join:y})=>{const u=h(n||[],e,y);if(y){const r=u;if(!r.length)return[];v(r,c,e);let m=r;return i!==void 0&&(m=m.slice(i)),o!==void 0&&(m=m.slice(0,o)),m}let t=v(u,c,e);return i!==void 0&&(t=t.slice(i)),o!==void 0&&(t=t.slice(0,o)),t||[]},count:async({model:e,where:n})=>n?h(n,e).length:f[e].length,update:async({model:e,where:n,update:c})=>{const o=h(n,e);return o.forEach(i=>{Object.assign(i,c)}),o[0]||null},delete:async({model:e,where:n})=>{const c=f[e],o=h(n,e);f[e]=c.filter(i=>!o.includes(i))},deleteMany:async({model:e,where:n})=>{const c=f[e],o=h(n,e);let i=0;return f[e]=c.filter(y=>o.includes(y)?(i++,!1):!o.includes(y)),i},updateMany({model:e,where:n,update:c}){const o=h(n,e);return o.forEach(i=>{Object.assign(i,c)}),o[0]||null}}}});return d=>(w=d,j(d))};export{Q as memoryAdapter};
//# sourceMappingURL=index-DH4VOXNy.mjs.map
