import{m as s,aq as c,ar as t,p as i,as as l,at as f,au as m,av as p,aw as y,ax as b,ay as C,c as a}from"./worker-entry-DwuZrGJP.mjs";import"/Users/georgestander/dev/tools/chatjs/node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/__intermediate_builds/ssr/ssr_bridge.js";import"node:events";import"cloudflare:workers";import"async_hooks";import"node:os";import"node:diagnostics_channel";import"fs";import"events";import"util";import"path";import"assert";import"node:stream";import"module";import"node:path";import"url";import"buffer";import"crypto";import"node:crypto";async function S({userId:e}){try{return await s.select().from(c).where(b(i(c.userId,e),p(c.userId))).orderBy(m(c.createdAt))}catch(r){throw console.error("Failed to get MCP connectors from database",r),r}}async function g({id:e}){try{const[r]=await s.select().from(c).where(i(c.id,e));return r}catch(r){throw console.error("Failed to get MCP connector by id from database",r),r}}async function B({userId:e,nameId:r,excludeId:o}){try{const n=[i(c.nameId,r),e===null?p(c.userId):i(c.userId,e)],d=o?l(...n,y`${c.id} != ${o}::uuid`):l(...n),[u]=await s.select().from(c).where(d);return u}catch(n){throw console.error("Failed to get MCP connector by nameId from database",n),n}}async function I({userId:e,name:r,nameId:o,url:n,type:d,oauthClientId:u,oauthClientSecret:h}){try{const[w]=await s.insert(c).values({userId:e,name:r,nameId:o,url:n,type:d,oauthClientId:u??null,oauthClientSecret:h??null}).returning();return w}catch(w){throw console.error("Failed to create MCP connector in database",w),w}}async function q({id:e,updates:r}){try{await s.update(c).set({...r,updatedAt:new Date}).where(i(c.id,e))}catch(o){throw console.error("Failed to update MCP connector in database",o),o}}async function M({id:e}){try{await s.delete(c).where(i(c.id,e))}catch(r){throw console.error("Failed to delete MCP connector from database",r),r}}async function A({mcpConnectorId:e}){const[r]=await s.select().from(t).where(l(i(t.mcpConnectorId,e),f(t.tokens))).orderBy(m(t.updatedAt)).limit(1);return r}async function O({state:e}){if(!e)return;const[r]=await s.select().from(t).where(i(t.state,e));return r}async function v({mcpConnectorId:e,serverUrl:r,state:o,codeVerifier:n,clientInfo:d}){const[u]=await s.insert(t).values({mcpConnectorId:e,serverUrl:r,state:o,codeVerifier:n,clientInfo:d}).returning();return u}async function $({state:e,codeVerifier:r}){const[o]=await s.update(t).set({codeVerifier:r}).where(l(i(t.state,e),p(t.codeVerifier))).returning();if(o)return o;const[n]=await s.select().from(t).where(i(t.state,e));if(!n)throw new Error(`Session with state ${e} not found`);return n}async function E({state:e,clientInfo:r}){const[o]=await s.update(t).set({clientInfo:r}).where(l(i(t.state,e),p(t.clientInfo))).returning();if(o)return o;const[n]=await s.select().from(t).where(i(t.state,e));if(!n)throw new Error(`Session with state ${e} not found`);return n}async function F({state:e,updates:r}){const o=Object.fromEntries(Object.entries(r).filter(([d,u])=>u!==void 0));if(Object.keys(o).length===0){const[d]=await s.select().from(t).where(i(t.state,e));if(!d)throw new Error(`Session with state ${e} not found`);return d}const[n]=await s.update(t).set(o).where(i(t.state,e)).returning();if(!n)throw new Error(`Session with state ${e} not found`);return n}async function P({state:e,mcpConnectorId:r,tokens:o}){const[n]=await s.update(t).set({tokens:o}).where(i(t.state,e)).returning();if(!n)throw new Error(`Session with state ${e} not found`);return await s.delete(t).where(l(i(t.mcpConnectorId,r),p(t.tokens),C(t.state,e))),n}async function k({state:e}){await s.delete(t).where(i(t.state,e))}async function N({mcpConnectorId:e}){await s.delete(t).where(i(t.mcpConnectorId,e))}a(S,"/lib/db/mcp-queries.ts","getMcpConnectorsByUserId");a(g,"/lib/db/mcp-queries.ts","getMcpConnectorById");a(B,"/lib/db/mcp-queries.ts","getMcpConnectorByNameId");a(I,"/lib/db/mcp-queries.ts","createMcpConnector");a(q,"/lib/db/mcp-queries.ts","updateMcpConnector");a(M,"/lib/db/mcp-queries.ts","deleteMcpConnector");a(A,"/lib/db/mcp-queries.ts","getAuthenticatedSession");a(O,"/lib/db/mcp-queries.ts","getSessionByState");a(v,"/lib/db/mcp-queries.ts","createOAuthSession");a($,"/lib/db/mcp-queries.ts","setOAuthCodeVerifierOnceByState");a(E,"/lib/db/mcp-queries.ts","setOAuthClientInfoOnceByState");a(F,"/lib/db/mcp-queries.ts","updateSessionByState");a(P,"/lib/db/mcp-queries.ts","saveTokensAndCleanup");a(k,"/lib/db/mcp-queries.ts","deleteSessionByState");a(N,"/lib/db/mcp-queries.ts","deleteSessionsByConnectorId");export{I as createMcpConnector,v as createOAuthSession,M as deleteMcpConnector,k as deleteSessionByState,N as deleteSessionsByConnectorId,A as getAuthenticatedSession,g as getMcpConnectorById,B as getMcpConnectorByNameId,S as getMcpConnectorsByUserId,O as getSessionByState,P as saveTokensAndCleanup,E as setOAuthClientInfoOnceByState,$ as setOAuthCodeVerifierOnceByState,q as updateMcpConnector,F as updateSessionByState};
//# sourceMappingURL=mcp-queries-Ch9BqnxD.mjs.map
