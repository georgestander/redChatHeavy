{"version":3,"file":"index-DH4VOXNy.mjs","sources":["../../../node_modules/.pnpm/better-auth@1.4.18_better-sqlite3@12.6.2_drizzle-kit@0.25.0_drizzle-orm@0.34.1_@cloudflare+wo_gnuc4skgho5hqg2jqlfi6hk52u/node_modules/better-auth/dist/adapters/memory-adapter/memory-adapter.mjs"],"sourcesContent":["import { logger } from \"@better-auth/core/env\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\n\n//#region src/adapters/memory-adapter/memory-adapter.ts\nconst memoryAdapter = (db, config) => {\n\tlet lazyOptions = null;\n\tconst adapterCreator = createAdapterFactory({\n\t\tconfig: {\n\t\t\tadapterId: \"memory\",\n\t\t\tadapterName: \"Memory Adapter\",\n\t\t\tusePlural: false,\n\t\t\tdebugLogs: config?.debugLogs || false,\n\t\t\tsupportsArrays: true,\n\t\t\tcustomTransformInput(props) {\n\t\t\t\tif ((props.options.advanced?.database?.useNumberId || props.options.advanced?.database?.generateId === \"serial\") && props.field === \"id\" && props.action === \"create\") return db[props.model].length + 1;\n\t\t\t\treturn props.data;\n\t\t\t},\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tconst clone = structuredClone(db);\n\t\t\t\ttry {\n\t\t\t\t\treturn await cb(adapterCreator(lazyOptions));\n\t\t\t\t} catch (error) {\n\t\t\t\t\tObject.keys(db).forEach((key) => {\n\t\t\t\t\t\tdb[key] = clone[key];\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tadapter: ({ getFieldName, options, getModelName }) => {\n\t\t\tconst applySortToRecords = (records, sortBy, model) => {\n\t\t\t\tif (!sortBy) return records;\n\t\t\t\treturn records.sort((a, b) => {\n\t\t\t\t\tconst field = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: sortBy.field\n\t\t\t\t\t});\n\t\t\t\t\tconst aValue = a[field];\n\t\t\t\t\tconst bValue = b[field];\n\t\t\t\t\tlet comparison = 0;\n\t\t\t\t\tif (aValue == null && bValue == null) comparison = 0;\n\t\t\t\t\telse if (aValue == null) comparison = -1;\n\t\t\t\t\telse if (bValue == null) comparison = 1;\n\t\t\t\t\telse if (typeof aValue === \"string\" && typeof bValue === \"string\") comparison = aValue.localeCompare(bValue);\n\t\t\t\t\telse if (aValue instanceof Date && bValue instanceof Date) comparison = aValue.getTime() - bValue.getTime();\n\t\t\t\t\telse if (typeof aValue === \"number\" && typeof bValue === \"number\") comparison = aValue - bValue;\n\t\t\t\t\telse if (typeof aValue === \"boolean\" && typeof bValue === \"boolean\") comparison = aValue === bValue ? 0 : aValue ? 1 : -1;\n\t\t\t\t\telse comparison = String(aValue).localeCompare(String(bValue));\n\t\t\t\t\treturn sortBy.direction === \"asc\" ? comparison : -comparison;\n\t\t\t\t});\n\t\t\t};\n\t\t\tfunction convertWhereClause(where, model, join) {\n\t\t\t\tconst execute = (where$1, model$1) => {\n\t\t\t\t\tconst table = db[model$1];\n\t\t\t\t\tif (!table) {\n\t\t\t\t\t\tlogger.error(`[MemoryAdapter] Model ${model$1} not found in the DB`, Object.keys(db));\n\t\t\t\t\t\tthrow new Error(`Model ${model$1} not found`);\n\t\t\t\t\t}\n\t\t\t\t\tconst evalClause = (record, clause) => {\n\t\t\t\t\t\tconst { field, value, operator } = clause;\n\t\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\t\tcase \"in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) throw new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\treturn value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) throw new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\treturn !value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"contains\": return record[field].includes(value);\n\t\t\t\t\t\t\tcase \"starts_with\": return record[field].startsWith(value);\n\t\t\t\t\t\t\tcase \"ends_with\": return record[field].endsWith(value);\n\t\t\t\t\t\t\tcase \"ne\": return record[field] !== value;\n\t\t\t\t\t\t\tcase \"gt\": return value != null && Boolean(record[field] > value);\n\t\t\t\t\t\t\tcase \"gte\": return value != null && Boolean(record[field] >= value);\n\t\t\t\t\t\t\tcase \"lt\": return value != null && Boolean(record[field] < value);\n\t\t\t\t\t\t\tcase \"lte\": return value != null && Boolean(record[field] <= value);\n\t\t\t\t\t\t\tdefault: return record[field] === value;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn table.filter((record) => {\n\t\t\t\t\t\tif (!where$1.length || where$1.length === 0) return true;\n\t\t\t\t\t\tlet result = evalClause(record, where$1[0]);\n\t\t\t\t\t\tfor (const clause of where$1) {\n\t\t\t\t\t\t\tconst clauseResult = evalClause(record, clause);\n\t\t\t\t\t\t\tif (clause.connector === \"OR\") result = result || clauseResult;\n\t\t\t\t\t\t\telse result = result && clauseResult;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tif (!join) return execute(where, model);\n\t\t\t\tconst baseRecords = execute(where, model);\n\t\t\t\tconst grouped = /* @__PURE__ */ new Map();\n\t\t\t\tconst seenIds = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const baseRecord of baseRecords) {\n\t\t\t\t\tconst baseId = String(baseRecord.id);\n\t\t\t\t\tif (!grouped.has(baseId)) {\n\t\t\t\t\t\tconst nested = { ...baseRecord };\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") nested[joinModelName] = null;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tnested[joinModelName] = [];\n\t\t\t\t\t\t\t\tseenIds.set(`${baseId}-${joinModel}`, /* @__PURE__ */ new Set());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgrouped.set(baseId, nested);\n\t\t\t\t\t}\n\t\t\t\t\tconst nestedEntry = grouped.get(baseId);\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\tconst joinTable = db[joinModelName];\n\t\t\t\t\t\tif (!joinTable) {\n\t\t\t\t\t\t\tlogger.error(`[MemoryAdapter] JoinOption model ${joinModelName} not found in the DB`, Object.keys(db));\n\t\t\t\t\t\t\tthrow new Error(`JoinOption model ${joinModelName} not found`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst matchingRecords = joinTable.filter((joinRecord) => joinRecord[joinAttr.on.to] === baseRecord[joinAttr.on.from]);\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") nestedEntry[joinModelName] = matchingRecords[0] || null;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst seenSet = seenIds.get(`${baseId}-${joinModel}`);\n\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\tlet count = 0;\n\t\t\t\t\t\t\tfor (const matchingRecord of matchingRecords) {\n\t\t\t\t\t\t\t\tif (count >= limit) break;\n\t\t\t\t\t\t\t\tif (!seenSet.has(matchingRecord.id)) {\n\t\t\t\t\t\t\t\t\tnestedEntry[joinModelName].push(matchingRecord);\n\t\t\t\t\t\t\t\t\tseenSet.add(matchingRecord.id);\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Array.from(grouped.values());\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcreate: async ({ model, data }) => {\n\t\t\t\t\tif (options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === \"serial\") data.id = db[getModelName(model)].length + 1;\n\t\t\t\t\tif (!db[model]) db[model] = [];\n\t\t\t\t\tdb[model].push(data);\n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tfindOne: async ({ model, where, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst resArray = res;\n\t\t\t\t\t\tif (!resArray.length) return null;\n\t\t\t\t\t\treturn resArray[0];\n\t\t\t\t\t}\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tfindMany: async ({ model, where, sortBy, limit, offset, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where || [], model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst resArray = res;\n\t\t\t\t\t\tif (!resArray.length) return [];\n\t\t\t\t\t\tapplySortToRecords(resArray, sortBy, model);\n\t\t\t\t\t\tlet paginatedRecords = resArray;\n\t\t\t\t\t\tif (offset !== void 0) paginatedRecords = paginatedRecords.slice(offset);\n\t\t\t\t\t\tif (limit !== void 0) paginatedRecords = paginatedRecords.slice(0, limit);\n\t\t\t\t\t\treturn paginatedRecords;\n\t\t\t\t\t}\n\t\t\t\t\tlet table = applySortToRecords(res, sortBy, model);\n\t\t\t\t\tif (offset !== void 0) table = table.slice(offset);\n\t\t\t\t\tif (limit !== void 0) table = table.slice(0, limit);\n\t\t\t\t\treturn table || [];\n\t\t\t\t},\n\t\t\t\tcount: async ({ model, where }) => {\n\t\t\t\t\tif (where) return convertWhereClause(where, model).length;\n\t\t\t\t\treturn db[model].length;\n\t\t\t\t},\n\t\t\t\tupdate: async ({ model, where, update }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tdelete: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tdb[model] = table.filter((record) => !res.includes(record));\n\t\t\t\t},\n\t\t\t\tdeleteMany: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tdb[model] = table.filter((record) => {\n\t\t\t\t\t\tif (res.includes(record)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !res.includes(record);\n\t\t\t\t\t});\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\tupdateMany({ model, where, update }) {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\treturn (options) => {\n\t\tlazyOptions = options;\n\t\treturn adapterCreator(options);\n\t};\n};\n\n//#endregion\nexport { memoryAdapter };\n//# sourceMappingURL=memory-adapter.mjs.map"],"names":["memoryAdapter","db","config","lazyOptions","adapterCreator","createAdapterFactory","props","cb","clone","error","key","getFieldName","options","getModelName","applySortToRecords","records","sortBy","model","a","b","field","aValue","bValue","comparison","convertWhereClause","where","join","execute","where$1","model$1","table","logger","evalClause","record","clause","value","operator","result","clauseResult","baseRecords","grouped","seenIds","baseRecord","baseId","nested","joinModel","joinAttr","joinModelName","nestedEntry","joinTable","matchingRecords","joinRecord","seenSet","limit","count","matchingRecord","data","res","resArray","offset","paginatedRecords","update"],"mappings":"6lBAIK,MAACA,EAAgB,CAACC,EAAIC,IAAW,CACrC,IAAIC,EAAc,KAClB,MAAMC,EAAiBC,EAAqB,CAC3C,OAAQ,CACP,UAAW,SACX,YAAa,iBACb,UAAW,GACX,UAAWH,GAAQ,WAAa,GAChC,eAAgB,GAChB,qBAAqBI,EAAO,CAC3B,OAAKA,EAAM,QAAQ,UAAU,UAAU,aAAeA,EAAM,QAAQ,UAAU,UAAU,aAAe,WAAaA,EAAM,QAAU,MAAQA,EAAM,SAAW,SAAiBL,EAAGK,EAAM,KAAK,EAAE,OAAS,EAChMA,EAAM,IACd,EACA,YAAa,MAAOC,GAAO,CAC1B,MAAMC,EAAQ,gBAAgBP,CAAE,EAChC,GAAI,CACH,OAAO,MAAMM,EAAGH,EAAeD,CAAW,CAAC,CAC5C,OAASM,EAAO,CACf,aAAO,KAAKR,CAAE,EAAE,QAASS,GAAQ,CAChCT,EAAGS,CAAG,EAAIF,EAAME,CAAG,CACpB,CAAC,EACKD,CACP,CACD,CACH,EACE,QAAS,CAAC,CAAE,aAAAE,EAAc,QAAAC,EAAS,aAAAC,CAAY,IAAO,CACrD,MAAMC,EAAqB,CAACC,EAASC,EAAQC,IACvCD,EACED,EAAQ,KAAK,CAACG,EAAGC,IAAM,CAC7B,MAAMC,EAAQT,EAAa,CAC1B,MAAAM,EACA,MAAOD,EAAO,KACpB,CAAM,EACKK,EAASH,EAAEE,CAAK,EAChBE,EAASH,EAAEC,CAAK,EACtB,IAAIG,EAAa,EACjB,OAAIF,GAAU,MAAQC,GAAU,KAAMC,EAAa,EAC1CF,GAAU,KAAME,EAAa,GAC7BD,GAAU,KAAMC,EAAa,EAC7B,OAAOF,GAAW,UAAY,OAAOC,GAAW,SAAUC,EAAaF,EAAO,cAAcC,CAAM,EAClGD,aAAkB,MAAQC,aAAkB,KAAMC,EAAaF,EAAO,QAAO,EAAKC,EAAO,QAAO,EAChG,OAAOD,GAAW,UAAY,OAAOC,GAAW,SAAUC,EAAaF,EAASC,EAChF,OAAOD,GAAW,WAAa,OAAOC,GAAW,UAAWC,EAAaF,IAAWC,EAAS,EAAID,EAAS,EAAI,GAClHE,EAAa,OAAOF,CAAM,EAAE,cAAc,OAAOC,CAAM,CAAC,EACtDN,EAAO,YAAc,MAAQO,EAAa,CAACA,CACnD,CAAC,EAlBmBR,EAoBrB,SAASS,EAAmBC,EAAOR,EAAOS,EAAM,CAC/C,MAAMC,EAAU,CAACC,EAASC,IAAY,CACrC,MAAMC,EAAQ7B,EAAG4B,CAAO,EACxB,GAAI,CAACC,EACJ,MAAAC,EAAO,MAAM,yBAAyBF,CAAO,uBAAwB,OAAO,KAAK5B,CAAE,CAAC,EAC9E,IAAI,MAAM,SAAS4B,CAAO,YAAY,EAE7C,MAAMG,EAAa,CAACC,EAAQC,IAAW,CACtC,KAAM,CAAE,MAAAd,EAAO,MAAAe,EAAO,SAAAC,CAAQ,EAAKF,EACnC,OAAQE,EAAQ,CACf,IAAK,KACJ,GAAI,CAAC,MAAM,QAAQD,CAAK,EAAG,MAAM,IAAI,MAAM,wBAAwB,EACnE,OAAOA,EAAM,SAASF,EAAOb,CAAK,CAAC,EACpC,IAAK,SACJ,GAAI,CAAC,MAAM,QAAQe,CAAK,EAAG,MAAM,IAAI,MAAM,wBAAwB,EACnE,MAAO,CAACA,EAAM,SAASF,EAAOb,CAAK,CAAC,EACrC,IAAK,WAAY,OAAOa,EAAOb,CAAK,EAAE,SAASe,CAAK,EACpD,IAAK,cAAe,OAAOF,EAAOb,CAAK,EAAE,WAAWe,CAAK,EACzD,IAAK,YAAa,OAAOF,EAAOb,CAAK,EAAE,SAASe,CAAK,EACrD,IAAK,KAAM,OAAOF,EAAOb,CAAK,IAAMe,EACpC,IAAK,KAAM,OAAOA,GAAS,MAAgBF,EAAOb,CAAK,EAAIe,EAC3D,IAAK,MAAO,OAAOA,GAAS,MAAgBF,EAAOb,CAAK,GAAKe,EAC7D,IAAK,KAAM,OAAOA,GAAS,MAAgBF,EAAOb,CAAK,EAAIe,EAC3D,IAAK,MAAO,OAAOA,GAAS,MAAgBF,EAAOb,CAAK,GAAKe,EAC7D,QAAS,OAAOF,EAAOb,CAAK,IAAMe,CACzC,CACK,EACA,OAAOL,EAAM,OAAQG,GAAW,CAC/B,GAAI,CAACL,EAAQ,QAAUA,EAAQ,SAAW,EAAG,MAAO,GACpD,IAAIS,EAASL,EAAWC,EAAQL,EAAQ,CAAC,CAAC,EAC1C,UAAWM,KAAUN,EAAS,CAC7B,MAAMU,EAAeN,EAAWC,EAAQC,CAAM,EAC1CA,EAAO,YAAc,KAAMG,EAASA,GAAUC,EAC7CD,EAASA,GAAUC,CACzB,CACA,OAAOD,CACR,CAAC,CACF,EACA,GAAI,CAACX,EAAM,OAAOC,EAAQF,EAAOR,CAAK,EACtC,MAAMsB,EAAcZ,EAAQF,EAAOR,CAAK,EAClCuB,EAA0B,IAAI,IAC9BC,EAA0B,IAAI,IACpC,UAAWC,KAAcH,EAAa,CACrC,MAAMI,EAAS,OAAOD,EAAW,EAAE,EACnC,GAAI,CAACF,EAAQ,IAAIG,CAAM,EAAG,CACzB,MAAMC,EAAS,CAAE,GAAGF,CAAU,EAC9B,SAAW,CAACG,EAAWC,CAAQ,IAAK,OAAO,QAAQpB,CAAI,EAAG,CACzD,MAAMqB,EAAgBlC,EAAagC,CAAS,EACxCC,EAAS,WAAa,aAAcF,EAAOG,CAAa,EAAI,MAE/DH,EAAOG,CAAa,EAAI,CAAA,EACxBN,EAAQ,IAAI,GAAGE,CAAM,IAAIE,CAAS,GAAoB,IAAI,GAAK,EAEjE,CACAL,EAAQ,IAAIG,EAAQC,CAAM,CAC3B,CACA,MAAMI,EAAcR,EAAQ,IAAIG,CAAM,EACtC,SAAW,CAACE,EAAWC,CAAQ,IAAK,OAAO,QAAQpB,CAAI,EAAG,CACzD,MAAMqB,EAAgBlC,EAAagC,CAAS,EACtCI,EAAYhD,EAAG8C,CAAa,EAClC,GAAI,CAACE,EACJ,MAAAlB,EAAO,MAAM,oCAAoCgB,CAAa,uBAAwB,OAAO,KAAK9C,CAAE,CAAC,EAC/F,IAAI,MAAM,oBAAoB8C,CAAa,YAAY,EAE9D,MAAMG,EAAkBD,EAAU,OAAQE,GAAeA,EAAWL,EAAS,GAAG,EAAE,IAAMJ,EAAWI,EAAS,GAAG,IAAI,CAAC,EACpH,GAAIA,EAAS,WAAa,aAAcE,EAAYD,CAAa,EAAIG,EAAgB,CAAC,GAAK,SACtF,CACJ,MAAME,EAAUX,EAAQ,IAAI,GAAGE,CAAM,IAAIE,CAAS,EAAE,EAC9CQ,EAAQP,EAAS,OAAS,IAChC,IAAIQ,EAAQ,EACZ,UAAWC,KAAkBL,EAAiB,CAC7C,GAAII,GAASD,EAAO,MACfD,EAAQ,IAAIG,EAAe,EAAE,IACjCP,EAAYD,CAAa,EAAE,KAAKQ,CAAc,EAC9CH,EAAQ,IAAIG,EAAe,EAAE,EAC7BD,IAEF,CACD,CACD,CACD,CACA,OAAO,MAAM,KAAKd,EAAQ,OAAM,CAAE,CACnC,CACA,MAAO,CACN,OAAQ,MAAO,CAAE,MAAAvB,EAAO,KAAAuC,OACnB5C,EAAQ,UAAU,UAAU,aAAeA,EAAQ,UAAU,UAAU,aAAe,YAAU4C,EAAK,GAAKvD,EAAGY,EAAaI,CAAK,CAAC,EAAE,OAAS,GAC1IhB,EAAGgB,CAAK,IAAGhB,EAAGgB,CAAK,EAAI,CAAA,GAC5BhB,EAAGgB,CAAK,EAAE,KAAKuC,CAAI,EACZA,GAER,QAAS,MAAO,CAAE,MAAAvC,EAAO,MAAAQ,EAAO,KAAAC,CAAI,IAAO,CAC1C,MAAM+B,EAAMjC,EAAmBC,EAAOR,EAAOS,CAAI,EACjD,GAAIA,EAAM,CACT,MAAMgC,EAAWD,EACjB,OAAKC,EAAS,OACPA,EAAS,CAAC,EADY,IAE9B,CACA,OAAOD,EAAI,CAAC,GAAK,IAClB,EACA,SAAU,MAAO,CAAE,MAAAxC,EAAO,MAAAQ,EAAO,OAAAT,EAAQ,MAAAqC,EAAO,OAAAM,EAAQ,KAAAjC,KAAW,CAClE,MAAM+B,EAAMjC,EAAmBC,GAAS,CAAA,EAAIR,EAAOS,CAAI,EACvD,GAAIA,EAAM,CACT,MAAMgC,EAAWD,EACjB,GAAI,CAACC,EAAS,OAAQ,MAAO,CAAA,EAC7B5C,EAAmB4C,EAAU1C,EAAQC,CAAK,EAC1C,IAAI2C,EAAmBF,EACvB,OAAIC,IAAW,SAAQC,EAAmBA,EAAiB,MAAMD,CAAM,GACnEN,IAAU,SAAQO,EAAmBA,EAAiB,MAAM,EAAGP,CAAK,GACjEO,CACR,CACA,IAAI9B,EAAQhB,EAAmB2C,EAAKzC,EAAQC,CAAK,EACjD,OAAI0C,IAAW,SAAQ7B,EAAQA,EAAM,MAAM6B,CAAM,GAC7CN,IAAU,SAAQvB,EAAQA,EAAM,MAAM,EAAGuB,CAAK,GAC3CvB,GAAS,CAAA,CACjB,EACA,MAAO,MAAO,CAAE,MAAAb,EAAO,MAAAQ,KAClBA,EAAcD,EAAmBC,EAAOR,CAAK,EAAE,OAC5ChB,EAAGgB,CAAK,EAAE,OAElB,OAAQ,MAAO,CAAE,MAAAA,EAAO,MAAAQ,EAAO,OAAAoC,CAAM,IAAO,CAC3C,MAAMJ,EAAMjC,EAAmBC,EAAOR,CAAK,EAC3C,OAAAwC,EAAI,QAASxB,GAAW,CACvB,OAAO,OAAOA,EAAQ4B,CAAM,CAC7B,CAAC,EACMJ,EAAI,CAAC,GAAK,IAClB,EACA,OAAQ,MAAO,CAAE,MAAAxC,EAAO,MAAAQ,KAAY,CACnC,MAAMK,EAAQ7B,EAAGgB,CAAK,EAChBwC,EAAMjC,EAAmBC,EAAOR,CAAK,EAC3ChB,EAAGgB,CAAK,EAAIa,EAAM,OAAQG,GAAW,CAACwB,EAAI,SAASxB,CAAM,CAAC,CAC3D,EACA,WAAY,MAAO,CAAE,MAAAhB,EAAO,MAAAQ,KAAY,CACvC,MAAMK,EAAQ7B,EAAGgB,CAAK,EAChBwC,EAAMjC,EAAmBC,EAAOR,CAAK,EAC3C,IAAIqC,EAAQ,EACZ,OAAArD,EAAGgB,CAAK,EAAIa,EAAM,OAAQG,GACrBwB,EAAI,SAASxB,CAAM,GACtBqB,IACO,IAED,CAACG,EAAI,SAASxB,CAAM,CAC3B,EACMqB,CACR,EACA,WAAW,CAAE,MAAArC,EAAO,MAAAQ,EAAO,OAAAoC,CAAM,EAAI,CACpC,MAAMJ,EAAMjC,EAAmBC,EAAOR,CAAK,EAC3C,OAAAwC,EAAI,QAASxB,GAAW,CACvB,OAAO,OAAOA,EAAQ4B,CAAM,CAC7B,CAAC,EACMJ,EAAI,CAAC,GAAK,IAClB,CACJ,CACE,CACF,CAAE,EACD,OAAQ7C,IACPT,EAAcS,EACPR,EAAeQ,CAAO,EAE/B","x_google_ignoreList":[0]}