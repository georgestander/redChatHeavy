{"version":3,"file":"useQuery-DtNLQT6k.js","sources":["../../../node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/runtime/register/client.js","../../../node_modules/.pnpm/@tanstack+query-core@5.75.0/node_modules/@tanstack/query-core/build/modern/queryObserver.js","../../../node_modules/.pnpm/@tanstack+react-query@5.75.1_react@19.2.3/node_modules/@tanstack/react-query/build/modern/isRestoring.js","../../../node_modules/.pnpm/@tanstack+react-query@5.75.1_react@19.2.3/node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js","../../../node_modules/.pnpm/@tanstack+react-query@5.75.1_react@19.2.3/node_modules/@tanstack/react-query/build/modern/utils.js","../../../node_modules/.pnpm/@tanstack+react-query@5.75.1_react@19.2.3/node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js","../../../node_modules/.pnpm/@tanstack+react-query@5.75.1_react@19.2.3/node_modules/@tanstack/react-query/build/modern/suspense.js","../../../node_modules/.pnpm/@tanstack+react-query@5.75.1_react@19.2.3/node_modules/@tanstack/react-query/build/modern/useBaseQuery.js","../../../node_modules/.pnpm/@tanstack+react-query@5.75.1_react@19.2.3/node_modules/@tanstack/react-query/build/modern/useQuery.js"],"sourcesContent":["import { createServerReference as baseCreateServerReference } from \"react-server-dom-webpack/client.browser\";\nexport const createServerReference = (id, name, method, source = \"action\") => {\n    const fullId = id + \"#\" + name;\n    const proxy = baseCreateServerReference(fullId, (id, args) => {\n        return globalThis.__rsc_callServer(id, args, source, method);\n    });\n    // Attach metadata that hooks like useQuery can use\n    proxy.id = fullId;\n    proxy.method = method;\n    proxy.source = source;\n    return proxy;\n};\n","// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked?.(key);\n        return Reflect.get(target, key);\n      }\n    });\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","\"use client\";\n\n// src/isRestoring.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=isRestoring.js.map","\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\nexport {\n  noop,\n  shouldThrowError\n};\n//# sourceMappingURL=utils.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"./utils.js\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  const originalStaleTime = defaultedOptions.staleTime;\n  if (defaultedOptions.suspense) {\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { isServer, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nimport { noop } from \"./utils.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`\n      );\n    }\n  }\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions);\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: client.getQueryCache().get(defaultedOptions.queryHash),\n    suspense: defaultedOptions.suspense\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {\n    const promise = isNewCacheEntry ? (\n      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n    ) : (\n      // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n      client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n    );\n    promise?.catch(noop).finally(() => {\n      observer.updateResult();\n    });\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","\"use client\";\n\n// src/useQuery.ts\nimport { QueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useQuery(options, queryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient);\n}\nexport {\n  useQuery\n};\n//# sourceMappingURL=useQuery.js.map"],"names":["createServerReference","id","name","method","source","fullId","proxy","baseCreateServerReference","args","QueryObserver","Subscribable","client","options","#client","#selectError","#currentThenable","pendingThenable","#currentQuery","#currentQueryInitialState","#currentResult","#currentResultState","#currentResultOptions","#selectFn","#selectResult","#lastQueryWithDefinedData","#staleTimeoutId","#refetchIntervalId","#currentRefetchInterval","#trackedProps","shouldFetchOnMount","#executeFetch","#updateTimers","shouldFetchOn","#clearStaleTimeout","#clearRefetchInterval","prevOptions","prevQuery","resolveEnabled","#updateQuery","shallowEqualObjects","mounted","shouldFetchOptionally","resolveStaleTime","#updateStaleTimeout","nextRefetchInterval","#computeRefetchInterval","#updateRefetchInterval","query","result","shouldAssignObserverCurrentProperties","onPropTracked","target","key","defaultedOptions","fetchOptions","promise","noop","staleTime","isServer","isValidTimeout","timeout","timeUntilStale","nextInterval","focusManager","prevResult","prevResultState","prevResultOptions","queryInitialState","state","newState","isPlaceholderData","data","fetchOnMount","fetchOptionally","fetchState","error","errorUpdatedAt","status","skipSelect","placeholderData","replaceData","selectError","isFetching","isPending","isError","isLoading","hasData","nextResult","isStale","finalizeThenableIfPossible","thenable","recreateThenable","pending","prevThenable","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","typedKey","#notify","notifyOptions","notifyManager","listener","shouldLoadOnMount","field","value","observer","optimisticResult","IsRestoringContext","React.createContext","useIsRestoring","React.useContext","createValue","isReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","shouldThrowError","throwError","params","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","React.useEffect","getHasError","throwOnError","suspense","defaultThrowOnError","_error","ensureSuspenseTimers","originalStaleTime","willFetch","isRestoring","shouldSuspend","fetchOptimistic","useBaseQuery","Observer","queryClient","useQueryClient","isNewCacheEntry","React.useState","shouldSubscribe","React.useSyncExternalStore","React.useCallback","onStoreChange","unsubscribe","useQuery"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}