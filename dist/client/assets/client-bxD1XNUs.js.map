{"version":3,"mappings":"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","names":["MESSAGE_TYPE","TEXT_ENCODER","TEXT_DECODER","ID_LENGTH","packMessage","message","msg","jsonPayload","payloadBytes","packed","idBytes","view","errorPayload","errorBytes","unpackMessage","data","messageType","parsed","status","id","payload","error","DEFAULT_KEY","realtimeTransport","key","handleResponse","transportContext","ws","isConnected","clientId","clientUrl","isHttps","setupWebSocket","protocol","event","listenForUpdates","response","processResponse","ensureWs","realtimeCallServer","args","_source","_method","socket","encodeReply","__vitePreload","n","encodedArgs","requestId","promisedResponse","respondToRequest","e","streamForRsc","shouldContinue","stream1","stream2","clonedResponse","rscPayload","createFromReadableStream","rawActionResult","isActionResponse","actionResponse","location","isRedirect","err","messageTypes","resolve","reject","handler","unpacked","stream","createUpdateStreamFromSocket","onUpdate","onError","deferredStreamController","controller","streamController"],"ignoreList":[0,1,2],"sources":["../../../node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/runtime/lib/realtime/shared.js","../../../node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/runtime/lib/realtime/protocol.js","../../../node_modules/.pnpm/rwsdk@1.0.0-beta.53_@cloudflare+vite-plugin@1.23.0_bufferutil@4.1.0_vite@7.3.1_@types+node@22_zvk7ynha23nrady3r6nbat6zha/node_modules/rwsdk/dist/runtime/lib/realtime/client.js"],"sourcesContent":["export const MESSAGE_TYPE = {\n    RSC_START: 0,\n    RSC_CHUNK: 1,\n    RSC_END: 2,\n    ACTION_REQUEST: 3,\n    ACTION_START: 4,\n    ACTION_CHUNK: 5,\n    ACTION_END: 6,\n    ACTION_ERROR: 7,\n};\n","import { MESSAGE_TYPE } from \"./shared\";\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER = new TextDecoder();\nconst ID_LENGTH = 36; // Length of a UUID string\n/**\n * Packs a message object into a Uint8Array for sending over WebSocket.\n */\nexport function packMessage(message) {\n    switch (message.type) {\n        case MESSAGE_TYPE.ACTION_REQUEST: {\n            const msg = message;\n            const jsonPayload = JSON.stringify({\n                id: msg.id,\n                args: msg.args,\n                requestId: msg.requestId,\n                clientUrl: msg.clientUrl,\n            });\n            const payloadBytes = TEXT_ENCODER.encode(jsonPayload);\n            const packed = new Uint8Array(1 + payloadBytes.length);\n            packed[0] = msg.type;\n            packed.set(payloadBytes, 1);\n            return packed;\n        }\n        case MESSAGE_TYPE.ACTION_START:\n        case MESSAGE_TYPE.RSC_START: {\n            const msg = message;\n            const idBytes = TEXT_ENCODER.encode(msg.id);\n            if (idBytes.length !== ID_LENGTH) {\n                throw new Error(\"Invalid message ID length for START message\");\n            }\n            const packed = new Uint8Array(1 + 2 + ID_LENGTH); // 1 for type, 2 for status\n            const view = new DataView(packed.buffer);\n            view.setUint8(0, msg.type);\n            view.setUint16(1, msg.status, false); // Big-endian\n            packed.set(idBytes, 3);\n            return packed;\n        }\n        case MESSAGE_TYPE.ACTION_CHUNK:\n        case MESSAGE_TYPE.RSC_CHUNK: {\n            const msg = message;\n            const idBytes = TEXT_ENCODER.encode(msg.id);\n            if (idBytes.length !== ID_LENGTH) {\n                throw new Error(\"Invalid message ID length for CHUNK message\");\n            }\n            const packed = new Uint8Array(1 + ID_LENGTH + msg.payload.length);\n            packed[0] = msg.type;\n            packed.set(idBytes, 1);\n            packed.set(msg.payload, 1 + ID_LENGTH);\n            return packed;\n        }\n        case MESSAGE_TYPE.ACTION_END:\n        case MESSAGE_TYPE.RSC_END: {\n            const msg = message;\n            const idBytes = TEXT_ENCODER.encode(msg.id);\n            if (idBytes.length !== ID_LENGTH) {\n                throw new Error(\"Invalid message ID length for END message\");\n            }\n            const packed = new Uint8Array(1 + ID_LENGTH);\n            packed[0] = msg.type;\n            packed.set(idBytes, 1);\n            return packed;\n        }\n        case MESSAGE_TYPE.ACTION_ERROR: {\n            const msg = message;\n            const idBytes = TEXT_ENCODER.encode(msg.id);\n            if (idBytes.length !== ID_LENGTH) {\n                throw new Error(\"Invalid message ID length for ERROR message\");\n            }\n            const errorPayload = JSON.stringify({ error: msg.error });\n            const errorBytes = TEXT_ENCODER.encode(errorPayload);\n            const packed = new Uint8Array(1 + ID_LENGTH + errorBytes.length);\n            packed[0] = msg.type;\n            packed.set(idBytes, 1);\n            packed.set(errorBytes, 1 + ID_LENGTH);\n            return packed;\n        }\n        default:\n            // This should be unreachable if all message types are handled\n            throw new Error(`Unknown message type for packing`);\n    }\n}\n/**\n * Unpacks a Uint8Array from WebSocket into a message object.\n */\nexport function unpackMessage(data) {\n    if (data.length === 0) {\n        throw new Error(\"Cannot unpack empty message\");\n    }\n    const messageType = data[0];\n    switch (messageType) {\n        case MESSAGE_TYPE.ACTION_REQUEST: {\n            const jsonPayload = TEXT_DECODER.decode(data.slice(1));\n            const parsed = JSON.parse(jsonPayload);\n            return { type: messageType, ...parsed };\n        }\n        case MESSAGE_TYPE.ACTION_START:\n        case MESSAGE_TYPE.RSC_START: {\n            if (data.length !== 1 + 2 + ID_LENGTH) {\n                throw new Error(\"Invalid START message length\");\n            }\n            const view = new DataView(data.buffer);\n            const status = view.getUint16(1, false);\n            const id = TEXT_DECODER.decode(data.slice(3));\n            return { type: messageType, id, status };\n        }\n        case MESSAGE_TYPE.ACTION_CHUNK:\n        case MESSAGE_TYPE.RSC_CHUNK: {\n            if (data.length < 1 + ID_LENGTH) {\n                throw new Error(\"Invalid CHUNK message length\");\n            }\n            const id = TEXT_DECODER.decode(data.slice(1, 1 + ID_LENGTH));\n            const payload = data.slice(1 + ID_LENGTH);\n            return { type: messageType, id, payload };\n        }\n        case MESSAGE_TYPE.ACTION_END:\n        case MESSAGE_TYPE.RSC_END: {\n            if (data.length !== 1 + ID_LENGTH) {\n                throw new Error(\"Invalid END message length\");\n            }\n            const id = TEXT_DECODER.decode(data.slice(1, 1 + ID_LENGTH));\n            return { type: messageType, id };\n        }\n        case MESSAGE_TYPE.ACTION_ERROR: {\n            if (data.length < 1 + ID_LENGTH) {\n                throw new Error(\"Invalid ERROR message length\");\n            }\n            const id = TEXT_DECODER.decode(data.slice(1, 1 + ID_LENGTH));\n            const errorPayload = TEXT_DECODER.decode(data.slice(1 + ID_LENGTH));\n            let error = \"Unknown error\";\n            try {\n                error = JSON.parse(errorPayload).error;\n            }\n            catch (e) {\n                // ignore if it's not a json\n            }\n            return { type: messageType, id, error };\n        }\n        default:\n            throw new Error(`Unknown message type for unpacking: ${messageType}`);\n    }\n}\n","// context(justinvdm, 14 Aug 2025): `react-server-dom-webpack` uses this globa ___webpack_require__ global,\n// so we need to import our client entry point (which sets it), before importing\n// prettier-ignore\nimport { initClient } from \"../../client/client\";\n// prettier-ignore\nimport { isActionResponse, } from \"../../client/types\";\n// prettier-ignore\nimport { createFromReadableStream } from \"react-server-dom-webpack/client.browser\";\n// prettier-ignore\nimport { MESSAGE_TYPE } from \"./shared\";\n// prettier-ignore\nimport { packMessage, unpackMessage, } from \"./protocol\";\nconst DEFAULT_KEY = \"default\";\nexport const initRealtimeClient = ({ key = DEFAULT_KEY, handleResponse, } = {}) => {\n    const transport = realtimeTransport({ key, handleResponse });\n    return initClient({ transport, handleResponse });\n};\nexport const realtimeTransport = ({ key = DEFAULT_KEY, handleResponse, }) => (transportContext) => {\n    let ws = null;\n    let isConnected = false;\n    const clientId = crypto.randomUUID();\n    const clientUrl = new URL(window.location.href);\n    const isHttps = clientUrl.protocol === \"https:\";\n    clientUrl.protocol = \"\";\n    clientUrl.host = \"\";\n    const setupWebSocket = async () => {\n        if (ws)\n            return;\n        const protocol = isHttps ? \"wss\" : \"ws\";\n        ws = new WebSocket(`${protocol}://${window.location.host}/__realtime?` +\n            `key=${encodeURIComponent(key)}&` +\n            `url=${encodeURIComponent(clientUrl.toString())}&` +\n            `clientId=${encodeURIComponent(clientId)}&` +\n            `shouldForwardResponses=${encodeURIComponent(handleResponse ? \"true\" : \"false\")}`);\n        ws.binaryType = \"arraybuffer\";\n        ws.addEventListener(\"open\", () => {\n            isConnected = true;\n        });\n        ws.addEventListener(\"error\", (event) => {\n            console.error(\"[Realtime] WebSocket error\", event);\n        });\n        ws.addEventListener(\"close\", () => {\n            console.warn(\"[Realtime] WebSocket closed, attempting to reconnect...\");\n            ws = null;\n            isConnected = false;\n            setTimeout(setupWebSocket, 5000);\n        });\n        listenForUpdates(ws, (response) => {\n            processResponse(response);\n        });\n    };\n    const ensureWs = () => {\n        if (!ws && isConnected) {\n            throw new Error(\"Inconsistent state: WebSocket is null but marked as connected\");\n        }\n        if (!ws || !isConnected) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        return ws;\n    };\n    const realtimeCallServer = async (id, args, _source, _method) => {\n        try {\n            const socket = ensureWs();\n            const { encodeReply } = await import(\"react-server-dom-webpack/client.browser\");\n            // Note(peterp, 2025-07-02): We need to send the \"current URL\" per message,\n            // in case the user has enabled client side navigation.\n            const clientUrl = new URL(window.location.href);\n            clientUrl.protocol = \"\";\n            clientUrl.host = \"\";\n            const encodedArgs = args != null ? await encodeReply(args) : null;\n            const requestId = crypto.randomUUID();\n            const message = packMessage({\n                type: MESSAGE_TYPE.ACTION_REQUEST,\n                id,\n                args: encodedArgs,\n                requestId,\n                clientUrl: clientUrl.toString(),\n            });\n            const promisedResponse = respondToRequest(requestId, socket);\n            socket.send(message);\n            return await processResponse(await promisedResponse);\n        }\n        catch (e) {\n            console.error(\"[Realtime] Error calling server\", e);\n            return undefined;\n        }\n    };\n    const processResponse = async (response) => {\n        try {\n            let streamForRsc;\n            let shouldContinue = true;\n            if (transportContext.handleResponse) {\n                const [stream1, stream2] = response.body.tee();\n                const clonedResponse = new Response(stream1, response);\n                streamForRsc = stream2;\n                shouldContinue = transportContext.handleResponse(clonedResponse);\n            }\n            else {\n                streamForRsc = response.body;\n            }\n            if (!shouldContinue) {\n                return undefined;\n            }\n            const rscPayload = createFromReadableStream(streamForRsc, {\n                callServer: realtimeCallServer,\n            });\n            transportContext.setRscPayload(rscPayload);\n            const rawActionResult = (await rscPayload).actionResult;\n            if (isActionResponse(rawActionResult)) {\n                const actionResponse = rawActionResult.__rw_action_response;\n                const handledByHook = transportContext.onActionResponse?.(actionResponse) === true;\n                if (!handledByHook) {\n                    const location = actionResponse.headers[\"location\"];\n                    const isRedirect = actionResponse.status >= 300 && actionResponse.status < 400;\n                    if (location && isRedirect) {\n                        window.location.href = location;\n                        return undefined;\n                    }\n                }\n                return rawActionResult;\n            }\n            return rawActionResult;\n        }\n        catch (err) {\n            throw err;\n        }\n    };\n    setupWebSocket();\n    return realtimeCallServer;\n};\nfunction respondToRequest(requestId, socket) {\n    const messageTypes = {\n        start: MESSAGE_TYPE.ACTION_START,\n        chunk: MESSAGE_TYPE.ACTION_CHUNK,\n        end: MESSAGE_TYPE.ACTION_END,\n        error: MESSAGE_TYPE.ACTION_ERROR,\n    };\n    return new Promise((resolve, reject) => {\n        const handler = (event) => {\n            const unpacked = unpackMessage(new Uint8Array(event.data));\n            if (unpacked.type === MESSAGE_TYPE.ACTION_REQUEST) {\n                return;\n            }\n            if (unpacked.id !== requestId) {\n                return;\n            }\n            if (unpacked.type === messageTypes.start) {\n                const message = unpacked;\n                socket.removeEventListener(\"message\", handler);\n                const stream = createUpdateStreamFromSocket(requestId, socket, messageTypes, reject);\n                const response = new Response(stream, {\n                    status: message.status,\n                    headers: { \"Content-Type\": \"text/plain\" },\n                });\n                resolve(response);\n            }\n        };\n        socket.addEventListener(\"message\", handler);\n    });\n}\nfunction listenForUpdates(socket, onUpdate) {\n    const messageTypes = {\n        start: MESSAGE_TYPE.RSC_START,\n        chunk: MESSAGE_TYPE.RSC_CHUNK,\n        end: MESSAGE_TYPE.RSC_END,\n    };\n    const handler = async (event) => {\n        const unpacked = unpackMessage(new Uint8Array(event.data));\n        if (unpacked.type === MESSAGE_TYPE.ACTION_REQUEST ||\n            unpacked.type === MESSAGE_TYPE.ACTION_CHUNK ||\n            unpacked.type === MESSAGE_TYPE.ACTION_END ||\n            unpacked.type === MESSAGE_TYPE.ACTION_ERROR) {\n            return;\n        }\n        if (unpacked.type === messageTypes.start) {\n            const message = unpacked;\n            const stream = createUpdateStreamFromSocket(message.id, socket, messageTypes, (error) => {\n                console.error(\"[Realtime] Error creating update stream\", error);\n            });\n            const response = new Response(stream, {\n                status: message.status,\n                headers: { \"Content-Type\": \"text/plain\" },\n            });\n            onUpdate(response);\n        }\n    };\n    socket.addEventListener(\"message\", handler);\n}\nconst createUpdateStreamFromSocket = (id, socket, messageTypes, onError) => {\n    let deferredStreamController = Promise.withResolvers();\n    const stream = new ReadableStream({\n        start(controller) {\n            deferredStreamController.resolve(controller);\n        },\n    });\n    const handler = async (event) => {\n        const unpacked = unpackMessage(new Uint8Array(event.data));\n        if (unpacked.type === MESSAGE_TYPE.ACTION_REQUEST) {\n            return;\n        }\n        if (unpacked.id !== id) {\n            return;\n        }\n        const streamController = await deferredStreamController.promise;\n        if (unpacked.type === messageTypes.chunk) {\n            const message = unpacked;\n            streamController.enqueue(message.payload);\n        }\n        else if (unpacked.type === messageTypes.end) {\n            streamController.close();\n            socket.removeEventListener(\"message\", handler);\n        }\n        else if (messageTypes.error && unpacked.type === messageTypes.error) {\n            const message = unpacked;\n            onError(new Error(message.error));\n            socket.removeEventListener(\"message\", handler);\n        }\n    };\n    socket.addEventListener(\"message\", handler);\n    return stream;\n};\n"],"file":"client-bxD1XNUs.js"}